{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/CG00.png","path":"img/CG00.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/NO logo3.jpg","path":"img/NO logo3.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/background.webp","path":"img/background.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/Head.webp","path":"img/Head.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bird.png","path":"img/bird.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/background.css","path":"css/background.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/myFunction.js","path":"js/myFunction.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/02.两数相加问题.md","hash":"f4f3960c877685838ec9786f2b975865824a0788","modified":1646487644102},{"_id":"source/_posts/Var、let、const的异同.md","hash":"bdb7dda6c68a9ff365f278d5d80ec3975bfaf225","modified":1646487607583},{"_id":"source/categories/index.md","hash":"155a7810395a33cc7c4839a43a0c9f3a79c489aa","modified":1646333034902},{"_id":"source/_posts/01-两数之和问题.md","hash":"d9eb2ebe1b5b88756f160cc09e50180bd3462902","modified":1646357090253},{"_id":"source/about/index.md","hash":"aa69048a5688dce23719b394d4faafb1bf8cfd5a","modified":1646333034902},{"_id":"source/tags/index.md","hash":"2e651a158e8a62b859401334fa7a8f597cb862a0","modified":1646333034903},{"_id":"source/_posts/KAG：回到标题与BookMark.md","hash":"9b55c3a60ce7590445e85f10320e7705c66e0e2d","modified":1646356395896},{"_id":"source/_posts/假山问题-浅探transform参数与warper函数.md","hash":"1ca6c8f1df82e795e109731022918697f84c648d","modified":1646333034891},{"_id":"source/_posts/获取当前标签名.md","hash":"2a9720221824e49cccbd774f1d1eb900698b69e8","modified":1646333034901},{"_id":"themes/butterfly/_config.yml","hash":"b79f9e483326d9c1609ebd5429bdeda9fc4a980b","modified":1646485786219},{"_id":"themes/butterfly/package.json","hash":"ff4e6e90badea36f89e79a3c7a25e67dcdf36e32","modified":1646292563455},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1646292563403},{"_id":"themes/butterfly/languages/en.yml","hash":"69ed4d7aa63a26afd539321784d27494fbebffe8","modified":1646292563419},{"_id":"themes/butterfly/languages/default.yml","hash":"54a412ace93549f02f8e44fcf3e1cacb161a64db","modified":1646292563419},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"c9675ad7721dd20c9f7731438181a891b43553e6","modified":1646292563420},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1646292563424},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"813eb75fbf274b26e2a0c0c75f359f810ad5eeff","modified":1646292563420},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1646292563454},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1646292563454},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1646292563424},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1646292563454},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1646292563455},{"_id":"themes/butterfly/README.md","hash":"2555c3e418157a0fda35d3deaf029f12e5a12f12","modified":1646292563405},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1646292563425},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"8459729db2978bebd7f3668f6dc00a5bb100e633","modified":1646292563426},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1646292563402},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1646292563403},{"_id":"themes/butterfly/README_CN.md","hash":"84fa5880f5358abe919eb295aad3cfd17b69b631","modified":1646292563405},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1646292563403},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"687461a9422d1eb4d4b5a619854c79e5acc30fd7","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1646292563426},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"2cf68619af17ece9acea71aa2cb06737097890a5","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"205562ec188bfba5686c51af77486550d0927df5","modified":1646292563437},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1646292563455},{"_id":"themes/butterfly/scripts/events/config.js","hash":"e959cd313fc20c62fe23f0a7cba3d350d6131d66","modified":1646292563456},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"b92cc4648cfe5fb28c58943727823d1178b73a4a","modified":1646292563456},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1646292563456},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1646292563457},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"6c3b7d0874fa499800a4fd49894c481b05ec750c","modified":1646292563457},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b321a97420082101a4d41e6e571db1a166475e06","modified":1646292563456},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"6d4cd2393945a9316339351cab588265f5c18d73","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1646292563461},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1646292563461},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1646292563457},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"22a2c69b3e68b0e3f80decfd4a2b9c9cc213ff5c","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1646292563457},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1646292563402},{"_id":"themes/butterfly/source/img/Head.webp","hash":"5b2047c94439b9b47ad1f2b4418f3734927b98b4","modified":1646334178055},{"_id":"themes/butterfly/source/img/bird.png","hash":"59274ce45b097aa6d2838f4a7de815bcfa8260b0","modified":1646334178054},{"_id":"themes/butterfly/source/img/favicon.png","hash":"60556b56b0d5210ecbc1fed146c087edcc49ae35","modified":1646334178055},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1646292563402},{"_id":"themes/butterfly/source/css/background.css","hash":"6f4b5d1fa5d7e0be9aadfd13c7bd041d29ec45bc","modified":1646486478528},{"_id":"themes/butterfly/source/js/main.js","hash":"a2c1c55b5b8ec9a83cf6242ebc9ea9be95e1f0c1","modified":1646292563479},{"_id":"themes/butterfly/source/css/var.styl","hash":"584ef7b18d5e677eb2e62f9b139097d3b714a993","modified":1646292563477},{"_id":"themes/butterfly/source/js/myFunction.js","hash":"d66669ee3c164da320bf6d9ae84602c365bd05d2","modified":1646487692545},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1646292563477},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1646292563479},{"_id":"themes/butterfly/source/js/utils.js","hash":"fdb9e5b38f076953a2431b8f682388b030694b55","modified":1646292563481},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"b8e3e07b0e8f3cf25af9550c6361725a05045b92","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fc3e67e5ae4774d9e89964ba96beed28f34ee8f0","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"a9e56b1c41bf327859b0a7bcb8e72b458bd851b2","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"3b0b2053fe9f08cbc21b3baa53163adc2f76c19a","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1646292563433},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"9c8e65939d048a579ea08d063c0f98550376f536","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1646292563433},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e2eba0fcb8332cb333b2aff9c76664e40e2e1974","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"8f43fdeaf8cff4a35bab74b48c963786ca015620","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1646292563438},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"61a220bf134201bdf49430b578305191421c547c","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"311d883dede2a6838bf24ba9e4b3f69e62d5b3f1","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"935dde9cf4c1fef0214dbb9935ecb71805735be0","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"c02b1779bd0ebca6749f195be096b6ca574bfa29","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1646292563453},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d35d156b06f4da25a048872f1cfc35ad49092515","modified":1646292563462},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"5e0e9e9b2cd3c256d52423e2278e790aa387a53a","modified":1646292563454},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1646292563454},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"b9d7d23dc8810542b8c8ffcbfbd3694318debcc6","modified":1646292563462},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"a2aa5caf338ff5323b6ff0601ebcc09e710d8398","modified":1646292563463},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1646292563465},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1646292563466},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"b62d41e079e45146f0019694156049c5f1be040a","modified":1646292563466},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e931ef81754a7b9d999fa23d134c620e68e75491","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"844858ae87c7278996ce484c6b456db354c48764","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"f3aac52defb3497079a313e8c63ac2f7ee24dfbe","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"35c7fa4e18cefe01b62e0caedccbdc0c26b3546c","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"1c1c585ba99cb4004956b5e98fc044260b456f99","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"4258fa2e590aeea704660008aed7f0362fac72d4","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"988a947f80c218d8c2279c9975f46d0c2a3d0b6e","modified":1646292563469},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"d72218cb5a6bfe048ae1c92009bd815a08a53d3a","modified":1646292563471},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1646292563471},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1646292563470},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a714776e3d585369f2285b6bb4e1564539c58d8b","modified":1646292563472},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1646292563472},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1646292563473},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"c42b872df237726483d93d6124b8751d4f64cf86","modified":1646292563472},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0bcd07ffbd2a86a1b24eaefabd7e278034b14ee2","modified":1646292563470},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"1fed25162d7204480e9bcf476b3246e1717107ca","modified":1646292563470},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1646292563474},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1646292563481},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"84c42716e833d2d1dd47195ea996803ffa0e58ec","modified":1646292563475},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f84268708a9ea3c417426bf194bdfea9f7374628","modified":1646292563473},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"076cd87805207c9b5612ec9771f6994287f4c169","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1646292563476},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1646292563477},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"107b9e586b12d1fe7bb5b6e53fcc8e31516ab3ba","modified":1646292563474},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f9bee6cac49de1171076560acf6a6eec96647c56","modified":1646292563473},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1646292563438},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"9ddfac9ae7071ecd982ca3808dcfd4d2d6098f33","modified":1646292563441},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1646292563441},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a780962b3a04cac4b296ce809ee7101e42cf3a37","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"e6d48579029c253b85f2abbba5997d6baf9a10ae","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"b22ed23c78fb372cbdc4cfd3f733beb2ebea5d74","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"414f876d28f8497d6d551363a89c5c69bf1533eb","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"810e8ca2669433f649329859922aabbb30d76178","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"21098eba47237ec003228e7fa70a5fbb14d6c804","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"3f10e67c7618615cc85d50e4a3694f3d8b262952","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"d1ac48307e4999be08c63c673e98fe3fcee5bfce","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0f287b10408b4455d946a69677549fcfd302e8c0","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6dd420ea858f3237d8a7353e8541df665dd6fdf1","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"cd1ce86441dc508e4c3dbf8b829046455ba8a6b4","modified":1646292563446},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b2ede1f6b41026ebd233ac076a405889a6eec76b","modified":1646292563446},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"444820bc7e4a9a033062bcd8cd71b10b49d1968a","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"3b42d3b8468431655112705bff7530ce647f8c05","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"c9e6e14770317a3516e2e2f320654cd52b1bd73a","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"a5aa867697578660fe78a0d9b0f245d09b571110","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1646292563450},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"7ce18e4b22c41dcfd84835e89b47030fc5f4a394","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1646292563450},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1646292563451},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1646292563463},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1646292563450},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1646292563463},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1646292563464},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"2086c6ad3c48ded263a36b230485ed0c15293f8e","modified":1646292563481},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"d684f2a60fe821d61761a01cf36fd2fb57c31c9c","modified":1646292563480},{"_id":"themes/butterfly/source/img/NO logo3.jpg","hash":"f7d7bd4066b31890388e76ec1bff9fd0e3265806","modified":1646339319045},{"_id":"themes/butterfly/source/img/background.webp","hash":"2d4f1081568cab516f591cf53c2cd33a327df485","modified":1646334178055},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1646292563464},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1646292563464},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fc8b7ef3778e7270a3543bc56708d0abad090da0","modified":1646334178054},{"_id":"themes/butterfly/source/img/CG00.png","hash":"dcf445309417704c7fedbacc6342b722490cd43f","modified":1646334178058},{"_id":"public/tags/index.html","hash":"8e4c040e1f7206ff1baa00faa96ea91c228859b4","modified":1646568818822},{"_id":"public/about/index.html","hash":"a2aa85b953366345625863d661121ab33f1062fb","modified":1646568818822},{"_id":"public/categories/index.html","hash":"d2b91ef4ecae8abf73203f8118b00a6005dd826c","modified":1646568818822},{"_id":"public/2022/03/05/Var、let、const的异同/index.html","hash":"6d56764d7644dfa251c3bd1f5d95d69122dc7b74","modified":1646568818822},{"_id":"public/2022/03/04/01-两数之和问题/index.html","hash":"8dd3935a6818a9e90d87ef45cfe5ceb0daddc1c9","modified":1646568818822},{"_id":"public/2022/03/04/02.两数相加问题/index.html","hash":"2b302ef7b1e63503208a07dc34c2d206e58c88fe","modified":1646568818822},{"_id":"public/2022/03/04/KAG：回到标题与BookMark/index.html","hash":"cd2f1c5f7a8e620483518bd5f35a19c7b1ab855a","modified":1646568818822},{"_id":"public/2022/03/03/假山问题-浅探transform参数与warper函数/index.html","hash":"e038fd80c85c70df39849d0de1a38d44a1449ae1","modified":1646568818822},{"_id":"public/2022/03/03/获取当前标签名/index.html","hash":"64903ba8904027e5b43e6056fbc5a622a91c4bdc","modified":1646568818822},{"_id":"public/archives/index.html","hash":"2b736fcb05470a18937a829ec79d8706deed2d1a","modified":1646568818822},{"_id":"public/archives/2022/03/index.html","hash":"9c738b25d4b969bbb78e46c5943760e29d1d1bc3","modified":1646568818822},{"_id":"public/archives/2022/index.html","hash":"f647974fa374fe548676b1e78389812e3c5ccc21","modified":1646568818822},{"_id":"public/categories/技术/index.html","hash":"a8c15ea9a8cad5f958faaa359baec14376eb9242","modified":1646568818822},{"_id":"public/categories/技术/JavaScript/index.html","hash":"2d77c40297a9679fd3540734283e834e2e49b79a","modified":1646568818822},{"_id":"public/categories/技术/算法/index.html","hash":"06f5400e162e8a4dbaaa22e213277e97484b6a90","modified":1646568818822},{"_id":"public/categories/技术/Renpy/index.html","hash":"4701aa23865ed118930077b3cf8fb243b2d1ab27","modified":1646568818822},{"_id":"public/categories/技术/KrKr/index.html","hash":"aef430c6949dbebfb349eded5615ffca294393eb","modified":1646568818822},{"_id":"public/tags/KrKr/index.html","hash":"0c0bd28b01a2e47c4cbfa3b92b4d17d241b1017d","modified":1646568818822},{"_id":"public/tags/算法/index.html","hash":"f791fa20b6d88e47b1d355498d021c38a4162e4c","modified":1646568818822},{"_id":"public/tags/Java/index.html","hash":"e91fd93765c07b13bb264a3727a8cdd2181b3108","modified":1646568818822},{"_id":"public/tags/JavaScript/index.html","hash":"0258e48810498c429d32c3a1f3244c415e2347c9","modified":1646568818822},{"_id":"public/index.html","hash":"591984b3edcbb5c83bd9c1f63fcb6cd11c435c85","modified":1646568818822},{"_id":"public/tags/Renpy/index.html","hash":"9307651b3aabb60259ff1f10408dbeeaeb78d1bc","modified":1646568818822},{"_id":"public/img/404.jpg","hash":"fc8b7ef3778e7270a3543bc56708d0abad090da0","modified":1646568818822},{"_id":"public/img/bird.png","hash":"59274ce45b097aa6d2838f4a7de815bcfa8260b0","modified":1646568818822},{"_id":"public/img/Head.webp","hash":"5b2047c94439b9b47ad1f2b4418f3734927b98b4","modified":1646568818822},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1646568818822},{"_id":"public/img/favicon.png","hash":"60556b56b0d5210ecbc1fed146c087edcc49ae35","modified":1646568818822},{"_id":"public/css/background.css","hash":"5c4f6b630b923ab80dd390a341a694856b0f6224","modified":1646568818822},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646568818822},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1646568818822},{"_id":"public/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1646568818822},{"_id":"public/js/myFunction.js","hash":"03231517ecb781b71f516f62817639a0bb798872","modified":1646568818822},{"_id":"public/js/search/local-search.js","hash":"ec62117f38e095425f295b1170c222c7a1399425","modified":1646568818822},{"_id":"public/css/index.css","hash":"50068a300402a1f274129b6d971d2112fdfb6cea","modified":1646568818822},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1646568818822},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1646568818822},{"_id":"public/img/background.webp","hash":"2d4f1081568cab516f591cf53c2cd33a327df485","modified":1646568818822},{"_id":"public/img/NO logo3.jpg","hash":"f7d7bd4066b31890388e76ec1bff9fd0e3265806","modified":1646568818822},{"_id":"public/img/CG00.png","hash":"dcf445309417704c7fedbacc6342b722490cd43f","modified":1646568818822},{"_id":"source/CNAME","hash":"0b414ef86e545620653ecff427ecc7bfc48575b4","modified":1646292037504},{"_id":"source/_posts/call、apply、bind的异同.md","hash":"2b25d848c0229f81b5d29aa33f435fd9a4fadba6","modified":1646642591987},{"_id":"source/_posts/JavaScript：Var、let、const的异同.md","hash":"50636f43f8f55a01cba29bbf65f0a6e14a608134","modified":1646642741953},{"_id":"source/_posts/JavaScript：call、apply、bind的异同.md","hash":"2ed5c97bd81014a750a857f7ea88ea38b9afef25","modified":1646642732140},{"_id":"source/_posts/JavaScript：作用域和作用域链.md","hash":"0097e4a429ae52db326f0ec1dcd8f79c56c0cd1d","modified":1646653608319},{"_id":"source/_posts/Renpy：获取当前标签名.md","hash":"1a0a641fffb2636adf4fac5380542933b0ae6a51","modified":1646642755210},{"_id":"source/_posts/JavaScript：闭包（Closure）的原理和目的.md","hash":"fa395f0446cf88c768076e2c4cdea0d7a7ed55ad","modified":1646655051722},{"_id":"source/_posts/Renpy：假山问题-浅探transform参数与warper函数.md","hash":"4a6665a4290463ddc8f2f40ca1bd0e506c1d64a3","modified":1646642833167},{"_id":"source/_posts/算法01.两数之和问题.md","hash":"c30c9902e240f17976703e1eb5445ff0793cc6b2","modified":1646642816030},{"_id":"source/_posts/算法02.两数相加问题.md","hash":"1eb24a3253139f0c6251e63a517a8338cab89246","modified":1646642787653}],"Category":[{"name":"技术","_id":"cl0f8k8gk0007fsuhcx1jh29n"},{"name":"JavaScript","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gq000gfsuhbabzdsva"},{"name":"算法","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gr000jfsuh0h1988b0"},{"name":"Renpy","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gs000nfsuh3u9w153m"},{"name":"KrKr","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gu000wfsuh781fgdn3"}],"Data":[],"Page":[{"title":"标签","date":"2022-03-03T08:18:48.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-03-03 16:18:48\ntype: \"tags\"\n---\n","updated":"2022-03-03T18:43:54.903Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl0f8k8g60000fsuh277p5xoe","content":"","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":""},{"title":"关于我","date":"2022-03-03T09:12:57.000Z","_content":"\n写一些关于我的东西。\n\n当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-03-03 17:12:57\n---\n\n写一些关于我的东西。\n\n当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。\n\n","updated":"2022-03-03T18:43:54.902Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl0f8k8gd0002fsuhh7gq2ui0","content":"<p>写一些关于我的东西。</p>\n<p>当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。</p>\n","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":"<p>写一些关于我的东西。</p>\n<p>当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。</p>\n"},{"title":"分类","date":"2022-03-03T08:19:33.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-03-03 16:19:33\ntype: \"categories\"\n---\n","updated":"2022-03-03T18:43:54.902Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl0f8k8gi0005fsuh3w7ycqq9","content":"","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":""}],"Post":[{"title":"KAG：回到标题与BookMark","date":"2022-03-04T01:12:18.000Z","_content":"\n## 1.回到标题机制\n\n于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。\n\n\n```kag\nfunction goToStart()\n{\n\t// 最初に戻る\n\tif(!startAnchorEnabled) return;\n\tloadBookMark(2021, false); // 栞を読み込む999\n}\nfunction goToStartWithAsk()\n{\n\t// 最初に戻る(確認あり)\n    askYesNo(\"返回标题吗？\", \"确认\", goToStart);\n}\n```\n\n其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。\n\n```kag\nfunction setStartAnchorEnabled(enabled)\n{\n\t// 「最初に戻る」の有効/無効の設定\n\tstartAnchorEnabled = enabled;\n\tif(enabled) saveBookMark(999, false); // 999 番に保存\n\tsetMenuAccessibleAll();\n}\n```\n\nloadBookMark会读取标记点的内容。\n\n**tip：标记点取决于\"\\*|\"即标签（*）以及可存储符号（|）。**\n\n**未加（|）的标签无法存储标记点。**\n\n## 2.保存标记点[startAnchor]机制\n\n在MainWindows.tjs内，制作被【】识别的function：\n\n```tjs\n  startanchor : function(elm)\n  {\n    // 「最初に戻る」の使用不可・使用可を設定する\n    setStartAnchorEnabled(elm.enabled === void || +elm.enabled);\n    return 0;\n  } incontextof this,\n```\n\n其使得\n\n```tjs\n  function setStartAnchorEnabled(enabled)\n  {\n​    // 「最初に戻る」の有効/無効の設定\n​    startAnchorEnabled = enabled;\n​    if(enabled) saveBookMark(999, false); // 999 番に保存\n​    setMenuAccessibleAll();\n  }\n```\n\n此代码块在savedata内保存了一个data999.ksd的文件\n\n**tip：data1000是记录“重载脚本”功能的存档。**\n\n\n\n## 3.saveBookMark和loadBookMark\n\n同样在MainWindows.tjs内，\n\n\n\n```\n  function saveBookMark(num, savehist = true)\n  {\n​    // 栞番号 num に栞を保存する\n​    if(readOnlyMode) return false;\n​    if(bookMarkProtectedStates[num]) return false;\n​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);\n​    if(ret)\n​    {\n​      // メニュー / bookMarkNames / bookMarkDates を更新\n​      getBookMarkInfoFromData(pcflags, num);\n​    }\n​    return ret;\n  }\n```\n\n请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。\n\n另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：\n\n```\n  function loadBookMark(num, loaduser = true)\n\n  {\n\n​    // 栞番号 num からデータを読み出す\n\n​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);\n\n  }\n```\n\n而loadBookMarkFromFile如下，\n\n```\n  function loadBookMarkFromFileWithAsk()\n  {\n​    // 任意のファイルから栞を読み込む\n​    var initialdir = \"\";\n​    if(lastSaveDataNameGlobal == \"\")\n​      initialdir = saveDataLocation + \"/\";\n​    var selectdata = %[\n​      title:\"栞をたどる\",\n​      filter: [saveThumbnail ?\n​          \"サムネイル画像付き栞データ(*.bmp)|*.bmp\" :\n​          \"栞データ(*.kdt)|*.kdt\"],\n​      filterIndex : 1,\n​      name : lastSaveDataNameGlobal,\n​      initialDir : initialdir,\n​      defaultExt : saveThumbnail?\"bmp\":\"kdt\",\n​      save : false,\n​    ];\n​    if(Storages.selectFile(selectdata))\n​    {\n​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);\n​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);\n​    }\n  }\n```\n\n目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。\n\n![KAG：回到标题与BookMark](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png)\n","source":"_posts/KAG：回到标题与BookMark.md","raw":"---\ntitle: KAG：回到标题与BookMark\ndate: 2022-03-04 09:12:18\ncategories:\n  - [技术,KrKr]\ntags: \"KrKr\"\n---\n\n## 1.回到标题机制\n\n于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。\n\n\n```kag\nfunction goToStart()\n{\n\t// 最初に戻る\n\tif(!startAnchorEnabled) return;\n\tloadBookMark(2021, false); // 栞を読み込む999\n}\nfunction goToStartWithAsk()\n{\n\t// 最初に戻る(確認あり)\n    askYesNo(\"返回标题吗？\", \"确认\", goToStart);\n}\n```\n\n其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。\n\n```kag\nfunction setStartAnchorEnabled(enabled)\n{\n\t// 「最初に戻る」の有効/無効の設定\n\tstartAnchorEnabled = enabled;\n\tif(enabled) saveBookMark(999, false); // 999 番に保存\n\tsetMenuAccessibleAll();\n}\n```\n\nloadBookMark会读取标记点的内容。\n\n**tip：标记点取决于\"\\*|\"即标签（*）以及可存储符号（|）。**\n\n**未加（|）的标签无法存储标记点。**\n\n## 2.保存标记点[startAnchor]机制\n\n在MainWindows.tjs内，制作被【】识别的function：\n\n```tjs\n  startanchor : function(elm)\n  {\n    // 「最初に戻る」の使用不可・使用可を設定する\n    setStartAnchorEnabled(elm.enabled === void || +elm.enabled);\n    return 0;\n  } incontextof this,\n```\n\n其使得\n\n```tjs\n  function setStartAnchorEnabled(enabled)\n  {\n​    // 「最初に戻る」の有効/無効の設定\n​    startAnchorEnabled = enabled;\n​    if(enabled) saveBookMark(999, false); // 999 番に保存\n​    setMenuAccessibleAll();\n  }\n```\n\n此代码块在savedata内保存了一个data999.ksd的文件\n\n**tip：data1000是记录“重载脚本”功能的存档。**\n\n\n\n## 3.saveBookMark和loadBookMark\n\n同样在MainWindows.tjs内，\n\n\n\n```\n  function saveBookMark(num, savehist = true)\n  {\n​    // 栞番号 num に栞を保存する\n​    if(readOnlyMode) return false;\n​    if(bookMarkProtectedStates[num]) return false;\n​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);\n​    if(ret)\n​    {\n​      // メニュー / bookMarkNames / bookMarkDates を更新\n​      getBookMarkInfoFromData(pcflags, num);\n​    }\n​    return ret;\n  }\n```\n\n请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。\n\n另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：\n\n```\n  function loadBookMark(num, loaduser = true)\n\n  {\n\n​    // 栞番号 num からデータを読み出す\n\n​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);\n\n  }\n```\n\n而loadBookMarkFromFile如下，\n\n```\n  function loadBookMarkFromFileWithAsk()\n  {\n​    // 任意のファイルから栞を読み込む\n​    var initialdir = \"\";\n​    if(lastSaveDataNameGlobal == \"\")\n​      initialdir = saveDataLocation + \"/\";\n​    var selectdata = %[\n​      title:\"栞をたどる\",\n​      filter: [saveThumbnail ?\n​          \"サムネイル画像付き栞データ(*.bmp)|*.bmp\" :\n​          \"栞データ(*.kdt)|*.kdt\"],\n​      filterIndex : 1,\n​      name : lastSaveDataNameGlobal,\n​      initialDir : initialdir,\n​      defaultExt : saveThumbnail?\"bmp\":\"kdt\",\n​      save : false,\n​    ];\n​    if(Storages.selectFile(selectdata))\n​    {\n​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);\n​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);\n​    }\n  }\n```\n\n目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。\n\n![KAG：回到标题与BookMark](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png)\n","slug":"KAG：回到标题与BookMark","published":1,"updated":"2022-03-04T01:13:15.896Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0f8k8gj0006fsuh924ag8r2","content":"<h2 id=\"1-回到标题机制\"><a href=\"#1-回到标题机制\" class=\"headerlink\" title=\"1.回到标题机制\"></a>1.回到标题机制</h2><p>于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goToStart()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る</span><br><span class=\"line\">\tif(!startAnchorEnabled) return;</span><br><span class=\"line\">\tloadBookMark(2021, false); // 栞を読み込む999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function goToStartWithAsk()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る(確認あり)</span><br><span class=\"line\">    askYesNo(&quot;返回标题吗？&quot;, &quot;确认&quot;, goToStart);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">\tstartAnchorEnabled = enabled;</span><br><span class=\"line\">\tif(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">\tsetMenuAccessibleAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadBookMark会读取标记点的内容。</p>\n<p><strong>tip：标记点取决于”*|”即标签（*）以及可存储符号（|）。</strong></p>\n<p><strong>未加（|）的标签无法存储标记点。</strong></p>\n<h2 id=\"2-保存标记点-startAnchor-机制\"><a href=\"#2-保存标记点-startAnchor-机制\" class=\"headerlink\" title=\"2.保存标记点[startAnchor]机制\"></a>2.保存标记点[startAnchor]机制</h2><p>在MainWindows.tjs内，制作被【】识别的function：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startanchor : function(elm)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 「最初に戻る」の使用不可・使用可を設定する</span><br><span class=\"line\">  setStartAnchorEnabled(elm.enabled === void || +elm.enabled);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125; incontextof this,</span><br></pre></td></tr></table></figure>\n\n<p>其使得</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">​    startAnchorEnabled = enabled;</span><br><span class=\"line\">​    if(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">​    setMenuAccessibleAll();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此代码块在savedata内保存了一个data999.ksd的文件</p>\n<p><strong>tip：data1000是记录“重载脚本”功能的存档。</strong></p>\n<h2 id=\"3-saveBookMark和loadBookMark\"><a href=\"#3-saveBookMark和loadBookMark\" class=\"headerlink\" title=\"3.saveBookMark和loadBookMark\"></a>3.saveBookMark和loadBookMark</h2><p>同样在MainWindows.tjs内，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function saveBookMark(num, savehist = true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 栞番号 num に栞を保存する</span><br><span class=\"line\">​    if(readOnlyMode) return false;</span><br><span class=\"line\">​    if(bookMarkProtectedStates[num]) return false;</span><br><span class=\"line\">​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);</span><br><span class=\"line\">​    if(ret)</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      // メニュー / bookMarkNames / bookMarkDates を更新</span><br><span class=\"line\">​      getBookMarkInfoFromData(pcflags, num);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">​    return ret;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。</p>\n<p>另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMark(num, loaduser = true)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    // 栞番号 num からデータを読み出す</span><br><span class=\"line\"></span><br><span class=\"line\">​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而loadBookMarkFromFile如下，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMarkFromFileWithAsk()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 任意のファイルから栞を読み込む</span><br><span class=\"line\">​    var initialdir = &quot;&quot;;</span><br><span class=\"line\">​    if(lastSaveDataNameGlobal == &quot;&quot;)</span><br><span class=\"line\">​      initialdir = saveDataLocation + &quot;/&quot;;</span><br><span class=\"line\">​    var selectdata = %[</span><br><span class=\"line\">​      title:&quot;栞をたどる&quot;,</span><br><span class=\"line\">​      filter: [saveThumbnail ?</span><br><span class=\"line\">​          &quot;サムネイル画像付き栞データ(*.bmp)|*.bmp&quot; :</span><br><span class=\"line\">​          &quot;栞データ(*.kdt)|*.kdt&quot;],</span><br><span class=\"line\">​      filterIndex : 1,</span><br><span class=\"line\">​      name : lastSaveDataNameGlobal,</span><br><span class=\"line\">​      initialDir : initialdir,</span><br><span class=\"line\">​      defaultExt : saveThumbnail?&quot;bmp&quot;:&quot;kdt&quot;,</span><br><span class=\"line\">​      save : false,</span><br><span class=\"line\">​    ];</span><br><span class=\"line\">​    if(Storages.selectFile(selectdata))</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);</span><br><span class=\"line\">​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png\" alt=\"KAG：回到标题与BookMark\"></p>\n","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":"<h2 id=\"1-回到标题机制\"><a href=\"#1-回到标题机制\" class=\"headerlink\" title=\"1.回到标题机制\"></a>1.回到标题机制</h2><p>于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goToStart()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る</span><br><span class=\"line\">\tif(!startAnchorEnabled) return;</span><br><span class=\"line\">\tloadBookMark(2021, false); // 栞を読み込む999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function goToStartWithAsk()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る(確認あり)</span><br><span class=\"line\">    askYesNo(&quot;返回标题吗？&quot;, &quot;确认&quot;, goToStart);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">\tstartAnchorEnabled = enabled;</span><br><span class=\"line\">\tif(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">\tsetMenuAccessibleAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadBookMark会读取标记点的内容。</p>\n<p><strong>tip：标记点取决于”*|”即标签（*）以及可存储符号（|）。</strong></p>\n<p><strong>未加（|）的标签无法存储标记点。</strong></p>\n<h2 id=\"2-保存标记点-startAnchor-机制\"><a href=\"#2-保存标记点-startAnchor-机制\" class=\"headerlink\" title=\"2.保存标记点[startAnchor]机制\"></a>2.保存标记点[startAnchor]机制</h2><p>在MainWindows.tjs内，制作被【】识别的function：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startanchor : function(elm)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 「最初に戻る」の使用不可・使用可を設定する</span><br><span class=\"line\">  setStartAnchorEnabled(elm.enabled === void || +elm.enabled);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125; incontextof this,</span><br></pre></td></tr></table></figure>\n\n<p>其使得</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">​    startAnchorEnabled = enabled;</span><br><span class=\"line\">​    if(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">​    setMenuAccessibleAll();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此代码块在savedata内保存了一个data999.ksd的文件</p>\n<p><strong>tip：data1000是记录“重载脚本”功能的存档。</strong></p>\n<h2 id=\"3-saveBookMark和loadBookMark\"><a href=\"#3-saveBookMark和loadBookMark\" class=\"headerlink\" title=\"3.saveBookMark和loadBookMark\"></a>3.saveBookMark和loadBookMark</h2><p>同样在MainWindows.tjs内，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function saveBookMark(num, savehist = true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 栞番号 num に栞を保存する</span><br><span class=\"line\">​    if(readOnlyMode) return false;</span><br><span class=\"line\">​    if(bookMarkProtectedStates[num]) return false;</span><br><span class=\"line\">​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);</span><br><span class=\"line\">​    if(ret)</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      // メニュー / bookMarkNames / bookMarkDates を更新</span><br><span class=\"line\">​      getBookMarkInfoFromData(pcflags, num);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">​    return ret;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。</p>\n<p>另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMark(num, loaduser = true)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    // 栞番号 num からデータを読み出す</span><br><span class=\"line\"></span><br><span class=\"line\">​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而loadBookMarkFromFile如下，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMarkFromFileWithAsk()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 任意のファイルから栞を読み込む</span><br><span class=\"line\">​    var initialdir = &quot;&quot;;</span><br><span class=\"line\">​    if(lastSaveDataNameGlobal == &quot;&quot;)</span><br><span class=\"line\">​      initialdir = saveDataLocation + &quot;/&quot;;</span><br><span class=\"line\">​    var selectdata = %[</span><br><span class=\"line\">​      title:&quot;栞をたどる&quot;,</span><br><span class=\"line\">​      filter: [saveThumbnail ?</span><br><span class=\"line\">​          &quot;サムネイル画像付き栞データ(*.bmp)|*.bmp&quot; :</span><br><span class=\"line\">​          &quot;栞データ(*.kdt)|*.kdt&quot;],</span><br><span class=\"line\">​      filterIndex : 1,</span><br><span class=\"line\">​      name : lastSaveDataNameGlobal,</span><br><span class=\"line\">​      initialDir : initialdir,</span><br><span class=\"line\">​      defaultExt : saveThumbnail?&quot;bmp&quot;:&quot;kdt&quot;,</span><br><span class=\"line\">​      save : false,</span><br><span class=\"line\">​    ];</span><br><span class=\"line\">​    if(Storages.selectFile(selectdata))</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);</span><br><span class=\"line\">​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png\" alt=\"KAG：回到标题与BookMark\"></p>\n"},{"title":"JavaScript：call、apply、bind的异同","date":"2022-03-07T08:40:48.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071642106.webp","_content":"\n# JavaScript：call、apply、bind的异同\n\n**首先，call()、apply()、bind() 都是用来重定义 this 对象的。**\n\n在ES5中，this总是指向最后调用函数的对象。\n\n## this对象\n\n```\n    var name = \"windowsName\";\n    function a() {\n        var name = \"Cherry\";\n\n        console.log(this.name);          // windowsName\n\n        console.log(\"inner:\" + this);    // inner: Window\n    }\n    a();\n    console.log(\"outer:\" + this)         // outer: Window\n```\n\n `a();`因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 `window.a()`\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    a.fn();\n```\n\n在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。\n\n```\nvar name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    window.a.fn();\n```\n\n此处对象依然是a调用的。\n\n然而，请看下面这个例子：\n\n```\n    var name = \"windowsName\";\n    var a = {\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // undefined\n        }\n    }\n    window.a.fn();\n```\n\n这里为什么会打印 `undefined` 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 `this.name` 的值是 `undefined`。\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name : null,\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // windowsName\n        }\n    }\n\n    var f = a.fn;\n    f();\n```\n\n此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。\n\n## call、apply\n\n apply 和 call 基本类似，他们的区别只是传入的参数不同。\n\ncall() 与apply()只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。\n\ncall：\n\n```\nfunction.call(thisArg, arg1, arg2, ...)\n```\n\napply：\n\n```\nfunc.apply(thisArg, [argsArray])\n```\n\n## bind\n\nbind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。\n\n**bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 `this` 被指定为 `bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。**\n\nbind：\n\n```\nfunction.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n### 柯里化（curry）\n\nbind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\n举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。\n\n柯里化的目的是为了复用参数，通过封装代码提升代码复用度。\n","source":"_posts/JavaScript：call、apply、bind的异同.md","raw":"---\ntitle: JavaScript：call、apply、bind的异同\ndate: 2022-03-07 16:40:48\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071642106.webp\"\ncategories: \n  - [技术,JavaScript]\n---\n\n# JavaScript：call、apply、bind的异同\n\n**首先，call()、apply()、bind() 都是用来重定义 this 对象的。**\n\n在ES5中，this总是指向最后调用函数的对象。\n\n## this对象\n\n```\n    var name = \"windowsName\";\n    function a() {\n        var name = \"Cherry\";\n\n        console.log(this.name);          // windowsName\n\n        console.log(\"inner:\" + this);    // inner: Window\n    }\n    a();\n    console.log(\"outer:\" + this)         // outer: Window\n```\n\n `a();`因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 `window.a()`\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    a.fn();\n```\n\n在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。\n\n```\nvar name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    window.a.fn();\n```\n\n此处对象依然是a调用的。\n\n然而，请看下面这个例子：\n\n```\n    var name = \"windowsName\";\n    var a = {\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // undefined\n        }\n    }\n    window.a.fn();\n```\n\n这里为什么会打印 `undefined` 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 `this.name` 的值是 `undefined`。\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name : null,\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // windowsName\n        }\n    }\n\n    var f = a.fn;\n    f();\n```\n\n此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。\n\n## call、apply\n\n apply 和 call 基本类似，他们的区别只是传入的参数不同。\n\ncall() 与apply()只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。\n\ncall：\n\n```\nfunction.call(thisArg, arg1, arg2, ...)\n```\n\napply：\n\n```\nfunc.apply(thisArg, [argsArray])\n```\n\n## bind\n\nbind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。\n\n**bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 `this` 被指定为 `bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。**\n\nbind：\n\n```\nfunction.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n### 柯里化（curry）\n\nbind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\n举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。\n\n柯里化的目的是为了复用参数，通过封装代码提升代码复用度。\n","slug":"JavaScript：call、apply、bind的异同","published":1,"updated":"2022-03-07T08:45:32.140Z","_id":"cl0ggkbsp0003q8uh1rvdgivt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript：call、apply、bind的异同\"><a href=\"#JavaScript：call、apply、bind的异同\" class=\"headerlink\" title=\"JavaScript：call、apply、bind的异同\"></a>JavaScript：call、apply、bind的异同</h1><p><strong>首先，call()、apply()、bind() 都是用来重定义 this 对象的。</strong></p>\n<p>在ES5中，this总是指向最后调用函数的对象。</p>\n<h2 id=\"this对象\"><a href=\"#this对象\" class=\"headerlink\" title=\"this对象\"></a>this对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    var name = &quot;Cherry&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(this.name);          // windowsName</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure>\n\n<p> <code>a();</code>因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 <code>window.a()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // Cherry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">    var a = &#123;</span><br><span class=\"line\">        name: &quot;Cherry&quot;,</span><br><span class=\"line\">        fn : function () &#123;</span><br><span class=\"line\">            console.log(this.name);      // Cherry</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>此处对象依然是a调用的。</p>\n<p>然而，请看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : null,</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // windowsName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = a.fn;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。</p>\n<h2 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h2><p> apply 和 call 基本类似，他们的区别只是传入的参数不同。</p>\n<p>call() 与apply()只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>\n<p>call：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>\n\n<p>apply：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>bind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。</p>\n<p><strong>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</strong></p>\n<p>bind：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h3><p>bind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>\n<p>举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。</p>\n<p>柯里化的目的是为了复用参数，通过封装代码提升代码复用度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript：call、apply、bind的异同\"><a href=\"#JavaScript：call、apply、bind的异同\" class=\"headerlink\" title=\"JavaScript：call、apply、bind的异同\"></a>JavaScript：call、apply、bind的异同</h1><p><strong>首先，call()、apply()、bind() 都是用来重定义 this 对象的。</strong></p>\n<p>在ES5中，this总是指向最后调用函数的对象。</p>\n<h2 id=\"this对象\"><a href=\"#this对象\" class=\"headerlink\" title=\"this对象\"></a>this对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    var name = &quot;Cherry&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(this.name);          // windowsName</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure>\n\n<p> <code>a();</code>因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 <code>window.a()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // Cherry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">    var a = &#123;</span><br><span class=\"line\">        name: &quot;Cherry&quot;,</span><br><span class=\"line\">        fn : function () &#123;</span><br><span class=\"line\">            console.log(this.name);      // Cherry</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>此处对象依然是a调用的。</p>\n<p>然而，请看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : null,</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // windowsName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = a.fn;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。</p>\n<h2 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h2><p> apply 和 call 基本类似，他们的区别只是传入的参数不同。</p>\n<p>call() 与apply()只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>\n<p>call：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>\n\n<p>apply：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>bind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。</p>\n<p><strong>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</strong></p>\n<p>bind：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h3><p>bind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>\n<p>举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。</p>\n<p>柯里化的目的是为了复用参数，通过封装代码提升代码复用度。</p>\n"},{"title":"JavaScript：Var、let、const的异同","date":"2022-03-05T11:51:25.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052139275.webp","_content":"\n# Var、let、const的异同\n\n## 一、var概述\n\n在JavaScriptES5之前，js使用var关键字来创建变量。\n\n但是，var却有三个致命的问题。\n\n### 1.赋值提升\n\n```javascript\nconsole.log(text) //undefined\n\nvar text = \"Hello\"\n```\n\n一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。\n\n```javascript\nvar text;\n\nconsole.log(text)\n\ntext = \"Hello\"\n```\n\n这便是赋值提升。\n\n### 2.声明覆盖\n\n```\nvar a = \"Hello\"\nvar a = \"world\"\nconsole.log(a) //\"world\"\n```\n\n这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。\n\n在项目中，如果依然保持声明覆盖是很危险的。\n\n### 3.私有作用域的缺失\n\n```\nfor (var i = 0; i < 2; i++) {\n    console.log(i)\n}\nconsole.log(i)\n/*\n0\n1\n2\n3\n*/\n```\n\ni这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。\n\n## 二、let和const\n\n在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。\n\n除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。\n\n```\nconst pi =3.14\npi = 3 //Uncaught TypeError: Assignment to constant variable.\n```\n\n当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。\n\n但是，如果是一个应用数据类型的话：\n\n```\nconst pi =[0,3,10]\npi[0] = 3\nconsole.log(pi);//(3) [3, 3, 10]\n```\n\n","source":"_posts/JavaScript：Var、let、const的异同.md","raw":"---\ntitle: JavaScript：Var、let、const的异同\ndate: 2022-03-05 19:51:25\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052139275.webp\"\ncategories: \n  - [技术,JavaScript]\n---\n\n# Var、let、const的异同\n\n## 一、var概述\n\n在JavaScriptES5之前，js使用var关键字来创建变量。\n\n但是，var却有三个致命的问题。\n\n### 1.赋值提升\n\n```javascript\nconsole.log(text) //undefined\n\nvar text = \"Hello\"\n```\n\n一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。\n\n```javascript\nvar text;\n\nconsole.log(text)\n\ntext = \"Hello\"\n```\n\n这便是赋值提升。\n\n### 2.声明覆盖\n\n```\nvar a = \"Hello\"\nvar a = \"world\"\nconsole.log(a) //\"world\"\n```\n\n这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。\n\n在项目中，如果依然保持声明覆盖是很危险的。\n\n### 3.私有作用域的缺失\n\n```\nfor (var i = 0; i < 2; i++) {\n    console.log(i)\n}\nconsole.log(i)\n/*\n0\n1\n2\n3\n*/\n```\n\ni这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。\n\n## 二、let和const\n\n在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。\n\n除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。\n\n```\nconst pi =3.14\npi = 3 //Uncaught TypeError: Assignment to constant variable.\n```\n\n当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。\n\n但是，如果是一个应用数据类型的话：\n\n```\nconst pi =[0,3,10]\npi[0] = 3\nconsole.log(pi);//(3) [3, 3, 10]\n```\n\n","slug":"JavaScript：Var、let、const的异同","published":1,"updated":"2022-03-07T08:45:41.953Z","_id":"cl0ggkjjk0007q8uh4l0m8qax","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Var、let、const的异同\"><a href=\"#Var、let、const的异同\" class=\"headerlink\" title=\"Var、let、const的异同\"></a>Var、let、const的异同</h1><h2 id=\"一、var概述\"><a href=\"#一、var概述\" class=\"headerlink\" title=\"一、var概述\"></a>一、var概述</h2><p>在JavaScriptES5之前，js使用var关键字来创建变量。</p>\n<p>但是，var却有三个致命的问题。</p>\n<h3 id=\"1-赋值提升\"><a href=\"#1-赋值提升\" class=\"headerlink\" title=\"1.赋值提升\"></a>1.赋值提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text)</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这便是赋值提升。</p>\n<h3 id=\"2-声明覆盖\"><a href=\"#2-声明覆盖\" class=\"headerlink\" title=\"2.声明覆盖\"></a>2.声明覆盖</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &quot;Hello&quot;</span><br><span class=\"line\">var a = &quot;world&quot;</span><br><span class=\"line\">console.log(a) //&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。</p>\n<p>在项目中，如果依然保持声明覆盖是很危险的。</p>\n<h3 id=\"3-私有作用域的缺失\"><a href=\"#3-私有作用域的缺失\" class=\"headerlink\" title=\"3.私有作用域的缺失\"></a>3.私有作用域的缺失</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i)</span><br><span class=\"line\">/*</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>i这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。</p>\n<h2 id=\"二、let和const\"><a href=\"#二、let和const\" class=\"headerlink\" title=\"二、let和const\"></a>二、let和const</h2><p>在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。</p>\n<p>除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =3.14</span><br><span class=\"line\">pi = 3 //Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<p>当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。</p>\n<p>但是，如果是一个应用数据类型的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =[0,3,10]</span><br><span class=\"line\">pi[0] = 3</span><br><span class=\"line\">console.log(pi);//(3) [3, 3, 10]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Var、let、const的异同\"><a href=\"#Var、let、const的异同\" class=\"headerlink\" title=\"Var、let、const的异同\"></a>Var、let、const的异同</h1><h2 id=\"一、var概述\"><a href=\"#一、var概述\" class=\"headerlink\" title=\"一、var概述\"></a>一、var概述</h2><p>在JavaScriptES5之前，js使用var关键字来创建变量。</p>\n<p>但是，var却有三个致命的问题。</p>\n<h3 id=\"1-赋值提升\"><a href=\"#1-赋值提升\" class=\"headerlink\" title=\"1.赋值提升\"></a>1.赋值提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text)</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这便是赋值提升。</p>\n<h3 id=\"2-声明覆盖\"><a href=\"#2-声明覆盖\" class=\"headerlink\" title=\"2.声明覆盖\"></a>2.声明覆盖</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &quot;Hello&quot;</span><br><span class=\"line\">var a = &quot;world&quot;</span><br><span class=\"line\">console.log(a) //&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。</p>\n<p>在项目中，如果依然保持声明覆盖是很危险的。</p>\n<h3 id=\"3-私有作用域的缺失\"><a href=\"#3-私有作用域的缺失\" class=\"headerlink\" title=\"3.私有作用域的缺失\"></a>3.私有作用域的缺失</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i)</span><br><span class=\"line\">/*</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>i这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。</p>\n<h2 id=\"二、let和const\"><a href=\"#二、let和const\" class=\"headerlink\" title=\"二、let和const\"></a>二、let和const</h2><p>在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。</p>\n<p>除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =3.14</span><br><span class=\"line\">pi = 3 //Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<p>当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。</p>\n<p>但是，如果是一个应用数据类型的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =[0,3,10]</span><br><span class=\"line\">pi[0] = 3</span><br><span class=\"line\">console.log(pi);//(3) [3, 3, 10]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Renpy：获取当前标签名","date":"2022-03-03T09:43:51.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png","copyright":false,"_content":"\n# 获取当前标签名\n\nrenpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。\n\n解决方法：重写callback_label函数\n\n```\ninit python:\n\n  def label_callback(name, abnormal):\n\n​    \\# devlog.info(name)\n\n​    store.current_label = name\n\n\n\n  config.label_callback = label_callback\n```\n\n直接将代码块插入脚本，再使用  **$renpy.notify(current_label)** 进行测试\n\n![result](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png)\n\n明显的，已经可以使用了\n","source":"_posts/Renpy：获取当前标签名.md","raw":"---\ntitle: Renpy：获取当前标签名\ndate: 2022-03-03 17:43:51\ncategories:\n  - [技术,Renpy]\ntags: \"Renpy\"\ncover: https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\ncopyright: false\n---\n\n# 获取当前标签名\n\nrenpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。\n\n解决方法：重写callback_label函数\n\n```\ninit python:\n\n  def label_callback(name, abnormal):\n\n​    \\# devlog.info(name)\n\n​    store.current_label = name\n\n\n\n  config.label_callback = label_callback\n```\n\n直接将代码块插入脚本，再使用  **$renpy.notify(current_label)** 进行测试\n\n![result](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png)\n\n明显的，已经可以使用了\n","slug":"Renpy：获取当前标签名","published":1,"updated":"2022-03-07T08:45:55.210Z","_id":"cl0ggkzvc000bq8uhh6wdh8da","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"获取当前标签名\"><a href=\"#获取当前标签名\" class=\"headerlink\" title=\"获取当前标签名\"></a>获取当前标签名</h1><p>renpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。</p>\n<p>解决方法：重写callback_label函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init python:</span><br><span class=\"line\"></span><br><span class=\"line\">  def label_callback(name, abnormal):</span><br><span class=\"line\"></span><br><span class=\"line\">​    \\# devlog.info(name)</span><br><span class=\"line\"></span><br><span class=\"line\">​    store.current_label = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  config.label_callback = label_callback</span><br></pre></td></tr></table></figure>\n\n<p>直接将代码块插入脚本，再使用  <strong>$renpy.notify(current_label)</strong> 进行测试</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\" alt=\"result\"></p>\n<p>明显的，已经可以使用了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"获取当前标签名\"><a href=\"#获取当前标签名\" class=\"headerlink\" title=\"获取当前标签名\"></a>获取当前标签名</h1><p>renpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。</p>\n<p>解决方法：重写callback_label函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init python:</span><br><span class=\"line\"></span><br><span class=\"line\">  def label_callback(name, abnormal):</span><br><span class=\"line\"></span><br><span class=\"line\">​    \\# devlog.info(name)</span><br><span class=\"line\"></span><br><span class=\"line\">​    store.current_label = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  config.label_callback = label_callback</span><br></pre></td></tr></table></figure>\n\n<p>直接将代码块插入脚本，再使用  <strong>$renpy.notify(current_label)</strong> 进行测试</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\" alt=\"result\"></p>\n<p>明显的，已经可以使用了</p>\n"},{"title":"Renpy：假山问题-浅探transform参数与warper函数","date":"2022-03-03T09:44:27.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/假山-蓝.png","copyright":false,"_content":"\n# 假山问题-浅探transform参数与warper函数\n\n此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。\n\n```\nimage hiddenM:\n    contains:\n        \"images/假山遮片1.png\"\n        topleft\n        ease 3 yoffset -90\n    contains:\n        \"images/假山遮片2.png\"\n        topleft\n        ease 3 yoffset 360\n\nimage fakeM = \"images/假山.png\"\n\nlabel start:\n    scene fakeM:\n        topleft\n    show hiddenM\n\n    \"测试用\"\n    return\n\n```\n\n## 1.假山问题之解\n\n先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，**contains语句的执行是即时的，不会等待子组件的完成。**contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。\n\n *(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)*\n\n将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。\n\n接下来是对图片进行transform，根据[transform特性列表](https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties)，很容易知道是对其yoffset进行更改使其改变位置。\n\n当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做[warpers](https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers)的函数。\n\n此函数的描述为：*warper是一类函数，其可以改变interpolation语句中定义的时间值。*\n\n也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。\n\n关于warper下面几个语句定义曲线就不赘述了。\n\n**值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。**\n\n## 2.假山问题之遗\n\n之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。\n\n1）两张image组件的互相重叠（层的高度）是有什么决定的？\n\n此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。\n\n2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）\n\n现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。\n\n## 3.关于其他问题的畅想\n\n也许以上此种也能解决\n\n4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动\n\n5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）\n\n8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面\n\n10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）\n\n\n\n","source":"_posts/Renpy：假山问题-浅探transform参数与warper函数.md","raw":"---\ntitle: Renpy：假山问题-浅探transform参数与warper函数\ndate: 2022-03-03 17:44:27\ncategories:\n  - [技术,Renpy]\ntags: \"Renpy\"\ncover: https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/假山-蓝.png\ncopyright: false\n---\n\n# 假山问题-浅探transform参数与warper函数\n\n此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。\n\n```\nimage hiddenM:\n    contains:\n        \"images/假山遮片1.png\"\n        topleft\n        ease 3 yoffset -90\n    contains:\n        \"images/假山遮片2.png\"\n        topleft\n        ease 3 yoffset 360\n\nimage fakeM = \"images/假山.png\"\n\nlabel start:\n    scene fakeM:\n        topleft\n    show hiddenM\n\n    \"测试用\"\n    return\n\n```\n\n## 1.假山问题之解\n\n先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，**contains语句的执行是即时的，不会等待子组件的完成。**contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。\n\n *(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)*\n\n将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。\n\n接下来是对图片进行transform，根据[transform特性列表](https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties)，很容易知道是对其yoffset进行更改使其改变位置。\n\n当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做[warpers](https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers)的函数。\n\n此函数的描述为：*warper是一类函数，其可以改变interpolation语句中定义的时间值。*\n\n也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。\n\n关于warper下面几个语句定义曲线就不赘述了。\n\n**值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。**\n\n## 2.假山问题之遗\n\n之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。\n\n1）两张image组件的互相重叠（层的高度）是有什么决定的？\n\n此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。\n\n2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）\n\n现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。\n\n## 3.关于其他问题的畅想\n\n也许以上此种也能解决\n\n4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动\n\n5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）\n\n8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面\n\n10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）\n\n\n\n","slug":"Renpy：假山问题-浅探transform参数与warper函数","published":1,"updated":"2022-03-07T08:47:13.167Z","_id":"cl0ggl1t9000fq8uhas9s1od0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"假山问题-浅探transform参数与warper函数\"><a href=\"#假山问题-浅探transform参数与warper函数\" class=\"headerlink\" title=\"假山问题-浅探transform参数与warper函数\"></a>假山问题-浅探transform参数与warper函数</h1><p>此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image hiddenM:</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片1.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset -90</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片2.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset 360</span><br><span class=\"line\"></span><br><span class=\"line\">image fakeM = &quot;images/假山.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">label start:</span><br><span class=\"line\">    scene fakeM:</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">    show hiddenM</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;测试用&quot;</span><br><span class=\"line\">    return</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-假山问题之解\"><a href=\"#1-假山问题之解\" class=\"headerlink\" title=\"1.假山问题之解\"></a>1.假山问题之解</h2><p>先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，<strong>contains语句的执行是即时的，不会等待子组件的完成。</strong>contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。</p>\n<p> <em>(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)</em></p>\n<p>将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。</p>\n<p>接下来是对图片进行transform，根据<a href=\"https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties\">transform特性列表</a>，很容易知道是对其yoffset进行更改使其改变位置。</p>\n<p>当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做<a href=\"https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers\">warpers</a>的函数。</p>\n<p>此函数的描述为：<em>warper是一类函数，其可以改变interpolation语句中定义的时间值。</em></p>\n<p>也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。</p>\n<p>关于warper下面几个语句定义曲线就不赘述了。</p>\n<p><strong>值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。</strong></p>\n<h2 id=\"2-假山问题之遗\"><a href=\"#2-假山问题之遗\" class=\"headerlink\" title=\"2.假山问题之遗\"></a>2.假山问题之遗</h2><p>之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。</p>\n<p>1）两张image组件的互相重叠（层的高度）是有什么决定的？</p>\n<p>此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。</p>\n<p>2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）</p>\n<p>现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。</p>\n<h2 id=\"3-关于其他问题的畅想\"><a href=\"#3-关于其他问题的畅想\" class=\"headerlink\" title=\"3.关于其他问题的畅想\"></a>3.关于其他问题的畅想</h2><p>也许以上此种也能解决</p>\n<p>4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动</p>\n<p>5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）</p>\n<p>8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面</p>\n<p>10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"假山问题-浅探transform参数与warper函数\"><a href=\"#假山问题-浅探transform参数与warper函数\" class=\"headerlink\" title=\"假山问题-浅探transform参数与warper函数\"></a>假山问题-浅探transform参数与warper函数</h1><p>此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image hiddenM:</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片1.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset -90</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片2.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset 360</span><br><span class=\"line\"></span><br><span class=\"line\">image fakeM = &quot;images/假山.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">label start:</span><br><span class=\"line\">    scene fakeM:</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">    show hiddenM</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;测试用&quot;</span><br><span class=\"line\">    return</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-假山问题之解\"><a href=\"#1-假山问题之解\" class=\"headerlink\" title=\"1.假山问题之解\"></a>1.假山问题之解</h2><p>先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，<strong>contains语句的执行是即时的，不会等待子组件的完成。</strong>contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。</p>\n<p> <em>(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)</em></p>\n<p>将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。</p>\n<p>接下来是对图片进行transform，根据<a href=\"https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties\">transform特性列表</a>，很容易知道是对其yoffset进行更改使其改变位置。</p>\n<p>当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做<a href=\"https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers\">warpers</a>的函数。</p>\n<p>此函数的描述为：<em>warper是一类函数，其可以改变interpolation语句中定义的时间值。</em></p>\n<p>也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。</p>\n<p>关于warper下面几个语句定义曲线就不赘述了。</p>\n<p><strong>值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。</strong></p>\n<h2 id=\"2-假山问题之遗\"><a href=\"#2-假山问题之遗\" class=\"headerlink\" title=\"2.假山问题之遗\"></a>2.假山问题之遗</h2><p>之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。</p>\n<p>1）两张image组件的互相重叠（层的高度）是有什么决定的？</p>\n<p>此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。</p>\n<p>2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）</p>\n<p>现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。</p>\n<h2 id=\"3-关于其他问题的畅想\"><a href=\"#3-关于其他问题的畅想\" class=\"headerlink\" title=\"3.关于其他问题的畅想\"></a>3.关于其他问题的畅想</h2><p>也许以上此种也能解决</p>\n<p>4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动</p>\n<p>5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）</p>\n<p>8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面</p>\n<p>10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）</p>\n"},{"title":"算法02：两数相加问题","date":"2022-03-04T01:20:15.000Z","copyright":false,"cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052140772.webp","_content":"# 两数相加问题\n\n## 1.涉及知识-链表ListNode\n\n## 2.具体题目\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n## 3.实现代码\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n## 4.思路\n\n因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。\n\nJava中链表的实现是以最小单位节点为元素，整合出来的，代码如下。\n\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    public int Listlength() {\n        int length = 0;\n        ListNode sth=this;\n        while (sth != null) {\n            sth = this.next;\n            length++;\n        }\n        return length;\n    }\n}\n```\n\n顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。\n\n","source":"_posts/算法02.两数相加问题.md","raw":"---\ntitle: 算法02：两数相加问题\ndate: 2022-03-04 09:20:15\ncategories:\n  - [技术,算法]\ntags: \n  - Java\n  - 算法\ncopyright: false\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052140772.webp\"\n---\n# 两数相加问题\n\n## 1.涉及知识-链表ListNode\n\n## 2.具体题目\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n## 3.实现代码\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n## 4.思路\n\n因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。\n\nJava中链表的实现是以最小单位节点为元素，整合出来的，代码如下。\n\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    public int Listlength() {\n        int length = 0;\n        ListNode sth=this;\n        while (sth != null) {\n            sth = this.next;\n            length++;\n        }\n        return length;\n    }\n}\n```\n\n顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。\n\n","slug":"算法02.两数相加问题","published":1,"updated":"2022-03-07T08:46:27.653Z","_id":"cl0ggla2a000oq8uha9bm8b8d","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"两数相加问题\"><a href=\"#两数相加问题\" class=\"headerlink\" title=\"两数相加问题\"></a>两数相加问题</h1><h2 id=\"1-涉及知识-链表ListNode\"><a href=\"#1-涉及知识-链表ListNode\" class=\"headerlink\" title=\"1.涉及知识-链表ListNode\"></a>1.涉及知识-链表ListNode</h2><h2 id=\"2-具体题目\"><a href=\"#2-具体题目\" class=\"headerlink\" title=\"2.具体题目\"></a>2.具体题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<h2 id=\"3-实现代码\"><a href=\"#3-实现代码\" class=\"headerlink\" title=\"3.实现代码\"></a>3.实现代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>, tail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">carry</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">null</span> || l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> l1 != <span class=\"literal\">null</span> ? l1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> l2 != <span class=\"literal\">null</span> ? l2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> n1 + n2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                head = tail = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">                tail = tail.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-思路\"><a href=\"#4-思路\" class=\"headerlink\" title=\"4.思路\"></a>4.思路</h2><p>因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。</p>\n<p>Java中链表的实现是以最小单位节点为元素，整合出来的，代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ListNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val, ListNode next) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Listlength() &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode sth=this;</span><br><span class=\"line\">        while (sth != null) &#123;</span><br><span class=\"line\">            sth = this.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"两数相加问题\"><a href=\"#两数相加问题\" class=\"headerlink\" title=\"两数相加问题\"></a>两数相加问题</h1><h2 id=\"1-涉及知识-链表ListNode\"><a href=\"#1-涉及知识-链表ListNode\" class=\"headerlink\" title=\"1.涉及知识-链表ListNode\"></a>1.涉及知识-链表ListNode</h2><h2 id=\"2-具体题目\"><a href=\"#2-具体题目\" class=\"headerlink\" title=\"2.具体题目\"></a>2.具体题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<h2 id=\"3-实现代码\"><a href=\"#3-实现代码\" class=\"headerlink\" title=\"3.实现代码\"></a>3.实现代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>, tail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">carry</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">null</span> || l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> l1 != <span class=\"literal\">null</span> ? l1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> l2 != <span class=\"literal\">null</span> ? l2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> n1 + n2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                head = tail = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">                tail = tail.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-思路\"><a href=\"#4-思路\" class=\"headerlink\" title=\"4.思路\"></a>4.思路</h2><p>因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。</p>\n<p>Java中链表的实现是以最小单位节点为元素，整合出来的，代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ListNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val, ListNode next) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Listlength() &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode sth=this;</span><br><span class=\"line\">        while (sth != null) &#123;</span><br><span class=\"line\">            sth = this.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。</p>\n"},{"title":"算法01：两数之和问题","date":"2022-03-04T01:20:15.000Z","copyright":false,"cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040924920.jpg","_content":"\n# 1.两数之和问题\n\n![两数之和问题](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png)\n\n## 解题方法\n\n```java\npublic class SumInTwoNum {\n    public int[] twoSum(int[] nums, int target) {//[2,7,11,15]\n        int[] result = new int[0];\n        for (int n = 0; n < nums.length; n++) {\n            int Vnum = target - nums[n];\n            for (int i = 0; i < nums.length; i++) {\n                if (Vnum == nums[i]) {\n                    result = new int[]{n, i};\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3,3};\n        SumInTwoNum test = new SumInTwoNum();\n        int[] result = test.twoSum(nums, 6);\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(result[i]);\n        }\n    }\n}\n```\n\n## 思路\n\n先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。\n\n## 实现过程中遇到的问题\n\n### 1.数组在主函数的输出\n\nint类型数组无法直接输出，需要一个循环结构。\n\n### 2.数组内容的写入\n\n仅支持用新数组制作复写，如result = new int[]{n, i};\n\n但是好处是这样就可以将数据传递出去了（虽然原因未知。\n\n### 3.循环结构的不停导致数组的覆写\n\n使用break；结束这一层嵌套的循环。\n\n## 官方解答\n\n### 方法一：暴力枚举\n\n思路及算法\n\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n代码\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n空间复杂度：O(1)O(1)。\n\n### 方法二：哈希表\n\n思路及算法\n\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。\n\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。\n\n空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。\n","source":"_posts/算法01.两数之和问题.md","raw":"---\ntitle: 算法01：两数之和问题\ndate: 2022-03-04 09:20:15\ncategories:\n  - [技术,算法]\ntags: \n  - Java\n  - 算法\ncopyright: false\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040924920.jpg\"\n---\n\n# 1.两数之和问题\n\n![两数之和问题](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png)\n\n## 解题方法\n\n```java\npublic class SumInTwoNum {\n    public int[] twoSum(int[] nums, int target) {//[2,7,11,15]\n        int[] result = new int[0];\n        for (int n = 0; n < nums.length; n++) {\n            int Vnum = target - nums[n];\n            for (int i = 0; i < nums.length; i++) {\n                if (Vnum == nums[i]) {\n                    result = new int[]{n, i};\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3,3};\n        SumInTwoNum test = new SumInTwoNum();\n        int[] result = test.twoSum(nums, 6);\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(result[i]);\n        }\n    }\n}\n```\n\n## 思路\n\n先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。\n\n## 实现过程中遇到的问题\n\n### 1.数组在主函数的输出\n\nint类型数组无法直接输出，需要一个循环结构。\n\n### 2.数组内容的写入\n\n仅支持用新数组制作复写，如result = new int[]{n, i};\n\n但是好处是这样就可以将数据传递出去了（虽然原因未知。\n\n### 3.循环结构的不停导致数组的覆写\n\n使用break；结束这一层嵌套的循环。\n\n## 官方解答\n\n### 方法一：暴力枚举\n\n思路及算法\n\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n代码\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n空间复杂度：O(1)O(1)。\n\n### 方法二：哈希表\n\n思路及算法\n\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。\n\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。\n\n空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。\n","slug":"算法01.两数之和问题","published":1,"updated":"2022-03-07T08:46:56.030Z","_id":"cl0ggm3rc000tq8uh1lj59ho1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-两数之和问题\"><a href=\"#1-两数之和问题\" class=\"headerlink\" title=\"1.两数之和问题\"></a>1.两数之和问题</h1><p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png\" alt=\"两数之和问题\"></p>\n<h2 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SumInTwoNum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;<span class=\"comment\">//[2,7,11,15]</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; n &lt; nums.length; n++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">Vnum</span> <span class=\"operator\">=</span> target - nums[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Vnum == nums[i]) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n, i&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">SumInTwoNum</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SumInTwoNum</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = test.twoSum(nums, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(result[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。</p>\n<h2 id=\"实现过程中遇到的问题\"><a href=\"#实现过程中遇到的问题\" class=\"headerlink\" title=\"实现过程中遇到的问题\"></a>实现过程中遇到的问题</h2><h3 id=\"1-数组在主函数的输出\"><a href=\"#1-数组在主函数的输出\" class=\"headerlink\" title=\"1.数组在主函数的输出\"></a>1.数组在主函数的输出</h3><p>int类型数组无法直接输出，需要一个循环结构。</p>\n<h3 id=\"2-数组内容的写入\"><a href=\"#2-数组内容的写入\" class=\"headerlink\" title=\"2.数组内容的写入\"></a>2.数组内容的写入</h3><p>仅支持用新数组制作复写，如result = new int[]{n, i};</p>\n<p>但是好处是这样就可以将数据传递出去了（虽然原因未知。</p>\n<h3 id=\"3-循环结构的不停导致数组的覆写\"><a href=\"#3-循环结构的不停导致数组的覆写\" class=\"headerlink\" title=\"3.循环结构的不停导致数组的覆写\"></a>3.循环结构的不停导致数组的覆写</h3><p>使用break；结束这一层嵌套的循环。</p>\n<h2 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h2><h3 id=\"方法一：暴力枚举\"><a href=\"#方法一：暴力枚举\" class=\"headerlink\" title=\"方法一：暴力枚举\"></a>方法一：暴力枚举</h3><p>思路及算法</p>\n<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p>\n<p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>\n<p>代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                if (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    return new int[]&#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p>\n<p>空间复杂度：O(1)O(1)。</p>\n<h3 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h3><p>思路及算法</p>\n<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>\n<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p>\n<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashtable.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。</p>\n<p>空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-两数之和问题\"><a href=\"#1-两数之和问题\" class=\"headerlink\" title=\"1.两数之和问题\"></a>1.两数之和问题</h1><p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png\" alt=\"两数之和问题\"></p>\n<h2 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SumInTwoNum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;<span class=\"comment\">//[2,7,11,15]</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; n &lt; nums.length; n++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">Vnum</span> <span class=\"operator\">=</span> target - nums[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Vnum == nums[i]) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n, i&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">SumInTwoNum</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SumInTwoNum</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = test.twoSum(nums, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(result[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。</p>\n<h2 id=\"实现过程中遇到的问题\"><a href=\"#实现过程中遇到的问题\" class=\"headerlink\" title=\"实现过程中遇到的问题\"></a>实现过程中遇到的问题</h2><h3 id=\"1-数组在主函数的输出\"><a href=\"#1-数组在主函数的输出\" class=\"headerlink\" title=\"1.数组在主函数的输出\"></a>1.数组在主函数的输出</h3><p>int类型数组无法直接输出，需要一个循环结构。</p>\n<h3 id=\"2-数组内容的写入\"><a href=\"#2-数组内容的写入\" class=\"headerlink\" title=\"2.数组内容的写入\"></a>2.数组内容的写入</h3><p>仅支持用新数组制作复写，如result = new int[]{n, i};</p>\n<p>但是好处是这样就可以将数据传递出去了（虽然原因未知。</p>\n<h3 id=\"3-循环结构的不停导致数组的覆写\"><a href=\"#3-循环结构的不停导致数组的覆写\" class=\"headerlink\" title=\"3.循环结构的不停导致数组的覆写\"></a>3.循环结构的不停导致数组的覆写</h3><p>使用break；结束这一层嵌套的循环。</p>\n<h2 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h2><h3 id=\"方法一：暴力枚举\"><a href=\"#方法一：暴力枚举\" class=\"headerlink\" title=\"方法一：暴力枚举\"></a>方法一：暴力枚举</h3><p>思路及算法</p>\n<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p>\n<p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>\n<p>代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                if (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    return new int[]&#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p>\n<p>空间复杂度：O(1)O(1)。</p>\n<h3 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h3><p>思路及算法</p>\n<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>\n<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p>\n<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashtable.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。</p>\n<p>空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。</p>\n"},{"title":"JavaScript：作用域和作用域链","date":"2022-03-07T09:42:00.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071744155.webp","_content":"\n# 作用域和作用域链\n\n在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）\n\n## 一、全局作用域\n\n拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:\n\n1.最外层的函数以及最外层变量:\n\n```javascript\nvar globleVariable= 'global';  // 最外层变量\nfunction globalFunc(){         // 最外层函数\n    var childVariable = 'global_child';  //函数内变量\n    function childFunc(){        // 内层函数\n        console.log(childVariable);\n    }\n    console.log(globleVariable)\n}\nconsole.log(globleVariable);  // global\nglobalFunc();                 // global\nconsole.log(childVariable)   // childVariable is not defined\nconsole.log(childFunc)       // childFunc is not defined\n```\n\n2.未定义直接赋值的变量:\n\n```\nfunction func1(){\n    special = 'special_variable';\n    var normal = 'normal_variable';\n}\nfunc1();\nconsole.log(special);    //special_variable\nconsole.log(normal)     // normal is not defined\n```\n\n由于变量提升使没有定义的变量成为全局变量。\n\n然而，即使是定义也存在问题，因为var存在变量覆盖的特性。\n\n## 二、局部作用域\n\n局部作用域一般只能在固定代码片段内可以访问到。最常见的就是**函数作用域**。\n\n### 函数作用域\n\n```\nfunction test(){\n    var num = 9;\n    // 内部可以访问\n    console.log(\"test中：\"+num);\n}\n//test外部不能访问\nconsole.log(\"test外部:\"+num);\n```\n\n![image-20220307171137786](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png)\n\n## 三、块级作用域\n\nES6新增了`let`和`const`命令，可以用来创建块级作用域变量，使用`let`命令声明的变量只在`let`命令所在`代码块`内有效。\n\nlet 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：\n\n- 变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量\n\n- 不允许反复声明\n\n## 四、作用域链\n\n### JavaScript执行原理\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析\n\n- 分析函数参数\n- 分析变量声明\n- 分析函数声明\n\n分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个`AO(Active Object 活动对象)`\n\n分析阶段分析成功后，会把给`AO(Active Object 活动对象)`给执行阶段\n\n- 引擎询问作用域，作用域中是否有这个叫X的变量\n\n- 如果作用域有X变量，引擎会使用这个变量\n\n- 如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。\n\n  \n\n这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。\n\nJavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。\n\n### 什么是作用域链\n\n作用域链是一个独特空间。当一个变量被调用，那么变量在 **被调用** 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。\n\n```\n// 定义一个全局作用域变量：\nconst fullName = \"Oluwatobi Sofela\";\n\n// 定义多层嵌套函数:\nfunction profile() {\n  function sayName() {\n    function writeName() {\n      return fullName;\n    }\n    return writeName();\n  }\n  return sayName();\n}\n\nconsole.log(profile()) // 'Oluwatobi Sofela'\n```\n\n在上述示例中，`fullName` 变量在 `writeName()` 函数作用域中被调用。\n\n因此，从变量的执行作用域到全局作用域之间存在如下作用域链：\n\n**writeName() scope ---> sayName() scope ---> profile() scope ---> global scope**\n\n换言之，从`fullName`变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。\n\n**注意：** 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。\n","source":"_posts/JavaScript：作用域和作用域链.md","raw":"---\ntitle: JavaScript：作用域和作用域链\ndate: 2022-03-07 17:42:00\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071744155.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\n# 作用域和作用域链\n\n在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）\n\n## 一、全局作用域\n\n拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:\n\n1.最外层的函数以及最外层变量:\n\n```javascript\nvar globleVariable= 'global';  // 最外层变量\nfunction globalFunc(){         // 最外层函数\n    var childVariable = 'global_child';  //函数内变量\n    function childFunc(){        // 内层函数\n        console.log(childVariable);\n    }\n    console.log(globleVariable)\n}\nconsole.log(globleVariable);  // global\nglobalFunc();                 // global\nconsole.log(childVariable)   // childVariable is not defined\nconsole.log(childFunc)       // childFunc is not defined\n```\n\n2.未定义直接赋值的变量:\n\n```\nfunction func1(){\n    special = 'special_variable';\n    var normal = 'normal_variable';\n}\nfunc1();\nconsole.log(special);    //special_variable\nconsole.log(normal)     // normal is not defined\n```\n\n由于变量提升使没有定义的变量成为全局变量。\n\n然而，即使是定义也存在问题，因为var存在变量覆盖的特性。\n\n## 二、局部作用域\n\n局部作用域一般只能在固定代码片段内可以访问到。最常见的就是**函数作用域**。\n\n### 函数作用域\n\n```\nfunction test(){\n    var num = 9;\n    // 内部可以访问\n    console.log(\"test中：\"+num);\n}\n//test外部不能访问\nconsole.log(\"test外部:\"+num);\n```\n\n![image-20220307171137786](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png)\n\n## 三、块级作用域\n\nES6新增了`let`和`const`命令，可以用来创建块级作用域变量，使用`let`命令声明的变量只在`let`命令所在`代码块`内有效。\n\nlet 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：\n\n- 变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量\n\n- 不允许反复声明\n\n## 四、作用域链\n\n### JavaScript执行原理\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析\n\n- 分析函数参数\n- 分析变量声明\n- 分析函数声明\n\n分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个`AO(Active Object 活动对象)`\n\n分析阶段分析成功后，会把给`AO(Active Object 活动对象)`给执行阶段\n\n- 引擎询问作用域，作用域中是否有这个叫X的变量\n\n- 如果作用域有X变量，引擎会使用这个变量\n\n- 如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。\n\n  \n\n这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。\n\nJavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。\n\n### 什么是作用域链\n\n作用域链是一个独特空间。当一个变量被调用，那么变量在 **被调用** 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。\n\n```\n// 定义一个全局作用域变量：\nconst fullName = \"Oluwatobi Sofela\";\n\n// 定义多层嵌套函数:\nfunction profile() {\n  function sayName() {\n    function writeName() {\n      return fullName;\n    }\n    return writeName();\n  }\n  return sayName();\n}\n\nconsole.log(profile()) // 'Oluwatobi Sofela'\n```\n\n在上述示例中，`fullName` 变量在 `writeName()` 函数作用域中被调用。\n\n因此，从变量的执行作用域到全局作用域之间存在如下作用域链：\n\n**writeName() scope ---> sayName() scope ---> profile() scope ---> global scope**\n\n换言之，从`fullName`变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。\n\n**注意：** 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。\n","slug":"JavaScript：作用域和作用域链","published":1,"updated":"2022-03-07T11:46:48.319Z","_id":"cl0gil2no000yq8uh3dge9jq3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h1><p>在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）</p>\n<h2 id=\"一、全局作用域\"><a href=\"#一、全局作用域\" class=\"headerlink\" title=\"一、全局作用域\"></a>一、全局作用域</h2><p>拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:</p>\n<p>1.最外层的函数以及最外层变量:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globleVariable= <span class=\"string\">&#x27;global&#x27;</span>;  <span class=\"comment\">// 最外层变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">globalFunc</span>(<span class=\"params\"></span>)&#123;         <span class=\"comment\">// 最外层函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> childVariable = <span class=\"string\">&#x27;global_child&#x27;</span>;  <span class=\"comment\">//函数内变量</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">childFunc</span>(<span class=\"params\"></span>)&#123;        <span class=\"comment\">// 内层函数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable);  <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"title function_\">globalFunc</span>();                 <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable)   <span class=\"comment\">// childVariable is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childFunc)       <span class=\"comment\">// childFunc is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>2.未定义直接赋值的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function func1()&#123;</span><br><span class=\"line\">    special = &#x27;special_variable&#x27;;</span><br><span class=\"line\">    var normal = &#x27;normal_variable&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\">console.log(special);    //special_variable</span><br><span class=\"line\">console.log(normal)     // normal is not defined</span><br></pre></td></tr></table></figure>\n\n<p>由于变量提升使没有定义的变量成为全局变量。</p>\n<p>然而，即使是定义也存在问题，因为var存在变量覆盖的特性。</p>\n<h2 id=\"二、局部作用域\"><a href=\"#二、局部作用域\" class=\"headerlink\" title=\"二、局部作用域\"></a>二、局部作用域</h2><p>局部作用域一般只能在固定代码片段内可以访问到。最常见的就是<strong>函数作用域</strong>。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    var num = 9;</span><br><span class=\"line\">    // 内部可以访问</span><br><span class=\"line\">    console.log(&quot;test中：&quot;+num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//test外部不能访问</span><br><span class=\"line\">console.log(&quot;test外部:&quot;+num);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png\" alt=\"image-20220307171137786\"></p>\n<h2 id=\"三、块级作用域\"><a href=\"#三、块级作用域\" class=\"headerlink\" title=\"三、块级作用域\"></a>三、块级作用域</h2><p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建块级作用域变量，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<code>代码块</code>内有效。</p>\n<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>\n<ul>\n<li><p>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</p>\n</li>\n<li><p>不允许反复声明</p>\n</li>\n</ul>\n<h2 id=\"四、作用域链\"><a href=\"#四、作用域链\" class=\"headerlink\" title=\"四、作用域链\"></a>四、作用域链</h2><h3 id=\"JavaScript执行原理\"><a href=\"#JavaScript执行原理\" class=\"headerlink\" title=\"JavaScript执行原理\"></a>JavaScript执行原理</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析</p>\n<ul>\n<li>分析函数参数</li>\n<li>分析变量声明</li>\n<li>分析函数声明</li>\n</ul>\n<p>分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个<code>AO(Active Object 活动对象)</code></p>\n<p>分析阶段分析成功后，会把给<code>AO(Active Object 活动对象)</code>给执行阶段</p>\n<ul>\n<li><p>引擎询问作用域，作用域中是否有这个叫X的变量</p>\n</li>\n<li><p>如果作用域有X变量，引擎会使用这个变量</p>\n</li>\n<li><p>如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。</p>\n</li>\n</ul>\n<p>这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。</p>\n<p>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。</p>\n<h3 id=\"什么是作用域链\"><a href=\"#什么是作用域链\" class=\"headerlink\" title=\"什么是作用域链\"></a>什么是作用域链</h3><p>作用域链是一个独特空间。当一个变量被调用，那么变量在 <strong>被调用</strong> 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局作用域变量：</span><br><span class=\"line\">const fullName = &quot;Oluwatobi Sofela&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义多层嵌套函数:</span><br><span class=\"line\">function profile() &#123;</span><br><span class=\"line\">  function sayName() &#123;</span><br><span class=\"line\">    function writeName() &#123;</span><br><span class=\"line\">      return fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return writeName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sayName();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(profile()) // &#x27;Oluwatobi Sofela&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，<code>fullName</code> 变量在 <code>writeName()</code> 函数作用域中被调用。</p>\n<p>因此，从变量的执行作用域到全局作用域之间存在如下作用域链：</p>\n<p><strong>writeName() scope —&gt; sayName() scope —&gt; profile() scope —&gt; global scope</strong></p>\n<p>换言之，从<code>fullName</code>变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。</p>\n<p><strong>注意：</strong> 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h1><p>在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）</p>\n<h2 id=\"一、全局作用域\"><a href=\"#一、全局作用域\" class=\"headerlink\" title=\"一、全局作用域\"></a>一、全局作用域</h2><p>拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:</p>\n<p>1.最外层的函数以及最外层变量:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globleVariable= <span class=\"string\">&#x27;global&#x27;</span>;  <span class=\"comment\">// 最外层变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">globalFunc</span>(<span class=\"params\"></span>)&#123;         <span class=\"comment\">// 最外层函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> childVariable = <span class=\"string\">&#x27;global_child&#x27;</span>;  <span class=\"comment\">//函数内变量</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">childFunc</span>(<span class=\"params\"></span>)&#123;        <span class=\"comment\">// 内层函数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable);  <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"title function_\">globalFunc</span>();                 <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable)   <span class=\"comment\">// childVariable is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childFunc)       <span class=\"comment\">// childFunc is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>2.未定义直接赋值的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function func1()&#123;</span><br><span class=\"line\">    special = &#x27;special_variable&#x27;;</span><br><span class=\"line\">    var normal = &#x27;normal_variable&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\">console.log(special);    //special_variable</span><br><span class=\"line\">console.log(normal)     // normal is not defined</span><br></pre></td></tr></table></figure>\n\n<p>由于变量提升使没有定义的变量成为全局变量。</p>\n<p>然而，即使是定义也存在问题，因为var存在变量覆盖的特性。</p>\n<h2 id=\"二、局部作用域\"><a href=\"#二、局部作用域\" class=\"headerlink\" title=\"二、局部作用域\"></a>二、局部作用域</h2><p>局部作用域一般只能在固定代码片段内可以访问到。最常见的就是<strong>函数作用域</strong>。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    var num = 9;</span><br><span class=\"line\">    // 内部可以访问</span><br><span class=\"line\">    console.log(&quot;test中：&quot;+num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//test外部不能访问</span><br><span class=\"line\">console.log(&quot;test外部:&quot;+num);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png\" alt=\"image-20220307171137786\"></p>\n<h2 id=\"三、块级作用域\"><a href=\"#三、块级作用域\" class=\"headerlink\" title=\"三、块级作用域\"></a>三、块级作用域</h2><p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建块级作用域变量，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<code>代码块</code>内有效。</p>\n<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>\n<ul>\n<li><p>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</p>\n</li>\n<li><p>不允许反复声明</p>\n</li>\n</ul>\n<h2 id=\"四、作用域链\"><a href=\"#四、作用域链\" class=\"headerlink\" title=\"四、作用域链\"></a>四、作用域链</h2><h3 id=\"JavaScript执行原理\"><a href=\"#JavaScript执行原理\" class=\"headerlink\" title=\"JavaScript执行原理\"></a>JavaScript执行原理</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析</p>\n<ul>\n<li>分析函数参数</li>\n<li>分析变量声明</li>\n<li>分析函数声明</li>\n</ul>\n<p>分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个<code>AO(Active Object 活动对象)</code></p>\n<p>分析阶段分析成功后，会把给<code>AO(Active Object 活动对象)</code>给执行阶段</p>\n<ul>\n<li><p>引擎询问作用域，作用域中是否有这个叫X的变量</p>\n</li>\n<li><p>如果作用域有X变量，引擎会使用这个变量</p>\n</li>\n<li><p>如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。</p>\n</li>\n</ul>\n<p>这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。</p>\n<p>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。</p>\n<h3 id=\"什么是作用域链\"><a href=\"#什么是作用域链\" class=\"headerlink\" title=\"什么是作用域链\"></a>什么是作用域链</h3><p>作用域链是一个独特空间。当一个变量被调用，那么变量在 <strong>被调用</strong> 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局作用域变量：</span><br><span class=\"line\">const fullName = &quot;Oluwatobi Sofela&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义多层嵌套函数:</span><br><span class=\"line\">function profile() &#123;</span><br><span class=\"line\">  function sayName() &#123;</span><br><span class=\"line\">    function writeName() &#123;</span><br><span class=\"line\">      return fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return writeName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sayName();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(profile()) // &#x27;Oluwatobi Sofela&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，<code>fullName</code> 变量在 <code>writeName()</code> 函数作用域中被调用。</p>\n<p>因此，从变量的执行作用域到全局作用域之间存在如下作用域链：</p>\n<p><strong>writeName() scope —&gt; sayName() scope —&gt; profile() scope —&gt; global scope</strong></p>\n<p>换言之，从<code>fullName</code>变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。</p>\n<p><strong>注意：</strong> 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。</p>\n"},{"title":"JavaScript：闭包（Closure）的原理和目的","copyright":false,"date":"2022-03-07T12:07:56.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072010147.webp","_content":"\n# JavaScript：闭包（Closure）的原理和目的\n\n## 词法作用域\n\n**词法作用域**（`Lexical Scopes`）是 `javascript` 中使用的作用域类型，**词法作用域** 也可以被叫做 **静态作用域**，与之相对的还有 **动态作用域**。那么 `javascript` 使用的 **词法作用域** 和 **动态作用域** 的区别是什么呢？看下面这段代码：\n\n```\nvar value = 1;\n\nfunction foo() {\n  console.log(value);\n}\n\nfunction bar() {\n  var value = 2;\n  foo();\n}\n\nbar();\n```\n\n![image-20220307194155261](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png)\n\n上面这段代码中，一共有三个作用域：\n\n- 全局作用域\n- `foo` 的函数作用域\n- `bar` 的函数作用域\n\n一直到这边都好理解，可是 `foo` 里访问了本地作用域中没有的变量 `value` 。根据前面说的，引擎为了拿到这个变量就要去 `foo` 的上层作用域查询，那么 `foo` 的上层作用域是什么呢？是它 **调用时** 所在的 bar 作用域？还是它 **定义时** 所在的全局作用域？\n\n这个关键的问题就是 `javascript` 中的作用域类型——**词法作用域。**\n\n> 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。\n\n**词法作用域（Lexical Scope）** 是定义表达式并能被访问的区间。\n\n换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。\n\n**注意：**\n\n- 词法作用域又叫静态作用域。\n- 一个声明 **被调用时的作用域** 不一定是它的词法作用域。相反的，**定义时的作用域** 才是词法作用域\n\n### 一个词法作用域的小示例\n\n考虑如下代码：\n\n```js\n// 定义一个全局作用域变量：\nconst myName = \"Oluwatobi\";\n\n// 在函数体内调用myName变量\nfunction getName() {\n  return myName;\n}\n\nconsole.log(getName()) // 'Oluwatobi'\n```\n\n在上述示例中，我们在全局作用域定义了`myName`变量，并在`getName()`函数作用域内调用了该变量。\n\n**问题：** `myName`变量的词法作用域是什么？全局作用域还是 `getName()`的局部作用域？\n\n**答案：** 切记 **词法作用域** 意味着 **定义时的作用域**，并不是**调用时的作用域** 。因此`myName`变量的词法作用域是全局作用域，因为我们在全局环境下定义了`myName`变量。\n\n**换言之，函数的作用域在它的定义的时候就已经确定了。**\n\n### 作用域[scope]与上下文[context]的相似与区别\n\ncontext指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。\n\n并且它们的创建者不同\n\n- 作用域是**词法分析**创建，静态\n- 执行上下文由**js引擎**创建，动态\n\n## 闭包\n\n一句话定义闭包，就是**能够访问其他函数内部变量的函数，被称为 *闭包***\n\n一般闭包的表现形式是：**闭包就是函数内部定义的函数，被返回了出去并在外部调用**。\n\n```\nfunction foo() {\n  var a = 2;\n\n  function bar() {\n    console.log( a );\n  }\n\n  return bar;\n}\n\nvar baz = foo();\n\nbaz(); // 这就形成了一个闭包\n```\n\n我们可以简单剖析一下上面代码的运行流程：\n\n1. 编译阶段，变量和函数被声明，作用域即被确定。\n2. 运行函数 `foo()`，此时会创建一个 `foo` 函数的执行上下文，执行上下文内部存储了 `foo` 中声明的所有变量函数信息。\n3. 函数 `foo` 运行完毕，将内部函数 `bar` 的引用赋值给外部的变量 `baz` ，此时 `baz` 指针指向的还是 `bar` ，因此哪怕它位于 `foo` 作用域之外，它还是能够获取到 `foo` 的内部变量。\n4. `baz` 在外部被执行，`baz` 的内部可执行代码 `console.log` 向作用域请求获取 `a` 变量，本地作用域没有找到，继续请求父级作用域，找到了 `foo` 中的 `a` 变量，返回给 `console.log`，打印出 `2`。\n\n闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。\n\n### 闭包的目的\n\n#### 1.延长变量存活时间\n\n在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。\n\n#### 2.创造私有作用域\n\n`javascript` 没有 `java` 中那种 `public` `private` 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。\n\n### 闭包的问题：内存泄露\n\n我们知道，`javascript` 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 `0` 的变量标记为失效变量并将之清除从而释放内存。\n\n然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。\n\n当然，造成内存泄露的原因有很多，除了闭包以外，还有 **全局变量的无意创建**。开发者的本意是想将变量作为局部变量使用，然而忘记写 `var` 导致变量被泄露到全局中。\n\n还有 `DOM` 的事件绑定，移除 `DOM` 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。\n","source":"_posts/JavaScript：闭包（Closure）的原理和目的.md","raw":"---\ntitle: JavaScript：闭包（Closure）的原理和目的\ncopyright: false\ndate: 2022-03-07 20:07:56\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072010147.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\n# JavaScript：闭包（Closure）的原理和目的\n\n## 词法作用域\n\n**词法作用域**（`Lexical Scopes`）是 `javascript` 中使用的作用域类型，**词法作用域** 也可以被叫做 **静态作用域**，与之相对的还有 **动态作用域**。那么 `javascript` 使用的 **词法作用域** 和 **动态作用域** 的区别是什么呢？看下面这段代码：\n\n```\nvar value = 1;\n\nfunction foo() {\n  console.log(value);\n}\n\nfunction bar() {\n  var value = 2;\n  foo();\n}\n\nbar();\n```\n\n![image-20220307194155261](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png)\n\n上面这段代码中，一共有三个作用域：\n\n- 全局作用域\n- `foo` 的函数作用域\n- `bar` 的函数作用域\n\n一直到这边都好理解，可是 `foo` 里访问了本地作用域中没有的变量 `value` 。根据前面说的，引擎为了拿到这个变量就要去 `foo` 的上层作用域查询，那么 `foo` 的上层作用域是什么呢？是它 **调用时** 所在的 bar 作用域？还是它 **定义时** 所在的全局作用域？\n\n这个关键的问题就是 `javascript` 中的作用域类型——**词法作用域。**\n\n> 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。\n\n**词法作用域（Lexical Scope）** 是定义表达式并能被访问的区间。\n\n换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。\n\n**注意：**\n\n- 词法作用域又叫静态作用域。\n- 一个声明 **被调用时的作用域** 不一定是它的词法作用域。相反的，**定义时的作用域** 才是词法作用域\n\n### 一个词法作用域的小示例\n\n考虑如下代码：\n\n```js\n// 定义一个全局作用域变量：\nconst myName = \"Oluwatobi\";\n\n// 在函数体内调用myName变量\nfunction getName() {\n  return myName;\n}\n\nconsole.log(getName()) // 'Oluwatobi'\n```\n\n在上述示例中，我们在全局作用域定义了`myName`变量，并在`getName()`函数作用域内调用了该变量。\n\n**问题：** `myName`变量的词法作用域是什么？全局作用域还是 `getName()`的局部作用域？\n\n**答案：** 切记 **词法作用域** 意味着 **定义时的作用域**，并不是**调用时的作用域** 。因此`myName`变量的词法作用域是全局作用域，因为我们在全局环境下定义了`myName`变量。\n\n**换言之，函数的作用域在它的定义的时候就已经确定了。**\n\n### 作用域[scope]与上下文[context]的相似与区别\n\ncontext指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。\n\n并且它们的创建者不同\n\n- 作用域是**词法分析**创建，静态\n- 执行上下文由**js引擎**创建，动态\n\n## 闭包\n\n一句话定义闭包，就是**能够访问其他函数内部变量的函数，被称为 *闭包***\n\n一般闭包的表现形式是：**闭包就是函数内部定义的函数，被返回了出去并在外部调用**。\n\n```\nfunction foo() {\n  var a = 2;\n\n  function bar() {\n    console.log( a );\n  }\n\n  return bar;\n}\n\nvar baz = foo();\n\nbaz(); // 这就形成了一个闭包\n```\n\n我们可以简单剖析一下上面代码的运行流程：\n\n1. 编译阶段，变量和函数被声明，作用域即被确定。\n2. 运行函数 `foo()`，此时会创建一个 `foo` 函数的执行上下文，执行上下文内部存储了 `foo` 中声明的所有变量函数信息。\n3. 函数 `foo` 运行完毕，将内部函数 `bar` 的引用赋值给外部的变量 `baz` ，此时 `baz` 指针指向的还是 `bar` ，因此哪怕它位于 `foo` 作用域之外，它还是能够获取到 `foo` 的内部变量。\n4. `baz` 在外部被执行，`baz` 的内部可执行代码 `console.log` 向作用域请求获取 `a` 变量，本地作用域没有找到，继续请求父级作用域，找到了 `foo` 中的 `a` 变量，返回给 `console.log`，打印出 `2`。\n\n闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。\n\n### 闭包的目的\n\n#### 1.延长变量存活时间\n\n在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。\n\n#### 2.创造私有作用域\n\n`javascript` 没有 `java` 中那种 `public` `private` 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。\n\n### 闭包的问题：内存泄露\n\n我们知道，`javascript` 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 `0` 的变量标记为失效变量并将之清除从而释放内存。\n\n然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。\n\n当然，造成内存泄露的原因有很多，除了闭包以外，还有 **全局变量的无意创建**。开发者的本意是想将变量作为局部变量使用，然而忘记写 `var` 导致变量被泄露到全局中。\n\n还有 `DOM` 的事件绑定，移除 `DOM` 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。\n","slug":"JavaScript：闭包（Closure）的原理和目的","published":1,"updated":"2022-03-07T12:10:51.722Z","_id":"cl0gnsq8w0012q8uhdenpg29t","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript：闭包（Closure）的原理和目的\"><a href=\"#JavaScript：闭包（Closure）的原理和目的\" class=\"headerlink\" title=\"JavaScript：闭包（Closure）的原理和目的\"></a>JavaScript：闭包（Closure）的原理和目的</h1><h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p><strong>词法作用域</strong>（<code>Lexical Scopes</code>）是 <code>javascript</code> 中使用的作用域类型，<strong>词法作用域</strong> 也可以被叫做 <strong>静态作用域</strong>，与之相对的还有 <strong>动态作用域</strong>。那么 <code>javascript</code> 使用的 <strong>词法作用域</strong> 和 <strong>动态作用域</strong> 的区别是什么呢？看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  var value = 2;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png\" alt=\"image-20220307194155261\"></p>\n<p>上面这段代码中，一共有三个作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li><code>foo</code> 的函数作用域</li>\n<li><code>bar</code> 的函数作用域</li>\n</ul>\n<p>一直到这边都好理解，可是 <code>foo</code> 里访问了本地作用域中没有的变量 <code>value</code> 。根据前面说的，引擎为了拿到这个变量就要去 <code>foo</code> 的上层作用域查询，那么 <code>foo</code> 的上层作用域是什么呢？是它 <strong>调用时</strong> 所在的 bar 作用域？还是它 <strong>定义时</strong> 所在的全局作用域？</p>\n<p>这个关键的问题就是 <code>javascript</code> 中的作用域类型——<strong>词法作用域。</strong></p>\n<blockquote>\n<p>词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</p>\n</blockquote>\n<p><strong>词法作用域（Lexical Scope）</strong> 是定义表达式并能被访问的区间。</p>\n<p>换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>词法作用域又叫静态作用域。</li>\n<li>一个声明 <strong>被调用时的作用域</strong> 不一定是它的词法作用域。相反的，<strong>定义时的作用域</strong> 才是词法作用域</li>\n</ul>\n<h3 id=\"一个词法作用域的小示例\"><a href=\"#一个词法作用域的小示例\" class=\"headerlink\" title=\"一个词法作用域的小示例\"></a>一个词法作用域的小示例</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个全局作用域变量：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myName = <span class=\"string\">&quot;Oluwatobi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在函数体内调用myName变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getName</span>()) <span class=\"comment\">// &#x27;Oluwatobi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们在全局作用域定义了<code>myName</code>变量，并在<code>getName()</code>函数作用域内调用了该变量。</p>\n<p><strong>问题：</strong> <code>myName</code>变量的词法作用域是什么？全局作用域还是 <code>getName()</code>的局部作用域？</p>\n<p><strong>答案：</strong> 切记 <strong>词法作用域</strong> 意味着 <strong>定义时的作用域</strong>，并不是<strong>调用时的作用域</strong> 。因此<code>myName</code>变量的词法作用域是全局作用域，因为我们在全局环境下定义了<code>myName</code>变量。</p>\n<p><strong>换言之，函数的作用域在它的定义的时候就已经确定了。</strong></p>\n<h3 id=\"作用域-scope-与上下文-context-的相似与区别\"><a href=\"#作用域-scope-与上下文-context-的相似与区别\" class=\"headerlink\" title=\"作用域[scope]与上下文[context]的相似与区别\"></a>作用域[scope]与上下文[context]的相似与区别</h3><p>context指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。</p>\n<p>并且它们的创建者不同</p>\n<ul>\n<li>作用域是<strong>词法分析</strong>创建，静态</li>\n<li>执行上下文由<strong>js引擎</strong>创建，动态</li>\n</ul>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>一句话定义闭包，就是<strong>能够访问其他函数内部变量的函数，被称为 <em>闭包</em></strong></p>\n<p>一般闭包的表现形式是：<strong>闭包就是函数内部定义的函数，被返回了出去并在外部调用</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">  function bar() &#123;</span><br><span class=\"line\">    console.log( a );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); // 这就形成了一个闭包</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单剖析一下上面代码的运行流程：</p>\n<ol>\n<li>编译阶段，变量和函数被声明，作用域即被确定。</li>\n<li>运行函数 <code>foo()</code>，此时会创建一个 <code>foo</code> 函数的执行上下文，执行上下文内部存储了 <code>foo</code> 中声明的所有变量函数信息。</li>\n<li>函数 <code>foo</code> 运行完毕，将内部函数 <code>bar</code> 的引用赋值给外部的变量 <code>baz</code> ，此时 <code>baz</code> 指针指向的还是 <code>bar</code> ，因此哪怕它位于 <code>foo</code> 作用域之外，它还是能够获取到 <code>foo</code> 的内部变量。</li>\n<li><code>baz</code> 在外部被执行，<code>baz</code> 的内部可执行代码 <code>console.log</code> 向作用域请求获取 <code>a</code> 变量，本地作用域没有找到，继续请求父级作用域，找到了 <code>foo</code> 中的 <code>a</code> 变量，返回给 <code>console.log</code>，打印出 <code>2</code>。</li>\n</ol>\n<p>闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。</p>\n<h3 id=\"闭包的目的\"><a href=\"#闭包的目的\" class=\"headerlink\" title=\"闭包的目的\"></a>闭包的目的</h3><h4 id=\"1-延长变量存活时间\"><a href=\"#1-延长变量存活时间\" class=\"headerlink\" title=\"1.延长变量存活时间\"></a>1.延长变量存活时间</h4><p>在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。</p>\n<h4 id=\"2-创造私有作用域\"><a href=\"#2-创造私有作用域\" class=\"headerlink\" title=\"2.创造私有作用域\"></a>2.创造私有作用域</h4><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。</p>\n<h3 id=\"闭包的问题：内存泄露\"><a href=\"#闭包的问题：内存泄露\" class=\"headerlink\" title=\"闭包的问题：内存泄露\"></a>闭包的问题：内存泄露</h3><p>我们知道，<code>javascript</code> 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p>\n<p>然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。</p>\n<p>当然，造成内存泄露的原因有很多，除了闭包以外，还有 <strong>全局变量的无意创建</strong>。开发者的本意是想将变量作为局部变量使用，然而忘记写 <code>var</code> 导致变量被泄露到全局中。</p>\n<p>还有 <code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript：闭包（Closure）的原理和目的\"><a href=\"#JavaScript：闭包（Closure）的原理和目的\" class=\"headerlink\" title=\"JavaScript：闭包（Closure）的原理和目的\"></a>JavaScript：闭包（Closure）的原理和目的</h1><h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p><strong>词法作用域</strong>（<code>Lexical Scopes</code>）是 <code>javascript</code> 中使用的作用域类型，<strong>词法作用域</strong> 也可以被叫做 <strong>静态作用域</strong>，与之相对的还有 <strong>动态作用域</strong>。那么 <code>javascript</code> 使用的 <strong>词法作用域</strong> 和 <strong>动态作用域</strong> 的区别是什么呢？看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  var value = 2;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png\" alt=\"image-20220307194155261\"></p>\n<p>上面这段代码中，一共有三个作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li><code>foo</code> 的函数作用域</li>\n<li><code>bar</code> 的函数作用域</li>\n</ul>\n<p>一直到这边都好理解，可是 <code>foo</code> 里访问了本地作用域中没有的变量 <code>value</code> 。根据前面说的，引擎为了拿到这个变量就要去 <code>foo</code> 的上层作用域查询，那么 <code>foo</code> 的上层作用域是什么呢？是它 <strong>调用时</strong> 所在的 bar 作用域？还是它 <strong>定义时</strong> 所在的全局作用域？</p>\n<p>这个关键的问题就是 <code>javascript</code> 中的作用域类型——<strong>词法作用域。</strong></p>\n<blockquote>\n<p>词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</p>\n</blockquote>\n<p><strong>词法作用域（Lexical Scope）</strong> 是定义表达式并能被访问的区间。</p>\n<p>换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>词法作用域又叫静态作用域。</li>\n<li>一个声明 <strong>被调用时的作用域</strong> 不一定是它的词法作用域。相反的，<strong>定义时的作用域</strong> 才是词法作用域</li>\n</ul>\n<h3 id=\"一个词法作用域的小示例\"><a href=\"#一个词法作用域的小示例\" class=\"headerlink\" title=\"一个词法作用域的小示例\"></a>一个词法作用域的小示例</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个全局作用域变量：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myName = <span class=\"string\">&quot;Oluwatobi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在函数体内调用myName变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getName</span>()) <span class=\"comment\">// &#x27;Oluwatobi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们在全局作用域定义了<code>myName</code>变量，并在<code>getName()</code>函数作用域内调用了该变量。</p>\n<p><strong>问题：</strong> <code>myName</code>变量的词法作用域是什么？全局作用域还是 <code>getName()</code>的局部作用域？</p>\n<p><strong>答案：</strong> 切记 <strong>词法作用域</strong> 意味着 <strong>定义时的作用域</strong>，并不是<strong>调用时的作用域</strong> 。因此<code>myName</code>变量的词法作用域是全局作用域，因为我们在全局环境下定义了<code>myName</code>变量。</p>\n<p><strong>换言之，函数的作用域在它的定义的时候就已经确定了。</strong></p>\n<h3 id=\"作用域-scope-与上下文-context-的相似与区别\"><a href=\"#作用域-scope-与上下文-context-的相似与区别\" class=\"headerlink\" title=\"作用域[scope]与上下文[context]的相似与区别\"></a>作用域[scope]与上下文[context]的相似与区别</h3><p>context指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。</p>\n<p>并且它们的创建者不同</p>\n<ul>\n<li>作用域是<strong>词法分析</strong>创建，静态</li>\n<li>执行上下文由<strong>js引擎</strong>创建，动态</li>\n</ul>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>一句话定义闭包，就是<strong>能够访问其他函数内部变量的函数，被称为 <em>闭包</em></strong></p>\n<p>一般闭包的表现形式是：<strong>闭包就是函数内部定义的函数，被返回了出去并在外部调用</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">  function bar() &#123;</span><br><span class=\"line\">    console.log( a );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); // 这就形成了一个闭包</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单剖析一下上面代码的运行流程：</p>\n<ol>\n<li>编译阶段，变量和函数被声明，作用域即被确定。</li>\n<li>运行函数 <code>foo()</code>，此时会创建一个 <code>foo</code> 函数的执行上下文，执行上下文内部存储了 <code>foo</code> 中声明的所有变量函数信息。</li>\n<li>函数 <code>foo</code> 运行完毕，将内部函数 <code>bar</code> 的引用赋值给外部的变量 <code>baz</code> ，此时 <code>baz</code> 指针指向的还是 <code>bar</code> ，因此哪怕它位于 <code>foo</code> 作用域之外，它还是能够获取到 <code>foo</code> 的内部变量。</li>\n<li><code>baz</code> 在外部被执行，<code>baz</code> 的内部可执行代码 <code>console.log</code> 向作用域请求获取 <code>a</code> 变量，本地作用域没有找到，继续请求父级作用域，找到了 <code>foo</code> 中的 <code>a</code> 变量，返回给 <code>console.log</code>，打印出 <code>2</code>。</li>\n</ol>\n<p>闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。</p>\n<h3 id=\"闭包的目的\"><a href=\"#闭包的目的\" class=\"headerlink\" title=\"闭包的目的\"></a>闭包的目的</h3><h4 id=\"1-延长变量存活时间\"><a href=\"#1-延长变量存活时间\" class=\"headerlink\" title=\"1.延长变量存活时间\"></a>1.延长变量存活时间</h4><p>在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。</p>\n<h4 id=\"2-创造私有作用域\"><a href=\"#2-创造私有作用域\" class=\"headerlink\" title=\"2.创造私有作用域\"></a>2.创造私有作用域</h4><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。</p>\n<h3 id=\"闭包的问题：内存泄露\"><a href=\"#闭包的问题：内存泄露\" class=\"headerlink\" title=\"闭包的问题：内存泄露\"></a>闭包的问题：内存泄露</h3><p>我们知道，<code>javascript</code> 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p>\n<p>然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。</p>\n<p>当然，造成内存泄露的原因有很多，除了闭包以外，还有 <strong>全局变量的无意创建</strong>。开发者的本意是想将变量作为局部变量使用，然而忘记写 <code>var</code> 导致变量被泄露到全局中。</p>\n<p>还有 <code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0f8k8gj0006fsuh924ag8r2","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gv0012fsuh717q81lz"},{"post_id":"cl0f8k8gj0006fsuh924ag8r2","category_id":"cl0f8k8gu000wfsuh781fgdn3","_id":"cl0f8k8gv0013fsuh05ak2e3e"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkbsr0005q8uhddvp2k1o"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0ggkbsr0006q8uh3n775f39"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkjjl0009q8uh3mi2fs88"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0ggkjjl000aq8uh9wltcg2c"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkzvd000dq8uh5ccqhxm8"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","category_id":"cl0f8k8gs000nfsuh3u9w153m","_id":"cl0ggkzvd000eq8uhb30e8wbv"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggl1ta000hq8uhd8mf761t"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","category_id":"cl0f8k8gs000nfsuh3u9w153m","_id":"cl0ggl1ta000iq8uh0qjr623w"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggla2b000rq8uhdyqqc9f8"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","category_id":"cl0f8k8gr000jfsuh0h1988b0","_id":"cl0ggla2c000sq8uhc46a2bf7"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggm3rd000wq8uhgo24fscd"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","category_id":"cl0f8k8gr000jfsuh0h1988b0","_id":"cl0ggm3rd000xq8uh19k55fbq"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0gio0930010q8uh09gz3de2"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0gio0940011q8uh2imu1lrw"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0gnwhp80014q8uhc61nfq35"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0gnwhp80015q8uh5dsz116j"}],"PostTag":[{"post_id":"cl0f8k8gj0006fsuh924ag8r2","tag_id":"cl0f8k8gr000ifsuh73vl7z8a","_id":"cl0f8k8gs000pfsuhaf6l5h8f"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0ggkbsq0004q8uhdcxh4zke"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0ggkjjl0008q8uhhzu64omp"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","tag_id":"cl0f8k8gs000rfsuhhf76dt41","_id":"cl0ggkzvd000cq8uh9i8cey47"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","tag_id":"cl0f8k8gs000rfsuhhf76dt41","_id":"cl0ggl1ta000gq8uhcuwu8xxf"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","tag_id":"cl0f8k8gg0004fsuh7go61n5z","_id":"cl0ggla2b000pq8uhdxhe5es8"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","tag_id":"cl0f8k8gm000afsuh9ea63qua","_id":"cl0ggla2b000qq8uh9bjfhkqu"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","tag_id":"cl0f8k8gg0004fsuh7go61n5z","_id":"cl0ggm3rd000uq8uh2jni3sur"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","tag_id":"cl0f8k8gm000afsuh9ea63qua","_id":"cl0ggm3rd000vq8uhcnod73k6"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0gio093000zq8uh0pm23q6w"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0gnwhp80013q8uhgbi0481z"}],"Tag":[{"name":"Java","_id":"cl0f8k8gg0004fsuh7go61n5z"},{"name":"算法","_id":"cl0f8k8gm000afsuh9ea63qua"},{"name":"KrKr","_id":"cl0f8k8gr000ifsuh73vl7z8a"},{"name":"JavaScript","_id":"cl0f8k8gr000mfsuhc6ww62hn"},{"name":"Renpy","_id":"cl0f8k8gs000rfsuhhf76dt41"}]}}