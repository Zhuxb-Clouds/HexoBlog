---
title: JavaScript：垃圾回收机制
copyright: false
date: 2022-03-07 21:23:16
tags: JavaScript
cover: "https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072124126.jpg"
categories:
  - [技术,JavaScript]
---

垃圾回收：`GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，如果让它们长时间占用内存不仅会让程序的效率降低，还会引起内存泄露等问题。浏览器通常就会通过内置的某些机制进行垃圾回收。

# 垃圾回收策略

在JavaScript内存管理中有一个概念叫做“可达性”，指的是可以通过某种方式读取或使用的性质。JavaScript会将那些不具有可达性的对象给清理回收，释放内存。

一般来说，识别可达性有两种策略

- 标记清除算法
- 引用计数算法

## 标记清除算法

标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法。

整个标记清除算法大致过程就像下面这样

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成1
- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收

**优点**

标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单

**缺点**

标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题

## 引用计数算法

**策略**

引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了。

它的策略是跟踪记录每个变量值被使用的次数

- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1
- 如果同一个值又被赋给另一个变量，那么引用数加 1
- 如果该变量的值被其他的值覆盖了，则引用次数减 1
- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存

# V8引擎的GC

V8 是为Google Chrome 提供支持的JavaScript 引擎的名称。 当使用Chrome 进行浏览时，它负责处理并执行JavaScript。 V8 提供了执行JavaScript 的运行时环境。 DOM 和其他Web 平台API 则由浏览器提供。

V8引擎使用的GC机制也是基于标记清除算法，但是在那基础之上还做了一定的优化。

有个这样的思辨故事：金字塔和双子大厦谁会更先倒塌？答案是双子塔大厦，因为老建筑比新建筑倒塌的概率更低。

基于这个理念，V8堆内存被分为了新生代和老生代。

新生代通常只有`1-8M`的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了**不同的垃圾回收器和不同的回收算法**，以便更高效地实施垃圾回收

- `副垃圾回收器 + Scavenge算法`：主要负责新生代的垃圾回收
- `主垃圾回收器 + Mark-Sweep && Mark-Compact算法`：主要负责老生代的垃圾回收。

