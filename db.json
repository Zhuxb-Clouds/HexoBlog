{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/butterfly/source/img/404.jpg","path":"img/404.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/CG00.png","path":"img/CG00.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/NO logo3.jpg","path":"img/NO logo3.jpg","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/background.webp","path":"img/background.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/Head.webp","path":"img/Head.webp","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/bird.png","path":"img/bird.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/butterfly/source/img/friend_404.gif","path":"img/friend_404.gif","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/background.css","path":"css/background.css","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/index.styl","path":"css/index.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/css/var.styl","path":"css/var.styl","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/myFunction.js","path":"js/myFunction.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/tw_cn.js","path":"js/tw_cn.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/algolia.js","path":"js/search/algolia.js","modified":0,"renderable":1},{"_id":"themes/butterfly/source/js/search/local-search.js","path":"js/search/local-search.js","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/butterfly/source/img/cg04.webp","path":"img/cg04.webp","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/02.两数相加问题.md","hash":"f4f3960c877685838ec9786f2b975865824a0788","modified":1646487644102},{"_id":"source/_posts/Var、let、const的异同.md","hash":"bdb7dda6c68a9ff365f278d5d80ec3975bfaf225","modified":1646487607583},{"_id":"source/categories/index.md","hash":"155a7810395a33cc7c4839a43a0c9f3a79c489aa","modified":1646333034902},{"_id":"source/_posts/01-两数之和问题.md","hash":"d9eb2ebe1b5b88756f160cc09e50180bd3462902","modified":1646357090253},{"_id":"source/about/index.md","hash":"9c94d39ca5f74559257b5aa2630e8fb51737bc20","modified":1646737647726},{"_id":"source/tags/index.md","hash":"2e651a158e8a62b859401334fa7a8f597cb862a0","modified":1646333034903},{"_id":"source/_posts/KAG：回到标题与BookMark.md","hash":"605c5c91555d62f4fedf105c7bc7fbd203b0a28e","modified":1646659596343},{"_id":"source/_posts/假山问题-浅探transform参数与warper函数.md","hash":"1ca6c8f1df82e795e109731022918697f84c648d","modified":1646333034891},{"_id":"source/_posts/获取当前标签名.md","hash":"2a9720221824e49cccbd774f1d1eb900698b69e8","modified":1646333034901},{"_id":"themes/butterfly/_config.yml","hash":"24991f18b93aaeb54a4d7285df290b7483ae1616","modified":1646953097128},{"_id":"themes/butterfly/package.json","hash":"ff4e6e90badea36f89e79a3c7a25e67dcdf36e32","modified":1646292563455},{"_id":"themes/butterfly/LICENSE","hash":"c8bc7df08db9dd3b39c2c2259a163a36cf2f6808","modified":1646292563403},{"_id":"themes/butterfly/languages/en.yml","hash":"69ed4d7aa63a26afd539321784d27494fbebffe8","modified":1646292563419},{"_id":"themes/butterfly/languages/default.yml","hash":"54a412ace93549f02f8e44fcf3e1cacb161a64db","modified":1646292563419},{"_id":"themes/butterfly/languages/zh-TW.yml","hash":"c9675ad7721dd20c9f7731438181a891b43553e6","modified":1646292563420},{"_id":"themes/butterfly/layout/archive.pug","hash":"2d5bf4b1755f89898c579c18d601be83d2bc8ebd","modified":1646292563424},{"_id":"themes/butterfly/languages/zh-CN.yml","hash":"813eb75fbf274b26e2a0c0c75f359f810ad5eeff","modified":1646292563420},{"_id":"themes/butterfly/layout/index.pug","hash":"648dcbdb3d145a710de81c909e000e8664d2ac9c","modified":1646292563454},{"_id":"themes/butterfly/layout/page.pug","hash":"bf2d6c6d2d156777b55292e51be02b0b3acf0af8","modified":1646292563454},{"_id":"themes/butterfly/layout/category.pug","hash":"bf979aec88d78b644fc5d31518f8679ad7625792","modified":1646292563424},{"_id":"themes/butterfly/layout/post.pug","hash":"fdbb508b5e6dec30fb8753c5a7fdd494410c4fc0","modified":1646292563454},{"_id":"themes/butterfly/layout/tag.pug","hash":"4bb5efc6dabdf1626685bf6771aaa1467155ae86","modified":1646292563455},{"_id":"themes/butterfly/README.md","hash":"2555c3e418157a0fda35d3deaf029f12e5a12f12","modified":1646292563405},{"_id":"themes/butterfly/layout/includes/404.pug","hash":"aace9ddff469de4226e47a52ede1c81e66d66d5c","modified":1646292563425},{"_id":"themes/butterfly/layout/includes/additional-js.pug","hash":"8459729db2978bebd7f3668f6dc00a5bb100e633","modified":1646292563426},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/custom.md","hash":"b41123ce5f0ccfa9e06a68b9f3cb59ba040a049a","modified":1646292563402},{"_id":"themes/butterfly/.github/workflows/publish.yml","hash":"e320b40c051bae1549156cd5ea4a51383cf78598","modified":1646292563403},{"_id":"themes/butterfly/README_CN.md","hash":"84fa5880f5358abe919eb295aad3cfd17b69b631","modified":1646292563405},{"_id":"themes/butterfly/.github/stale.yml","hash":"7a131b8aa4936fbcedea3517299e1cdc1bcbcaab","modified":1646292563403},{"_id":"themes/butterfly/layout/includes/head.pug","hash":"687461a9422d1eb4d4b5a619854c79e5acc30fd7","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/footer.pug","hash":"8715948b93e7508b84d913be1969b28c6b067b9b","modified":1646292563426},{"_id":"themes/butterfly/layout/includes/layout.pug","hash":"f2e1d8a05d2e409c4804f67a98f5f59f527d6627","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/pagination.pug","hash":"bb1847f45e713cc88b1c0a97035ec01f0209c995","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/sidebar.pug","hash":"2cf68619af17ece9acea71aa2cb06737097890a5","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/rightside.pug","hash":"205562ec188bfba5686c51af77486550d0927df5","modified":1646292563437},{"_id":"themes/butterfly/scripts/events/404.js","hash":"f1d1c378356b776e9b2a8411e6dca88dc8c3245c","modified":1646292563455},{"_id":"themes/butterfly/scripts/events/config.js","hash":"e959cd313fc20c62fe23f0a7cba3d350d6131d66","modified":1646292563456},{"_id":"themes/butterfly/scripts/events/welcome.js","hash":"b92cc4648cfe5fb28c58943727823d1178b73a4a","modified":1646292563456},{"_id":"themes/butterfly/scripts/events/stylus.js","hash":"218add7e9b39b6fb6e69921abb9e44891a6cc3ce","modified":1646292563456},{"_id":"themes/butterfly/scripts/filters/post_lazyload.js","hash":"5fd6c9659262dc8f61d87866d0417fd534292c88","modified":1646292563457},{"_id":"themes/butterfly/scripts/filters/random_cover.js","hash":"6c3b7d0874fa499800a4fd49894c481b05ec750c","modified":1646292563457},{"_id":"themes/butterfly/scripts/events/init.js","hash":"b321a97420082101a4d41e6e571db1a166475e06","modified":1646292563456},{"_id":"themes/butterfly/scripts/tag/flink.js","hash":"3ba7677969ff01fab06fc6713455ddc6861f0024","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/gallery.js","hash":"6d4cd2393945a9316339351cab588265f5c18d73","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/button.js","hash":"44cca49ddc76921bb455465ef912cab46c993cef","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/inlineImg.js","hash":"7641adb0d520c5ff29dd36fc1fb8617c52ecc9fb","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/hide.js","hash":"e01a3967e5884881bab858b11635457df412de80","modified":1646292563459},{"_id":"themes/butterfly/scripts/tag/label.js","hash":"551f1b8edc973bd8afc5cce2eae546f002fa84c3","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/mermaid.js","hash":"fd683ccc090db3122d77c7ee73e8d35dc8735ee3","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/note.js","hash":"420ba8b11e7316b4c09eb301d39814bc9bae9f90","modified":1646292563460},{"_id":"themes/butterfly/scripts/tag/tabs.js","hash":"08ea00791bd4738952234cb5d8360e119df6f875","modified":1646292563461},{"_id":"themes/butterfly/scripts/tag/timeline.js","hash":"4c7056d3cd56f10bd209d2ba4d3cc2027aad1440","modified":1646292563461},{"_id":"themes/butterfly/scripts/helpers/aside_archives.js","hash":"4f712b4ea383b59a3122683db1d54c04a79ccc5d","modified":1646292563457},{"_id":"themes/butterfly/scripts/helpers/inject_head_js.js","hash":"22a2c69b3e68b0e3f80decfd4a2b9c9cc213ff5c","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/page.js","hash":"384de3c04809ec5fa996e8aa0628f770cd4bff3e","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/related_post.js","hash":"26dd1900e68a3e10a5cf3f3484a93139a0f1340e","modified":1646292563458},{"_id":"themes/butterfly/scripts/helpers/aside_categories.js","hash":"376e1884ea764404c38b1e73b16de0358ece519e","modified":1646292563457},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/bug_report.md","hash":"0b7979a908ebe8c350d73b6731f0be3e29d401c2","modified":1646292563402},{"_id":"themes/butterfly/source/img/Head.webp","hash":"5b2047c94439b9b47ad1f2b4418f3734927b98b4","modified":1646334178055},{"_id":"themes/butterfly/source/img/bird.png","hash":"59274ce45b097aa6d2838f4a7de815bcfa8260b0","modified":1646334178054},{"_id":"themes/butterfly/source/img/favicon.png","hash":"60556b56b0d5210ecbc1fed146c087edcc49ae35","modified":1646334178055},{"_id":"themes/butterfly/.github/ISSUE_TEMPLATE/feature_request.md","hash":"205a69ba038cf76affcdc1f39d88a8cb8079fc12","modified":1646292563402},{"_id":"themes/butterfly/source/css/background.css","hash":"b7118c684e848ebb706b43330443e1f3411cc639","modified":1646744835634},{"_id":"themes/butterfly/source/js/main.js","hash":"a2c1c55b5b8ec9a83cf6242ebc9ea9be95e1f0c1","modified":1646292563479},{"_id":"themes/butterfly/source/css/var.styl","hash":"584ef7b18d5e677eb2e62f9b139097d3b714a993","modified":1646292563477},{"_id":"themes/butterfly/source/js/myFunction.js","hash":"7e8302a6faa573178baa6767b3aae7e350e15661","modified":1646737973280},{"_id":"themes/butterfly/source/css/index.styl","hash":"c7924868adcb046b46498626a9223c7a7b3f2e30","modified":1646292563477},{"_id":"themes/butterfly/source/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1646292563479},{"_id":"themes/butterfly/source/js/utils.js","hash":"fdb9e5b38f076953a2431b8f682388b030694b55","modified":1646292563481},{"_id":"themes/butterfly/layout/includes/head/analytics.pug","hash":"c1e45d4d0bd905ddcd2282de4fe89be92e67847d","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/head/Open_Graph.pug","hash":"07380718ed3af19a7e64b30e8c13726fe5983947","modified":1646292563427},{"_id":"themes/butterfly/layout/includes/head/config_site.pug","hash":"bd5dd5452e28a4fe94c3241a758ec6f4fdb7a149","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/config.pug","hash":"b8e3e07b0e8f3cf25af9550c6361725a05045b92","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/google_adsense.pug","hash":"f29123e603cbbcc6ce277d4e8f600ba67498077c","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/pwa.pug","hash":"6dc2c9b85df9ab4f5b554305339fd80a90a6cf43","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/head/noscript.pug","hash":"72efaa09ff60843567458bd54152e06f0cb2757e","modified":1646292563428},{"_id":"themes/butterfly/layout/includes/head/preconnect.pug","hash":"fc3e67e5ae4774d9e89964ba96beed28f34ee8f0","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/head/site_verification.pug","hash":"5168caadc4cf541f5d6676a9c5e8ae47a948f9ad","modified":1646292563429},{"_id":"themes/butterfly/layout/includes/header/index.pug","hash":"3a2797d2744607ba6cdb5a02853851957c0f7e29","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/menu_item.pug","hash":"ca8bcd90ad9467819330bfe7c02b76322754bccf","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/nav.pug","hash":"a9e56b1c41bf327859b0a7bcb8e72b458bd851b2","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/post-info.pug","hash":"3b0b2053fe9f08cbc21b3baa53163adc2f76c19a","modified":1646292563430},{"_id":"themes/butterfly/layout/includes/header/social.pug","hash":"631ec7000fd4d6cfa2de118ee02ad8a42ffb34f5","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/mixins/article-sort.pug","hash":"971038debf539333b1687b4a1d87cf4fc965a846","modified":1646292563433},{"_id":"themes/butterfly/layout/includes/mixins/post-ui.pug","hash":"9c8e65939d048a579ea08d063c0f98550376f536","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/loading/loading-js.pug","hash":"2e1ab0c2ca59a1ff5a5ba9b6ef60f3e34af5430c","modified":1646292563432},{"_id":"themes/butterfly/layout/includes/loading/loading.pug","hash":"dd8e6813976be64e80eba6562b54e74527ab306d","modified":1646292563433},{"_id":"themes/butterfly/layout/includes/page/categories.pug","hash":"5276a8d2835e05bd535fedc9f593a0ce8c3e8437","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/page/default-page.pug","hash":"e9459f122af7b733398578f9f0f8ab3c5e12a217","modified":1646292563434},{"_id":"themes/butterfly/layout/includes/page/flink.pug","hash":"e2eba0fcb8332cb333b2aff9c76664e40e2e1974","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/post/post-copyright.pug","hash":"6ec54b77e3a90e148e66e317e5bb6c89624fddca","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/post/reward.pug","hash":"594626a18b7efbf771232855dfbce143fb244bc6","modified":1646292563437},{"_id":"themes/butterfly/layout/includes/page/tags.pug","hash":"8f43fdeaf8cff4a35bab74b48c963786ca015620","modified":1646292563435},{"_id":"themes/butterfly/layout/includes/third-party/aplayer.pug","hash":"bee06b3f01fa1f0d8fa08c154234b452da425101","modified":1646292563438},{"_id":"themes/butterfly/layout/includes/third-party/effect.pug","hash":"4c3da5a89b4e6fd3ab527f5c6d27790359d57f71","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/pjax.pug","hash":"61a220bf134201bdf49430b578305191421c547c","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/pangu.pug","hash":"d06dafe7faf3a2e328ef62f26166a51ffe7a5579","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/prismjs.pug","hash":"2448b243ded58aa1d5fc22fd115e6d06b636f9fd","modified":1646292563448},{"_id":"themes/butterfly/layout/includes/third-party/subtitle.pug","hash":"311d883dede2a6838bf24ba9e4b3f69e62d5b3f1","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_announcement.pug","hash":"21e019bdc3b1e796bb00976bb29af2d51f873624","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_ad.pug","hash":"a8312b527493dabbadbb1280760168d3bc909a3b","modified":1646292563451},{"_id":"themes/butterfly/layout/includes/widget/card_archives.pug","hash":"73d33b6930e7944187a4b3403daf25d27077a2dd","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_author.pug","hash":"935dde9cf4c1fef0214dbb9935ecb71805735be0","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_bottom_self.pug","hash":"1dba77d250eeebfb6e293d504352c7e9ea31980b","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_categories.pug","hash":"66e383b4ef374951eb87dd1bf4cdb7a667193fb5","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_newest_comment.pug","hash":"c02b1779bd0ebca6749f195be096b6ca574bfa29","modified":1646292563452},{"_id":"themes/butterfly/layout/includes/widget/card_post_toc.pug","hash":"59d979702fa21d960443824198614d63aaf69662","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_tags.pug","hash":"9755cac8424dc578e9ec07dbcaa429fddbedd392","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_recent_post.pug","hash":"471b20e71a19db1f5115727082e5188200c49383","modified":1646292563453},{"_id":"themes/butterfly/layout/includes/widget/card_top_self.pug","hash":"7b5ae404a1205546b7de4be42291315cf918f2b3","modified":1646292563453},{"_id":"themes/butterfly/source/css/_global/function.styl","hash":"d35d156b06f4da25a048872f1cfc35ad49092515","modified":1646292563462},{"_id":"themes/butterfly/layout/includes/widget/index.pug","hash":"5e0e9e9b2cd3c256d52423e2278e790aa387a53a","modified":1646292563454},{"_id":"themes/butterfly/layout/includes/widget/card_webinfo.pug","hash":"62adef7998fb9bebc5891a49472cfea944a1bf7a","modified":1646292563454},{"_id":"themes/butterfly/source/css/_global/index.styl","hash":"b9d7d23dc8810542b8c8ffcbfbd3694318debcc6","modified":1646292563462},{"_id":"themes/butterfly/source/css/_highlight/highlight.styl","hash":"a2aa5caf338ff5323b6ff0601ebcc09e710d8398","modified":1646292563463},{"_id":"themes/butterfly/source/css/_highlight/theme.styl","hash":"3c178608406c31d768af355ef1d7326da37cc75f","modified":1646292563465},{"_id":"themes/butterfly/source/css/_layout/chat.styl","hash":"f27ad7b5d781c98bcac5c12c2d70b69b830e0374","modified":1646292563466},{"_id":"themes/butterfly/source/css/_layout/aside.styl","hash":"b62d41e079e45146f0019694156049c5f1be040a","modified":1646292563466},{"_id":"themes/butterfly/source/css/_layout/comments.styl","hash":"0abe05309a186682772a94e5e759b63f8028e61a","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/footer.styl","hash":"e931ef81754a7b9d999fa23d134c620e68e75491","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/loading.styl","hash":"844858ae87c7278996ce484c6b456db354c48764","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/head.styl","hash":"f3aac52defb3497079a313e8c63ac2f7ee24dfbe","modified":1646292563467},{"_id":"themes/butterfly/source/css/_layout/pagination.styl","hash":"bd099f7d3adef4b7edd24c0a25a07415b156e587","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/post.styl","hash":"35c7fa4e18cefe01b62e0caedccbdc0c26b3546c","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/reward.styl","hash":"b5ba2c3339ad406ce611d12d3f8cc84f864fbc03","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/relatedposts.styl","hash":"6dcf19c0933c8828a439f801b0f4b256447dec07","modified":1646292563468},{"_id":"themes/butterfly/source/css/_layout/rightside.styl","hash":"1c1c585ba99cb4004956b5e98fc044260b456f99","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/sidebar.styl","hash":"4258fa2e590aeea704660008aed7f0362fac72d4","modified":1646292563469},{"_id":"themes/butterfly/source/css/_layout/third-party.styl","hash":"988a947f80c218d8c2279c9975f46d0c2a3d0b6e","modified":1646292563469},{"_id":"themes/butterfly/source/css/_page/archives.styl","hash":"d72218cb5a6bfe048ae1c92009bd815a08a53d3a","modified":1646292563471},{"_id":"themes/butterfly/source/css/_page/categories.styl","hash":"68bc8cbea25dbb3cdc170f09f9b43ce130547717","modified":1646292563471},{"_id":"themes/butterfly/source/css/_page/404.styl","hash":"a7223a8fcc4fa7b81e552c9a2554be7df9de312e","modified":1646292563470},{"_id":"themes/butterfly/source/css/_page/common.styl","hash":"a714776e3d585369f2285b6bb4e1564539c58d8b","modified":1646292563472},{"_id":"themes/butterfly/source/css/_page/flink.styl","hash":"ecc2b2e28c179eb9406fc2c6f00e141078249cdd","modified":1646292563472},{"_id":"themes/butterfly/source/css/_page/tags.styl","hash":"9e35f91847773b915c74a78b8aa66c7bdb950ad0","modified":1646292563473},{"_id":"themes/butterfly/source/css/_page/homepage.styl","hash":"c42b872df237726483d93d6124b8751d4f64cf86","modified":1646292563472},{"_id":"themes/butterfly/source/css/_mode/darkmode.styl","hash":"0bcd07ffbd2a86a1b24eaefabd7e278034b14ee2","modified":1646292563470},{"_id":"themes/butterfly/source/css/_mode/readmode.styl","hash":"1fed25162d7204480e9bcf476b3246e1717107ca","modified":1646292563470},{"_id":"themes/butterfly/source/css/_tags/button.styl","hash":"62da1de0d5b8453fcecbfacddb16985265638ba5","modified":1646292563474},{"_id":"themes/butterfly/source/js/tw_cn.js","hash":"4db1170be7a9360e2c5399d281b979da730df2a3","modified":1646292563481},{"_id":"themes/butterfly/source/css/_tags/gallery.styl","hash":"84c42716e833d2d1dd47195ea996803ffa0e58ec","modified":1646292563475},{"_id":"themes/butterfly/source/css/_search/algolia.styl","hash":"f84268708a9ea3c417426bf194bdfea9f7374628","modified":1646292563473},{"_id":"themes/butterfly/source/css/_tags/hexo.styl","hash":"985b183db7b7bfd8f9bdb60494549fb7f850348b","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/hide.styl","hash":"b7cf7753479fcf2fe07287ffdb0e568adbba4c18","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/inlineImg.styl","hash":"5a873d01fabebcf7ddf7a6b1c2e2e5e2714097f4","modified":1646292563475},{"_id":"themes/butterfly/source/css/_tags/label.styl","hash":"2f83bd145b870d80d4b18b0ac603235229a5694e","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/note.styl","hash":"076cd87805207c9b5612ec9771f6994287f4c169","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/tabs.styl","hash":"ec81ea316c82b83d6aee31e52f248d329559d5d3","modified":1646292563476},{"_id":"themes/butterfly/source/css/_tags/timeline.styl","hash":"07ea7134db7a66c87658116f089fb1a2a6906563","modified":1646292563476},{"_id":"themes/butterfly/source/css/_third-party/normalize.min.css","hash":"8549829fb7d3c21cd9e119884962e8c463a4a267","modified":1646292563477},{"_id":"themes/butterfly/source/css/_search/local-search.styl","hash":"107b9e586b12d1fe7bb5b6e53fcc8e31516ab3ba","modified":1646292563474},{"_id":"themes/butterfly/source/css/_search/index.styl","hash":"f9bee6cac49de1171076560acf6a6eec96647c56","modified":1646292563473},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/fb.pug","hash":"4eebb2d94ca75809ef0cf32d70f13e9bf1e87091","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/disqus.pug","hash":"f4d21dcbc3b00eed9b1f604e132c4c6811a0a059","modified":1646292563438},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/twikoo.pug","hash":"eb2d840fa42de3ec7a7fda0eaa30246d52f543e2","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/index.pug","hash":"a18415004d03c0a1783eccac522fbcb6ce0ea1f1","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/waline.pug","hash":"f3db5c5e738e097a191dc0de59c61d3e1444f7c3","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/card-post-count/valine.pug","hash":"896dc0b7480151562c5717771e3000c5a7fc1b16","modified":1646292563439},{"_id":"themes/butterfly/layout/includes/third-party/chat/chatra.pug","hash":"f3f6eaecbcf9352342e259f4a5a3ad7160f31fc9","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/crisp.pug","hash":"b741b5e942481d779a8a1fe94c45154a62a6b748","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/index.pug","hash":"bb467bb22f3d0775b33f9eacbfc086ecb7831e78","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/daovoice.pug","hash":"e5af55cdb87d1ffd3d8702bc77097159acf95b54","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/gitter.pug","hash":"794ce3911f17d354b7196deb8c36d191afac63fb","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/chat/tidio.pug","hash":"cd7ab4a776be93eea96a6f6fd0a547977fbe1ea3","modified":1646292563440},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqusjs.pug","hash":"9ddfac9ae7071ecd982ca3808dcfd4d2d6098f33","modified":1646292563441},{"_id":"themes/butterfly/layout/includes/third-party/comments/disqus.pug","hash":"d5f81fd5443a1b09efb165b5f4447a35949d14ad","modified":1646292563441},{"_id":"themes/butterfly/layout/includes/third-party/comments/giscus.pug","hash":"a780962b3a04cac4b296ce809ee7101e42cf3a37","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/facebook_comments.pug","hash":"e6d48579029c253b85f2abbba5997d6baf9a10ae","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/gitalk.pug","hash":"b22ed23c78fb372cbdc4cfd3f733beb2ebea5d74","modified":1646292563442},{"_id":"themes/butterfly/layout/includes/third-party/comments/index.pug","hash":"414f876d28f8497d6d551363a89c5c69bf1533eb","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/js.pug","hash":"810e8ca2669433f649329859922aabbb30d76178","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/livere.pug","hash":"589f8503f264d4fda971c8daf2028f45c4f2867b","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/utterances.pug","hash":"21098eba47237ec003228e7fa70a5fbb14d6c804","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/comments/twikoo.pug","hash":"3f10e67c7618615cc85d50e4a3694f3d8b262952","modified":1646292563443},{"_id":"themes/butterfly/layout/includes/third-party/comments/valine.pug","hash":"d1ac48307e4999be08c63c673e98fe3fcee5bfce","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/math/index.pug","hash":"2afa4c21dd19890f47fb568cfb0d90efb676a253","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/comments/waline.pug","hash":"0f287b10408b4455d946a69677549fcfd302e8c0","modified":1646292563444},{"_id":"themes/butterfly/layout/includes/third-party/math/katex.pug","hash":"266caf985dc0703ff81b871b8f8d206f57db6e79","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/math/mermaid.pug","hash":"6dd420ea858f3237d8a7353e8541df665dd6fdf1","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/math/mathjax.pug","hash":"87e40f0c315407ab88571a2b3450d640f15c96bc","modified":1646292563445},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/disqus-comment.pug","hash":"cd1ce86441dc508e4c3dbf8b829046455ba8a6b4","modified":1646292563446},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/index.pug","hash":"16cf05cf9649322da57e9b8d316573bb65f8d8d8","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/github-issues.pug","hash":"b2ede1f6b41026ebd233ac076a405889a6eec76b","modified":1646292563446},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/twikoo-comment.pug","hash":"444820bc7e4a9a033062bcd8cd71b10b49d1968a","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/valine.pug","hash":"3b42d3b8468431655112705bff7530ce647f8c05","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/newest-comments/waline.pug","hash":"c9e6e14770317a3516e2e2f320654cd52b1bd73a","modified":1646292563447},{"_id":"themes/butterfly/layout/includes/third-party/search/algolia.pug","hash":"a5aa867697578660fe78a0d9b0f245d09b571110","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/search/index.pug","hash":"ff3727c3ec698ec61a28c55cbc8c8508f0efb0a0","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/share/add-this.pug","hash":"8b4034e53ca5bf85097f681a6e76a53ce685c205","modified":1646292563450},{"_id":"themes/butterfly/layout/includes/third-party/search/local-search.pug","hash":"7ce18e4b22c41dcfd84835e89b47030fc5f4a394","modified":1646292563449},{"_id":"themes/butterfly/layout/includes/third-party/share/addtoany.pug","hash":"fbac21a6c5924fb2f8d1190fd634105fdbc603d4","modified":1646292563450},{"_id":"themes/butterfly/layout/includes/third-party/share/share-js.pug","hash":"7e9a7347dd8ca4c33c564fb62512743b6012bb2d","modified":1646292563451},{"_id":"themes/butterfly/source/css/_highlight/highlight/diff.styl","hash":"6e77f1ca0cfb0db6b028f5c0238780e66d344f3d","modified":1646292563463},{"_id":"themes/butterfly/layout/includes/third-party/share/index.pug","hash":"4898a09d8e67fb358ffd74b3a1f0014f555dd856","modified":1646292563450},{"_id":"themes/butterfly/source/css/_highlight/highlight/index.styl","hash":"fc702a4614d0562a381907b083f71ba63d301d86","modified":1646292563463},{"_id":"themes/butterfly/source/css/_highlight/prismjs/index.styl","hash":"01ff9e77eb1bd454bec65a6ff5972c8e219bc708","modified":1646292563464},{"_id":"themes/butterfly/source/js/search/local-search.js","hash":"2086c6ad3c48ded263a36b230485ed0c15293f8e","modified":1646292563481},{"_id":"themes/butterfly/source/js/search/algolia.js","hash":"d684f2a60fe821d61761a01cf36fd2fb57c31c9c","modified":1646292563480},{"_id":"themes/butterfly/source/img/NO logo3.jpg","hash":"f7d7bd4066b31890388e76ec1bff9fd0e3265806","modified":1646339319045},{"_id":"themes/butterfly/source/img/background.webp","hash":"2d4f1081568cab516f591cf53c2cd33a327df485","modified":1646334178055},{"_id":"themes/butterfly/source/css/_highlight/prismjs/line-number.styl","hash":"0b8aea62d1550113e1fcc237fae1b03743190208","modified":1646292563464},{"_id":"themes/butterfly/source/css/_highlight/prismjs/diff.styl","hash":"1309292f1c8c53d96cd7333507b106bcc24ca8fc","modified":1646292563464},{"_id":"themes/butterfly/source/img/404.jpg","hash":"fc8b7ef3778e7270a3543bc56708d0abad090da0","modified":1646334178054},{"_id":"themes/butterfly/source/img/CG00.png","hash":"dcf445309417704c7fedbacc6342b722490cd43f","modified":1646334178058},{"_id":"public/tags/index.html","hash":"8bcb9feb8353d82876fb43b76ee2666bcbc2a88b","modified":1646953062519},{"_id":"public/about/index.html","hash":"ffa3ab157c85776027ae45524088a41ce4f8bc0f","modified":1646953062519},{"_id":"public/categories/index.html","hash":"078cf51689338b9906f327c9b4d69c0f3dbae526","modified":1646953062519},{"_id":"public/2022/03/05/Var、let、const的异同/index.html","hash":"6d56764d7644dfa251c3bd1f5d95d69122dc7b74","modified":1646568818822},{"_id":"public/2022/03/04/01-两数之和问题/index.html","hash":"8dd3935a6818a9e90d87ef45cfe5ceb0daddc1c9","modified":1646568818822},{"_id":"public/2022/03/04/02.两数相加问题/index.html","hash":"2b302ef7b1e63503208a07dc34c2d206e58c88fe","modified":1646568818822},{"_id":"public/2022/03/04/KAG：回到标题与BookMark/index.html","hash":"8dd4be282d1893f63bb77b09e92956dda9edcd1e","modified":1646953062519},{"_id":"public/2022/03/03/假山问题-浅探transform参数与warper函数/index.html","hash":"e038fd80c85c70df39849d0de1a38d44a1449ae1","modified":1646568818822},{"_id":"public/2022/03/03/获取当前标签名/index.html","hash":"64903ba8904027e5b43e6056fbc5a622a91c4bdc","modified":1646568818822},{"_id":"public/archives/index.html","hash":"f32a6067ce70a907416806b8674fee1e72297c70","modified":1646953062519},{"_id":"public/archives/2022/03/index.html","hash":"9ab8d88eaa8a5799b76971eadb94e74b95f6c053","modified":1646953062519},{"_id":"public/archives/2022/index.html","hash":"d9f955191a2a90b211ecab56b5d3f76f50383dc6","modified":1646953062519},{"_id":"public/categories/技术/index.html","hash":"8ba6f74911a8d2de49198cdec50fc9077daa167c","modified":1646953062519},{"_id":"public/categories/技术/JavaScript/index.html","hash":"5878d0e87b39dbbfcc1db241b61f5165d48f7808","modified":1646953062519},{"_id":"public/categories/技术/算法/index.html","hash":"36b5cadd4d55aeed8df125e494588e42d2549311","modified":1646953062519},{"_id":"public/categories/技术/Renpy/index.html","hash":"56d2f2de3b748a2a9b15552f6a5dcf9790bd8d30","modified":1646953062519},{"_id":"public/categories/技术/KrKr/index.html","hash":"de6f13a70aad9f72dc26e88b18a6697484674375","modified":1646953062519},{"_id":"public/tags/KrKr/index.html","hash":"012aacdd9b45574c0fc26c7328a8f414aafe66bc","modified":1646953062519},{"_id":"public/tags/算法/index.html","hash":"ddb7d30ab438f4a1930281965fe0fee14e8a688a","modified":1646953062519},{"_id":"public/tags/Java/index.html","hash":"3151a26d091b87359fbfd7ac97e2fa2f6a53b7e5","modified":1646953062519},{"_id":"public/tags/JavaScript/index.html","hash":"757d202f11c9c2f1fc78866939eb7946635d0f21","modified":1646953062519},{"_id":"public/index.html","hash":"194cc1e259bcba733abfca9915dc18fcca01fda6","modified":1646953062519},{"_id":"public/tags/Renpy/index.html","hash":"3ce68a51eb1106a36ead35da07e2417919d76964","modified":1646953062519},{"_id":"public/img/404.jpg","hash":"fc8b7ef3778e7270a3543bc56708d0abad090da0","modified":1646568818822},{"_id":"public/img/bird.png","hash":"59274ce45b097aa6d2838f4a7de815bcfa8260b0","modified":1646568818822},{"_id":"public/img/Head.webp","hash":"5b2047c94439b9b47ad1f2b4418f3734927b98b4","modified":1646568818822},{"_id":"public/img/friend_404.gif","hash":"8d2d0ebef70a8eb07329f57e645889b0e420fa48","modified":1646568818822},{"_id":"public/img/favicon.png","hash":"60556b56b0d5210ecbc1fed146c087edcc49ae35","modified":1646568818822},{"_id":"public/css/background.css","hash":"cf4504b96305773f44fe253ba99cb9e737c54aaf","modified":1646799237162},{"_id":"public/css/var.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1646568818822},{"_id":"public/js/utils.js","hash":"0b95daada72abb5d64a1e3236049a60120e47cca","modified":1646568818822},{"_id":"public/js/search/algolia.js","hash":"aaa5e44125dcf321866bc2355a73773b11db8c9c","modified":1646568818822},{"_id":"public/js/myFunction.js","hash":"03231517ecb781b71f516f62817639a0bb798872","modified":1646568818822},{"_id":"public/js/search/local-search.js","hash":"ec62117f38e095425f295b1170c222c7a1399425","modified":1646568818822},{"_id":"public/css/index.css","hash":"50068a300402a1f274129b6d971d2112fdfb6cea","modified":1646568818822},{"_id":"public/js/main.js","hash":"04efcbd28b37875cfec88eb87cab7256a9ebb327","modified":1646568818822},{"_id":"public/js/tw_cn.js","hash":"00053ce73210274b3679f42607edef1206eebc68","modified":1646568818822},{"_id":"public/img/background.webp","hash":"2d4f1081568cab516f591cf53c2cd33a327df485","modified":1646568818822},{"_id":"public/img/NO logo3.jpg","hash":"f7d7bd4066b31890388e76ec1bff9fd0e3265806","modified":1646568818822},{"_id":"public/img/CG00.png","hash":"dcf445309417704c7fedbacc6342b722490cd43f","modified":1646568818822},{"_id":"source/CNAME","hash":"0b414ef86e545620653ecff427ecc7bfc48575b4","modified":1646292037504},{"_id":"source/_posts/call、apply、bind的异同.md","hash":"2b25d848c0229f81b5d29aa33f435fd9a4fadba6","modified":1646642591987},{"_id":"source/_posts/JavaScript：Var、let、const的异同.md","hash":"ced39d7362464a922b0103677eadfb18b5251c9e","modified":1646659584649},{"_id":"source/_posts/JavaScript：call、apply、bind的异同.md","hash":"89c3caaf5d6c18a53541c7ef5b738913db85f862","modified":1646659577807},{"_id":"source/_posts/JavaScript：作用域和作用域链.md","hash":"32e011db1720a9dee83f0ee01c14cfc419489f38","modified":1646659579426},{"_id":"source/_posts/Renpy：获取当前标签名.md","hash":"1a0a641fffb2636adf4fac5380542933b0ae6a51","modified":1646642755210},{"_id":"source/_posts/JavaScript：闭包（Closure）的原理和目的.md","hash":"fa395f0446cf88c768076e2c4cdea0d7a7ed55ad","modified":1646655051722},{"_id":"source/_posts/Renpy：假山问题-浅探transform参数与warper函数.md","hash":"4a6665a4290463ddc8f2f40ca1bd0e506c1d64a3","modified":1646642833167},{"_id":"source/_posts/算法01.两数之和问题.md","hash":"c30c9902e240f17976703e1eb5445ff0793cc6b2","modified":1646642816030},{"_id":"source/_posts/算法02.两数相加问题.md","hash":"1eb24a3253139f0c6251e63a517a8338cab89246","modified":1646642787653},{"_id":"source/_posts/JavaScript：垃圾回收机制.md","hash":"c142fc95d1d8d321a1c1ef6ca40b722cec3e8814","modified":1646659507106},{"_id":"source/_posts/JavaScript：浅谈Promise.md","hash":"32a73251c2b6cd8e112aff1f2b81b983ba33840e","modified":1646671234798},{"_id":"public/2022/03/08/JavaScript：浅谈Promise/index.html","hash":"00bc136e55a0dec11f3768f2ae3109a991d41ea3","modified":1646953062519},{"_id":"public/2022/03/07/JavaScript：垃圾回收机制/index.html","hash":"9c660a82cc2b121e183672456d2fb37569c2cbc7","modified":1646953062519},{"_id":"public/2022/03/07/JavaScript：闭包（Closure）的原理和目的/index.html","hash":"232521e5ceb516177d457c92adf67be6a2aade12","modified":1646953062519},{"_id":"public/2022/03/05/JavaScript：Var、let、const的异同/index.html","hash":"c22a9fff04175671afd8291bcd15767875b6ea9c","modified":1646953062519},{"_id":"public/2022/03/07/JavaScript：作用域和作用域链/index.html","hash":"3b6a70c4980f3f353e916c2e67522550811e261e","modified":1646953062519},{"_id":"public/2022/03/04/算法02.两数相加问题/index.html","hash":"db1300da0ba20786d6bb70449ed17b7eb6711ad5","modified":1646953062519},{"_id":"public/2022/03/04/算法01.两数之和问题/index.html","hash":"f7ccc3c3f35d376a2e420a409c61bd6d74198ea4","modified":1646953062519},{"_id":"public/2022/03/07/JavaScript：call、apply、bind的异同/index.html","hash":"b43fdf7a1c1c707b3f42dc4a4f5cc2068311cf28","modified":1646953062519},{"_id":"public/2022/03/03/Renpy：假山问题-浅探transform参数与warper函数/index.html","hash":"120599cc1d1473de8d97c968381fcbcba99cba47","modified":1646953062519},{"_id":"public/archives/page/2/index.html","hash":"c0ec5d421ca26a05a9197ff9d867a07136d0a7f8","modified":1646953062519},{"_id":"public/2022/03/03/Renpy：获取当前标签名/index.html","hash":"049c42c480b78ab7988fbe06eb8dba8d859c3fda","modified":1646953062519},{"_id":"public/archives/2022/page/2/index.html","hash":"2b2fbb0c7172fc80bb9d972048283ba339f7f11d","modified":1646953062519},{"_id":"public/categories/技术/page/2/index.html","hash":"c2170c937af88b872e96ae13f224064cca4760b9","modified":1646953062519},{"_id":"public/archives/2022/03/page/2/index.html","hash":"e5aea82f066e36229f720b087967b4d0cbda092e","modified":1646953062519},{"_id":"public/page/2/index.html","hash":"ad4aaf6ea2a691ce8b97684b6e12b678ed2f8a74","modified":1646953062519},{"_id":"public/tags/ES6/index.html","hash":"5687c2dd0db86e6dc9c9a9758558aa32e07adc50","modified":1646953062519},{"_id":"public/CNAME","hash":"0b414ef86e545620653ecff427ecc7bfc48575b4","modified":1646682765726},{"_id":"themes/butterfly/source/img/cg04.webp","hash":"2ac672decf886b01b37f35c8ac6a3af489fdf8fc","modified":1646719043221},{"_id":"source/_posts/JavaScript：原型和原型链.md","hash":"a11a18394b35a3c08eba61c4941093fdc2530f08","modified":1646722490505},{"_id":"public/2022/03/08/JavaScript：原型和原型链/index.html","hash":"891faf4a40a7a33a393be56e9bdfa44c691c0390","modified":1646953062519},{"_id":"public/img/cg04.webp","hash":"2ac672decf886b01b37f35c8ac6a3af489fdf8fc","modified":1646723079727},{"_id":"source/_posts/CSS：如何画一个三角形.md","hash":"0cb78e67386fba85b01179932238fc536badb33f","modified":1646734665112},{"_id":"public/2022/03/08/CSS：如何画一个三角形/index.html","hash":"c45cf2a43ca5ebcca0ed72b2f02989f20752fd7e","modified":1646953062519},{"_id":"public/categories/技术/CSS/index.html","hash":"4976517ce18cbe3dab5e9a966b634ed4d077b07c","modified":1646953062519},{"_id":"public/tags/CSS/index.html","hash":"8b885218513a2a2ab64da24dcdbb4f64411fc80e","modified":1646953062519},{"_id":"source/_posts/Vue：-nextTick使用.md","hash":"ac29bf39ba8da0e2caefb8ddc377423a65e5ebda","modified":1646949443993},{"_id":"source/_posts/HTML：语义化标签.md","hash":"5230826277e6ea68f313d5f51aa05ff3fa5db9ef","modified":1646950449593},{"_id":"source/_posts/JavaScript：防抖和节流.md","hash":"d2542f20ca7736f5ecfe642f980aacafe2d08b11","modified":1646951625775},{"_id":"source/_posts/Vue：Keep-alive标签与它的生命周期钩子.md","hash":"4698c01ad30fa4ec42fa623a04dc06b2cb3362a0","modified":1646952825078},{"_id":"public/2022/03/11/Vue：Keep-alive标签与它的生命周期钩子/index.html","hash":"8aada423746425aa84e76bb860bc8b1895f1422c","modified":1646953062519},{"_id":"public/2022/03/11/JavaScript：防抖和节流/index.html","hash":"8ab15602331204b3da5d8ca21ce5fbb4aa145db4","modified":1646953062519},{"_id":"public/2022/03/11/HTML：语义化标签/index.html","hash":"dbef1164b6e1039b0f5801692c5fa539b313f976","modified":1646953062519},{"_id":"public/2022/03/11/Vue：-nextTick使用/index.html","hash":"6047d9e3e2b79164981c785eb7a020fb1556d54b","modified":1646953062519},{"_id":"public/categories/技术/Vue/index.html","hash":"008ac6afb1ae29a3a83113e607627c51667edbb5","modified":1646953062519},{"_id":"public/categories/技术/HTML/index.html","hash":"64029f30f5c3ecba7716806d7996d194548bfabc","modified":1646953062519},{"_id":"public/tags/Vue/index.html","hash":"81f3f7332309388cb8222a57b2c93cafb8aa17b4","modified":1646953062519},{"_id":"public/tags/HTML/index.html","hash":"d6b4b1ec022c19140cbb3a78fd0dabab7c1c62a9","modified":1646953062519},{"_id":"source/_posts/算法：寻找最长斐波那契数列.md","hash":"f76919c2b7732f1d20edab7d48efa4063e5b07a3","modified":1647183923555}],"Category":[{"name":"技术","_id":"cl0f8k8gk0007fsuhcx1jh29n"},{"name":"JavaScript","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gq000gfsuhbabzdsva"},{"name":"算法","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gr000jfsuh0h1988b0"},{"name":"Renpy","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gs000nfsuh3u9w153m"},{"name":"KrKr","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gu000wfsuh781fgdn3"},{"name":"CSS","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0hzb1h00002j0uhhtn2cbgx"},{"name":"Vue","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0lj6vyn0002j0uh9nh6gein"},{"name":"HTML","parent":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ljn4jo0008j0uh7edsawou"}],"Data":[],"Page":[{"title":"标签","date":"2022-03-03T08:18:48.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2022-03-03 16:18:48\ntype: \"tags\"\n---\n","updated":"2022-03-03T18:43:54.903Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cl0f8k8g60000fsuh277p5xoe","content":"","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":""},{"title":"关于我","date":"2022-03-03T09:12:57.000Z","_content":"\n写一些关于我的东西。\n\n当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。\n\n不过这也没什么、不过是收拾收拾行李，再重头罢了。\n\n","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2022-03-03 17:12:57\n---\n\n写一些关于我的东西。\n\n当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。\n\n不过这也没什么、不过是收拾收拾行李，再重头罢了。\n\n","updated":"2022-03-08T11:07:27.726Z","path":"about/index.html","_id":"cl0f8k8gd0002fsuhh7gq2ui0","comments":1,"layout":"page","content":"<p>写一些关于我的东西。</p>\n<p>当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。</p>\n<p>不过这也没什么、不过是收拾收拾行李，再重头罢了。</p>\n","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":"<p>写一些关于我的东西。</p>\n<p>当将一个自我化的个体突然放在世俗的评判体系下，那些引以为傲的优点仿佛丢失精度的浮点数一样，变得一文不值，甚至让我一度无法认知自己。</p>\n<p>不过这也没什么、不过是收拾收拾行李，再重头罢了。</p>\n"},{"title":"分类","date":"2022-03-03T08:19:33.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2022-03-03 16:19:33\ntype: \"categories\"\n---\n","updated":"2022-03-03T18:43:54.902Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cl0f8k8gi0005fsuh3w7ycqq9","content":"","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":""}],"Post":[{"title":"KAG：回到标题与BookMark","date":"2022-03-04T01:12:18.000Z","copyright":false,"_content":"\n## 1.回到标题机制\n\n于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。\n\n\n```kag\nfunction goToStart()\n{\n\t// 最初に戻る\n\tif(!startAnchorEnabled) return;\n\tloadBookMark(2021, false); // 栞を読み込む999\n}\nfunction goToStartWithAsk()\n{\n\t// 最初に戻る(確認あり)\n    askYesNo(\"返回标题吗？\", \"确认\", goToStart);\n}\n```\n\n其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。\n\n```kag\nfunction setStartAnchorEnabled(enabled)\n{\n\t// 「最初に戻る」の有効/無効の設定\n\tstartAnchorEnabled = enabled;\n\tif(enabled) saveBookMark(999, false); // 999 番に保存\n\tsetMenuAccessibleAll();\n}\n```\n\nloadBookMark会读取标记点的内容。\n\n**tip：标记点取决于\"\\*|\"即标签（*）以及可存储符号（|）。**\n\n**未加（|）的标签无法存储标记点。**\n\n## 2.保存标记点[startAnchor]机制\n\n在MainWindows.tjs内，制作被【】识别的function：\n\n```tjs\n  startanchor : function(elm)\n  {\n    // 「最初に戻る」の使用不可・使用可を設定する\n    setStartAnchorEnabled(elm.enabled === void || +elm.enabled);\n    return 0;\n  } incontextof this,\n```\n\n其使得\n\n```tjs\n  function setStartAnchorEnabled(enabled)\n  {\n​    // 「最初に戻る」の有効/無効の設定\n​    startAnchorEnabled = enabled;\n​    if(enabled) saveBookMark(999, false); // 999 番に保存\n​    setMenuAccessibleAll();\n  }\n```\n\n此代码块在savedata内保存了一个data999.ksd的文件\n\n**tip：data1000是记录“重载脚本”功能的存档。**\n\n\n\n## 3.saveBookMark和loadBookMark\n\n同样在MainWindows.tjs内，\n\n\n\n```\n  function saveBookMark(num, savehist = true)\n  {\n​    // 栞番号 num に栞を保存する\n​    if(readOnlyMode) return false;\n​    if(bookMarkProtectedStates[num]) return false;\n​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);\n​    if(ret)\n​    {\n​      // メニュー / bookMarkNames / bookMarkDates を更新\n​      getBookMarkInfoFromData(pcflags, num);\n​    }\n​    return ret;\n  }\n```\n\n请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。\n\n另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：\n\n```\n  function loadBookMark(num, loaduser = true)\n\n  {\n\n​    // 栞番号 num からデータを読み出す\n\n​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);\n\n  }\n```\n\n而loadBookMarkFromFile如下，\n\n```\n  function loadBookMarkFromFileWithAsk()\n  {\n​    // 任意のファイルから栞を読み込む\n​    var initialdir = \"\";\n​    if(lastSaveDataNameGlobal == \"\")\n​      initialdir = saveDataLocation + \"/\";\n​    var selectdata = %[\n​      title:\"栞をたどる\",\n​      filter: [saveThumbnail ?\n​          \"サムネイル画像付き栞データ(*.bmp)|*.bmp\" :\n​          \"栞データ(*.kdt)|*.kdt\"],\n​      filterIndex : 1,\n​      name : lastSaveDataNameGlobal,\n​      initialDir : initialdir,\n​      defaultExt : saveThumbnail?\"bmp\":\"kdt\",\n​      save : false,\n​    ];\n​    if(Storages.selectFile(selectdata))\n​    {\n​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);\n​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);\n​    }\n  }\n```\n\n目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。\n\n![KAG：回到标题与BookMark](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png)\n","source":"_posts/KAG：回到标题与BookMark.md","raw":"---\ntitle: KAG：回到标题与BookMark\ndate: 2022-03-04 09:12:18\ncategories:\n  - [技术,KrKr]\ntags: \"KrKr\"\ncopyright: false\n---\n\n## 1.回到标题机制\n\n于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。\n\n\n```kag\nfunction goToStart()\n{\n\t// 最初に戻る\n\tif(!startAnchorEnabled) return;\n\tloadBookMark(2021, false); // 栞を読み込む999\n}\nfunction goToStartWithAsk()\n{\n\t// 最初に戻る(確認あり)\n    askYesNo(\"返回标题吗？\", \"确认\", goToStart);\n}\n```\n\n其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。\n\n```kag\nfunction setStartAnchorEnabled(enabled)\n{\n\t// 「最初に戻る」の有効/無効の設定\n\tstartAnchorEnabled = enabled;\n\tif(enabled) saveBookMark(999, false); // 999 番に保存\n\tsetMenuAccessibleAll();\n}\n```\n\nloadBookMark会读取标记点的内容。\n\n**tip：标记点取决于\"\\*|\"即标签（*）以及可存储符号（|）。**\n\n**未加（|）的标签无法存储标记点。**\n\n## 2.保存标记点[startAnchor]机制\n\n在MainWindows.tjs内，制作被【】识别的function：\n\n```tjs\n  startanchor : function(elm)\n  {\n    // 「最初に戻る」の使用不可・使用可を設定する\n    setStartAnchorEnabled(elm.enabled === void || +elm.enabled);\n    return 0;\n  } incontextof this,\n```\n\n其使得\n\n```tjs\n  function setStartAnchorEnabled(enabled)\n  {\n​    // 「最初に戻る」の有効/無効の設定\n​    startAnchorEnabled = enabled;\n​    if(enabled) saveBookMark(999, false); // 999 番に保存\n​    setMenuAccessibleAll();\n  }\n```\n\n此代码块在savedata内保存了一个data999.ksd的文件\n\n**tip：data1000是记录“重载脚本”功能的存档。**\n\n\n\n## 3.saveBookMark和loadBookMark\n\n同样在MainWindows.tjs内，\n\n\n\n```\n  function saveBookMark(num, savehist = true)\n  {\n​    // 栞番号 num に栞を保存する\n​    if(readOnlyMode) return false;\n​    if(bookMarkProtectedStates[num]) return false;\n​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);\n​    if(ret)\n​    {\n​      // メニュー / bookMarkNames / bookMarkDates を更新\n​      getBookMarkInfoFromData(pcflags, num);\n​    }\n​    return ret;\n  }\n```\n\n请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。\n\n另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：\n\n```\n  function loadBookMark(num, loaduser = true)\n\n  {\n\n​    // 栞番号 num からデータを読み出す\n\n​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);\n\n  }\n```\n\n而loadBookMarkFromFile如下，\n\n```\n  function loadBookMarkFromFileWithAsk()\n  {\n​    // 任意のファイルから栞を読み込む\n​    var initialdir = \"\";\n​    if(lastSaveDataNameGlobal == \"\")\n​      initialdir = saveDataLocation + \"/\";\n​    var selectdata = %[\n​      title:\"栞をたどる\",\n​      filter: [saveThumbnail ?\n​          \"サムネイル画像付き栞データ(*.bmp)|*.bmp\" :\n​          \"栞データ(*.kdt)|*.kdt\"],\n​      filterIndex : 1,\n​      name : lastSaveDataNameGlobal,\n​      initialDir : initialdir,\n​      defaultExt : saveThumbnail?\"bmp\":\"kdt\",\n​      save : false,\n​    ];\n​    if(Storages.selectFile(selectdata))\n​    {\n​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);\n​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);\n​    }\n  }\n```\n\n目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。\n\n![KAG：回到标题与BookMark](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png)\n","slug":"KAG：回到标题与BookMark","published":1,"updated":"2022-03-07T13:26:36.343Z","_id":"cl0f8k8gj0006fsuh924ag8r2","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"1-回到标题机制\"><a href=\"#1-回到标题机制\" class=\"headerlink\" title=\"1.回到标题机制\"></a>1.回到标题机制</h2><p>于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goToStart()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る</span><br><span class=\"line\">\tif(!startAnchorEnabled) return;</span><br><span class=\"line\">\tloadBookMark(2021, false); // 栞を読み込む999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function goToStartWithAsk()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る(確認あり)</span><br><span class=\"line\">    askYesNo(&quot;返回标题吗？&quot;, &quot;确认&quot;, goToStart);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">\tstartAnchorEnabled = enabled;</span><br><span class=\"line\">\tif(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">\tsetMenuAccessibleAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadBookMark会读取标记点的内容。</p>\n<p><strong>tip：标记点取决于”*|”即标签（*）以及可存储符号（|）。</strong></p>\n<p><strong>未加（|）的标签无法存储标记点。</strong></p>\n<h2 id=\"2-保存标记点-startAnchor-机制\"><a href=\"#2-保存标记点-startAnchor-机制\" class=\"headerlink\" title=\"2.保存标记点[startAnchor]机制\"></a>2.保存标记点[startAnchor]机制</h2><p>在MainWindows.tjs内，制作被【】识别的function：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startanchor : function(elm)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 「最初に戻る」の使用不可・使用可を設定する</span><br><span class=\"line\">  setStartAnchorEnabled(elm.enabled === void || +elm.enabled);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125; incontextof this,</span><br></pre></td></tr></table></figure>\n\n<p>其使得</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">​    startAnchorEnabled = enabled;</span><br><span class=\"line\">​    if(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">​    setMenuAccessibleAll();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此代码块在savedata内保存了一个data999.ksd的文件</p>\n<p><strong>tip：data1000是记录“重载脚本”功能的存档。</strong></p>\n<h2 id=\"3-saveBookMark和loadBookMark\"><a href=\"#3-saveBookMark和loadBookMark\" class=\"headerlink\" title=\"3.saveBookMark和loadBookMark\"></a>3.saveBookMark和loadBookMark</h2><p>同样在MainWindows.tjs内，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function saveBookMark(num, savehist = true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 栞番号 num に栞を保存する</span><br><span class=\"line\">​    if(readOnlyMode) return false;</span><br><span class=\"line\">​    if(bookMarkProtectedStates[num]) return false;</span><br><span class=\"line\">​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);</span><br><span class=\"line\">​    if(ret)</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      // メニュー / bookMarkNames / bookMarkDates を更新</span><br><span class=\"line\">​      getBookMarkInfoFromData(pcflags, num);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">​    return ret;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。</p>\n<p>另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMark(num, loaduser = true)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    // 栞番号 num からデータを読み出す</span><br><span class=\"line\"></span><br><span class=\"line\">​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而loadBookMarkFromFile如下，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMarkFromFileWithAsk()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 任意のファイルから栞を読み込む</span><br><span class=\"line\">​    var initialdir = &quot;&quot;;</span><br><span class=\"line\">​    if(lastSaveDataNameGlobal == &quot;&quot;)</span><br><span class=\"line\">​      initialdir = saveDataLocation + &quot;/&quot;;</span><br><span class=\"line\">​    var selectdata = %[</span><br><span class=\"line\">​      title:&quot;栞をたどる&quot;,</span><br><span class=\"line\">​      filter: [saveThumbnail ?</span><br><span class=\"line\">​          &quot;サムネイル画像付き栞データ(*.bmp)|*.bmp&quot; :</span><br><span class=\"line\">​          &quot;栞データ(*.kdt)|*.kdt&quot;],</span><br><span class=\"line\">​      filterIndex : 1,</span><br><span class=\"line\">​      name : lastSaveDataNameGlobal,</span><br><span class=\"line\">​      initialDir : initialdir,</span><br><span class=\"line\">​      defaultExt : saveThumbnail?&quot;bmp&quot;:&quot;kdt&quot;,</span><br><span class=\"line\">​      save : false,</span><br><span class=\"line\">​    ];</span><br><span class=\"line\">​    if(Storages.selectFile(selectdata))</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);</span><br><span class=\"line\">​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png\" alt=\"KAG：回到标题与BookMark\"></p>\n","site":{"data":{}},"cover":"/img/CG00.png","excerpt":"","more":"<h2 id=\"1-回到标题机制\"><a href=\"#1-回到标题机制\" class=\"headerlink\" title=\"1.回到标题机制\"></a>1.回到标题机制</h2><p>于macro_ui.ks的回到标题按钮（sysbutton）会调用kag.goToStartWithAsk()以存读档的方式完美回到标题。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function goToStart()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る</span><br><span class=\"line\">\tif(!startAnchorEnabled) return;</span><br><span class=\"line\">\tloadBookMark(2021, false); // 栞を読み込む999</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function goToStartWithAsk()</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 最初に戻る(確認あり)</span><br><span class=\"line\">    askYesNo(&quot;返回标题吗？&quot;, &quot;确认&quot;, goToStart);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中、goToStart会先判断startAnchorEnabled，即某处的[startAnchor]是否保存了一个startAnchor存档。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t// 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">\tstartAnchorEnabled = enabled;</span><br><span class=\"line\">\tif(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">\tsetMenuAccessibleAll();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>loadBookMark会读取标记点的内容。</p>\n<p><strong>tip：标记点取决于”*|”即标签（*）以及可存储符号（|）。</strong></p>\n<p><strong>未加（|）的标签无法存储标记点。</strong></p>\n<h2 id=\"2-保存标记点-startAnchor-机制\"><a href=\"#2-保存标记点-startAnchor-机制\" class=\"headerlink\" title=\"2.保存标记点[startAnchor]机制\"></a>2.保存标记点[startAnchor]机制</h2><p>在MainWindows.tjs内，制作被【】识别的function：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">startanchor : function(elm)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  // 「最初に戻る」の使用不可・使用可を設定する</span><br><span class=\"line\">  setStartAnchorEnabled(elm.enabled === void || +elm.enabled);</span><br><span class=\"line\">  return 0;</span><br><span class=\"line\">&#125; incontextof this,</span><br></pre></td></tr></table></figure>\n\n<p>其使得</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function setStartAnchorEnabled(enabled)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 「最初に戻る」の有効/無効の設定</span><br><span class=\"line\">​    startAnchorEnabled = enabled;</span><br><span class=\"line\">​    if(enabled) saveBookMark(999, false); // 999 番に保存</span><br><span class=\"line\">​    setMenuAccessibleAll();</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>此代码块在savedata内保存了一个data999.ksd的文件</p>\n<p><strong>tip：data1000是记录“重载脚本”功能的存档。</strong></p>\n<h2 id=\"3-saveBookMark和loadBookMark\"><a href=\"#3-saveBookMark和loadBookMark\" class=\"headerlink\" title=\"3.saveBookMark和loadBookMark\"></a>3.saveBookMark和loadBookMark</h2><p>同样在MainWindows.tjs内，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function saveBookMark(num, savehist = true)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 栞番号 num に栞を保存する</span><br><span class=\"line\">​    if(readOnlyMode) return false;</span><br><span class=\"line\">​    if(bookMarkProtectedStates[num]) return false;</span><br><span class=\"line\">​    var ret = saveBookMarkToFile(getBookMarkFileNameAtNum(num), savehist);</span><br><span class=\"line\">​    if(ret)</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      // メニュー / bookMarkNames / bookMarkDates を更新</span><br><span class=\"line\">​      getBookMarkInfoFromData(pcflags, num);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">​    return ret;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>请注意savehist这个参数，似乎这一项为false的情况下，saveBookMark就并不会保存ksd文件，而是如同游戏内存档一样保存。</p>\n<p>另外，loadBookMark这个参数很蹩脚，需要原封不动的传递到loadBookMarkFromFile这个参数内：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMark(num, loaduser = true)</span><br><span class=\"line\"></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    // 栞番号 num からデータを読み出す</span><br><span class=\"line\"></span><br><span class=\"line\">​    return loadBookMarkFromFile(getBookMarkFileNameAtNum(num), loaduser);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>而loadBookMarkFromFile如下，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  function loadBookMarkFromFileWithAsk()</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">​    // 任意のファイルから栞を読み込む</span><br><span class=\"line\">​    var initialdir = &quot;&quot;;</span><br><span class=\"line\">​    if(lastSaveDataNameGlobal == &quot;&quot;)</span><br><span class=\"line\">​      initialdir = saveDataLocation + &quot;/&quot;;</span><br><span class=\"line\">​    var selectdata = %[</span><br><span class=\"line\">​      title:&quot;栞をたどる&quot;,</span><br><span class=\"line\">​      filter: [saveThumbnail ?</span><br><span class=\"line\">​          &quot;サムネイル画像付き栞データ(*.bmp)|*.bmp&quot; :</span><br><span class=\"line\">​          &quot;栞データ(*.kdt)|*.kdt&quot;],</span><br><span class=\"line\">​      filterIndex : 1,</span><br><span class=\"line\">​      name : lastSaveDataNameGlobal,</span><br><span class=\"line\">​      initialDir : initialdir,</span><br><span class=\"line\">​      defaultExt : saveThumbnail?&quot;bmp&quot;:&quot;kdt&quot;,</span><br><span class=\"line\">​      save : false,</span><br><span class=\"line\">​    ];</span><br><span class=\"line\">​    if(Storages.selectFile(selectdata))</span><br><span class=\"line\">​    &#123;</span><br><span class=\"line\">​      loadBookMarkFromFile(lastSaveDataName = lastSaveDataNameGlobal = selectdata.name);</span><br><span class=\"line\">​      lastSaveDataName = Storages.chopStorageExt(lastSaveDataName);</span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>目前仅研究到这一步，能窥见标签系统与书签系统所联动模式的一角，也算有点收获。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040911291.png\" alt=\"KAG：回到标题与BookMark\"></p>\n"},{"title":"JavaScript：call、apply、bind的异同","copyright":false,"date":"2022-03-07T08:40:48.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071642106.webp","_content":"\n# JavaScript：call、apply、bind的异同\n\n**首先，call()、apply()、bind() 都是用来重定义 this 对象的。**\n\n在ES5中，this总是指向最后调用函数的对象。\n\n## this对象\n\n```\n    var name = \"windowsName\";\n    function a() {\n        var name = \"Cherry\";\n\n        console.log(this.name);          // windowsName\n\n        console.log(\"inner:\" + this);    // inner: Window\n    }\n    a();\n    console.log(\"outer:\" + this)         // outer: Window\n```\n\n `a();`因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 `window.a()`\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    a.fn();\n```\n\n在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。\n\n```\nvar name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    window.a.fn();\n```\n\n此处对象依然是a调用的。\n\n然而，请看下面这个例子：\n\n```\n    var name = \"windowsName\";\n    var a = {\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // undefined\n        }\n    }\n    window.a.fn();\n```\n\n这里为什么会打印 `undefined` 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 `this.name` 的值是 `undefined`。\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name : null,\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // windowsName\n        }\n    }\n\n    var f = a.fn;\n    f();\n```\n\n此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。\n\n## call、apply\n\n apply 和 call 基本类似，他们的区别只是传入的参数不同。\n\ncall() 与apply()只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。\n\ncall：\n\n```\nfunction.call(thisArg, arg1, arg2, ...)\n```\n\napply：\n\n```\nfunc.apply(thisArg, [argsArray])\n```\n\n## bind\n\nbind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。\n\n**bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 `this` 被指定为 `bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。**\n\nbind：\n\n```\nfunction.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n### 柯里化（curry）\n\nbind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\n举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。\n\n柯里化的目的是为了复用参数，通过封装代码提升代码复用度。\n","source":"_posts/JavaScript：call、apply、bind的异同.md","raw":"---\ntitle: JavaScript：call、apply、bind的异同\ncopyright: false\ndate: 2022-03-07 16:40:48\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071642106.webp\"\ncategories: \n  - [技术,JavaScript]\n---\n\n# JavaScript：call、apply、bind的异同\n\n**首先，call()、apply()、bind() 都是用来重定义 this 对象的。**\n\n在ES5中，this总是指向最后调用函数的对象。\n\n## this对象\n\n```\n    var name = \"windowsName\";\n    function a() {\n        var name = \"Cherry\";\n\n        console.log(this.name);          // windowsName\n\n        console.log(\"inner:\" + this);    // inner: Window\n    }\n    a();\n    console.log(\"outer:\" + this)         // outer: Window\n```\n\n `a();`因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 `window.a()`\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    a.fn();\n```\n\n在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。\n\n```\nvar name = \"windowsName\";\n    var a = {\n        name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // Cherry\n        }\n    }\n    window.a.fn();\n```\n\n此处对象依然是a调用的。\n\n然而，请看下面这个例子：\n\n```\n    var name = \"windowsName\";\n    var a = {\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // undefined\n        }\n    }\n    window.a.fn();\n```\n\n这里为什么会打印 `undefined` 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 `this.name` 的值是 `undefined`。\n\n```\n    var name = \"windowsName\";\n    var a = {\n        name : null,\n        // name: \"Cherry\",\n        fn : function () {\n            console.log(this.name);      // windowsName\n        }\n    }\n\n    var f = a.fn;\n    f();\n```\n\n此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。\n\n## call、apply\n\n apply 和 call 基本类似，他们的区别只是传入的参数不同。\n\ncall() 与apply()只有一个区别，就是 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。\n\ncall：\n\n```\nfunction.call(thisArg, arg1, arg2, ...)\n```\n\napply：\n\n```\nfunc.apply(thisArg, [argsArray])\n```\n\n## bind\n\nbind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。\n\n**bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 `this` 被指定为 `bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。**\n\nbind：\n\n```\nfunction.bind(thisArg[, arg1[, arg2[, ...]]])\n```\n\n### 柯里化（curry）\n\nbind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。\n\n举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。\n\n柯里化的目的是为了复用参数，通过封装代码提升代码复用度。\n","slug":"JavaScript：call、apply、bind的异同","published":1,"updated":"2022-03-07T13:26:17.807Z","_id":"cl0ggkbsp0003q8uh1rvdgivt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript：call、apply、bind的异同\"><a href=\"#JavaScript：call、apply、bind的异同\" class=\"headerlink\" title=\"JavaScript：call、apply、bind的异同\"></a>JavaScript：call、apply、bind的异同</h1><p><strong>首先，call()、apply()、bind() 都是用来重定义 this 对象的。</strong></p>\n<p>在ES5中，this总是指向最后调用函数的对象。</p>\n<h2 id=\"this对象\"><a href=\"#this对象\" class=\"headerlink\" title=\"this对象\"></a>this对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    var name = &quot;Cherry&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(this.name);          // windowsName</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure>\n\n<p> <code>a();</code>因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 <code>window.a()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // Cherry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">    var a = &#123;</span><br><span class=\"line\">        name: &quot;Cherry&quot;,</span><br><span class=\"line\">        fn : function () &#123;</span><br><span class=\"line\">            console.log(this.name);      // Cherry</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>此处对象依然是a调用的。</p>\n<p>然而，请看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : null,</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // windowsName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = a.fn;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。</p>\n<h2 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h2><p> apply 和 call 基本类似，他们的区别只是传入的参数不同。</p>\n<p>call() 与apply()只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>\n<p>call：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>\n\n<p>apply：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>bind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。</p>\n<p><strong>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</strong></p>\n<p>bind：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h3><p>bind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>\n<p>举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。</p>\n<p>柯里化的目的是为了复用参数，通过封装代码提升代码复用度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript：call、apply、bind的异同\"><a href=\"#JavaScript：call、apply、bind的异同\" class=\"headerlink\" title=\"JavaScript：call、apply、bind的异同\"></a>JavaScript：call、apply、bind的异同</h1><p><strong>首先，call()、apply()、bind() 都是用来重定义 this 对象的。</strong></p>\n<p>在ES5中，this总是指向最后调用函数的对象。</p>\n<h2 id=\"this对象\"><a href=\"#this对象\" class=\"headerlink\" title=\"this对象\"></a>this对象</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    var name = &quot;Cherry&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(this.name);          // windowsName</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&quot;inner:&quot; + this);    // inner: Window</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\">console.log(&quot;outer:&quot; + this)         // outer: Window</span><br></pre></td></tr></table></figure>\n\n<p> <code>a();</code>因为前面没有调用的对象、那么就是全局对象 window，这就相当于是 <code>window.a()</code></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // Cherry</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>在这个例子中，函数 fn 是对象 a 调用的，所以打印的值就是 a 中的 name 的值。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">    var a = &#123;</span><br><span class=\"line\">        name: &quot;Cherry&quot;,</span><br><span class=\"line\">        fn : function () &#123;</span><br><span class=\"line\">            console.log(this.name);      // Cherry</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>此处对象依然是a调用的。</p>\n<p>然而，请看下面这个例子：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // undefined</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.a.fn();</span><br></pre></td></tr></table></figure>\n\n<p>这里为什么会打印 <code>undefined</code> 呢？这是因为正如刚刚所描述的那样，调用 fn 的是 a 对象，也就是说 fn 的内部的 this 是对象 a，而对象 a 中并没有对 name 进行定义，所以 log 的 <code>this.name</code> 的值是 <code>undefined</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var name = &quot;windowsName&quot;;</span><br><span class=\"line\">var a = &#123;</span><br><span class=\"line\">    name : null,</span><br><span class=\"line\">    // name: &quot;Cherry&quot;,</span><br><span class=\"line\">    fn : function () &#123;</span><br><span class=\"line\">        console.log(this.name);      // windowsName</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var f = a.fn;</span><br><span class=\"line\">f();</span><br></pre></td></tr></table></figure>\n\n<p>此处有一点很容易错误的，虽然f拥有a.fn()的方法，但是调用它的仍然是windows。</p>\n<h2 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h2><p> apply 和 call 基本类似，他们的区别只是传入的参数不同。</p>\n<p>call() 与apply()只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>\n<p>call：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.call(thisArg, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>\n\n<p>apply：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">func.apply(thisArg, [argsArray])</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h2><p>bind与其他两者不同的是，它返回的是一个函数，而其他的参数会作为这个返回函数的参数传递。</p>\n<p><strong>bind() 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code>的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</strong></p>\n<p>bind：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"柯里化（curry）\"><a href=\"#柯里化（curry）\" class=\"headerlink\" title=\"柯里化（curry）\"></a>柯里化（curry）</h3><p>bind还涉及一个柯里化的问题，在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>\n<p>举例来说，一个接收3个参数的普通函数，在进行柯里化后， 柯里化版本的函数接收一个参数并返回接收下一个参数的函数， 该函数返回一个接收第三个参数的函数。 最后一个函数在接收第三个参数后， 将之前接收到的三个参数应用于原普通函数中，并返回最终结果。</p>\n<p>柯里化的目的是为了复用参数，通过封装代码提升代码复用度。</p>\n"},{"title":"JavaScript：Var、let、const的异同","date":"2022-03-05T11:51:25.000Z","copyright":false,"cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052139275.webp","_content":"\n# Var、let、const的异同\n\n## 一、var概述\n\n在JavaScriptES5之前，js使用var关键字来创建变量。\n\n但是，var却有三个致命的问题。\n\n### 1.赋值提升\n\n```javascript\nconsole.log(text) //undefined\n\nvar text = \"Hello\"\n```\n\n一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。\n\n```javascript\nvar text;\n\nconsole.log(text)\n\ntext = \"Hello\"\n```\n\n这便是赋值提升。\n\n### 2.声明覆盖\n\n```\nvar a = \"Hello\"\nvar a = \"world\"\nconsole.log(a) //\"world\"\n```\n\n这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。\n\n在项目中，如果依然保持声明覆盖是很危险的。\n\n### 3.私有作用域的缺失\n\n```\nfor (var i = 0; i < 2; i++) {\n    console.log(i)\n}\nconsole.log(i)\n/*\n0\n1\n2\n3\n*/\n```\n\ni这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。\n\n## 二、let和const\n\n在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。\n\n除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。\n\n```\nconst pi =3.14\npi = 3 //Uncaught TypeError: Assignment to constant variable.\n```\n\n当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。\n\n但是，如果是一个应用数据类型的话：\n\n```\nconst pi =[0,3,10]\npi[0] = 3\nconsole.log(pi);//(3) [3, 3, 10]\n```\n\n","source":"_posts/JavaScript：Var、let、const的异同.md","raw":"---\ntitle: JavaScript：Var、let、const的异同\ndate: 2022-03-05 19:51:25\ntags: JavaScript\ncopyright: false\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052139275.webp\"\ncategories: \n  - [技术,JavaScript]\n---\n\n# Var、let、const的异同\n\n## 一、var概述\n\n在JavaScriptES5之前，js使用var关键字来创建变量。\n\n但是，var却有三个致命的问题。\n\n### 1.赋值提升\n\n```javascript\nconsole.log(text) //undefined\n\nvar text = \"Hello\"\n```\n\n一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。\n\n```javascript\nvar text;\n\nconsole.log(text)\n\ntext = \"Hello\"\n```\n\n这便是赋值提升。\n\n### 2.声明覆盖\n\n```\nvar a = \"Hello\"\nvar a = \"world\"\nconsole.log(a) //\"world\"\n```\n\n这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。\n\n在项目中，如果依然保持声明覆盖是很危险的。\n\n### 3.私有作用域的缺失\n\n```\nfor (var i = 0; i < 2; i++) {\n    console.log(i)\n}\nconsole.log(i)\n/*\n0\n1\n2\n3\n*/\n```\n\ni这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。\n\n## 二、let和const\n\n在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。\n\n除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。\n\n```\nconst pi =3.14\npi = 3 //Uncaught TypeError: Assignment to constant variable.\n```\n\n当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。\n\n但是，如果是一个应用数据类型的话：\n\n```\nconst pi =[0,3,10]\npi[0] = 3\nconsole.log(pi);//(3) [3, 3, 10]\n```\n\n","slug":"JavaScript：Var、let、const的异同","published":1,"updated":"2022-03-07T13:26:24.649Z","_id":"cl0ggkjjk0007q8uh4l0m8qax","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Var、let、const的异同\"><a href=\"#Var、let、const的异同\" class=\"headerlink\" title=\"Var、let、const的异同\"></a>Var、let、const的异同</h1><h2 id=\"一、var概述\"><a href=\"#一、var概述\" class=\"headerlink\" title=\"一、var概述\"></a>一、var概述</h2><p>在JavaScriptES5之前，js使用var关键字来创建变量。</p>\n<p>但是，var却有三个致命的问题。</p>\n<h3 id=\"1-赋值提升\"><a href=\"#1-赋值提升\" class=\"headerlink\" title=\"1.赋值提升\"></a>1.赋值提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text)</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这便是赋值提升。</p>\n<h3 id=\"2-声明覆盖\"><a href=\"#2-声明覆盖\" class=\"headerlink\" title=\"2.声明覆盖\"></a>2.声明覆盖</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &quot;Hello&quot;</span><br><span class=\"line\">var a = &quot;world&quot;</span><br><span class=\"line\">console.log(a) //&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。</p>\n<p>在项目中，如果依然保持声明覆盖是很危险的。</p>\n<h3 id=\"3-私有作用域的缺失\"><a href=\"#3-私有作用域的缺失\" class=\"headerlink\" title=\"3.私有作用域的缺失\"></a>3.私有作用域的缺失</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i)</span><br><span class=\"line\">/*</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>i这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。</p>\n<h2 id=\"二、let和const\"><a href=\"#二、let和const\" class=\"headerlink\" title=\"二、let和const\"></a>二、let和const</h2><p>在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。</p>\n<p>除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =3.14</span><br><span class=\"line\">pi = 3 //Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<p>当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。</p>\n<p>但是，如果是一个应用数据类型的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =[0,3,10]</span><br><span class=\"line\">pi[0] = 3</span><br><span class=\"line\">console.log(pi);//(3) [3, 3, 10]</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Var、let、const的异同\"><a href=\"#Var、let、const的异同\" class=\"headerlink\" title=\"Var、let、const的异同\"></a>Var、let、const的异同</h1><h2 id=\"一、var概述\"><a href=\"#一、var概述\" class=\"headerlink\" title=\"一、var概述\"></a>一、var概述</h2><p>在JavaScriptES5之前，js使用var关键字来创建变量。</p>\n<p>但是，var却有三个致命的问题。</p>\n<h3 id=\"1-赋值提升\"><a href=\"#1-赋值提升\" class=\"headerlink\" title=\"1.赋值提升\"></a>1.赋值提升</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text) <span class=\"comment\">//undefined</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>一般来说，text在log语句之下才声明，按照js单线程来说，这个位置理当报错，然而在执行的时候，log却返回的是undefined。这证明上面的代码块与下面的代码块等效。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> text;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(text)</span><br><span class=\"line\"></span><br><span class=\"line\">text = <span class=\"string\">&quot;Hello&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>这便是赋值提升。</p>\n<h3 id=\"2-声明覆盖\"><a href=\"#2-声明覆盖\" class=\"headerlink\" title=\"2.声明覆盖\"></a>2.声明覆盖</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = &quot;Hello&quot;</span><br><span class=\"line\">var a = &quot;world&quot;</span><br><span class=\"line\">console.log(a) //&quot;world&quot;</span><br></pre></td></tr></table></figure>\n\n<p>这里明明a已经声明过一次，第二次居然还能再一次声明并赋值，这是不合理的。</p>\n<p>在项目中，如果依然保持声明覆盖是很危险的。</p>\n<h3 id=\"3-私有作用域的缺失\"><a href=\"#3-私有作用域的缺失\" class=\"headerlink\" title=\"3.私有作用域的缺失\"></a>3.私有作用域的缺失</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for (var i = 0; i &lt; 2; i++) &#123;</span><br><span class=\"line\">    console.log(i)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(i)</span><br><span class=\"line\">/*</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">*/</span><br></pre></td></tr></table></figure>\n\n<p>i这个变量明明是在for循环内声明的，在外部居然也能访问到，这是很不合理的。非常容易造成变量污染的问题。</p>\n<h2 id=\"二、let和const\"><a href=\"#二、let和const\" class=\"headerlink\" title=\"二、let和const\"></a>二、let和const</h2><p>在ES6，let很好的解决了var的三个问题。不如说let就是一个仿造面向对象语言制作出来的升级版的var。</p>\n<p>除此之外，ES6还提出了const（常量）。const与let相同，一样解决了var的三个问题并且拥有块级作用域。但是他也有一个自我的特性：不可更改。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =3.14</span><br><span class=\"line\">pi = 3 //Uncaught TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>\n\n<p>当const声明基本类型变量的时候，变量是无法被更改或是再次赋值的。</p>\n<p>但是，如果是一个应用数据类型的话：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const pi =[0,3,10]</span><br><span class=\"line\">pi[0] = 3</span><br><span class=\"line\">console.log(pi);//(3) [3, 3, 10]</span><br></pre></td></tr></table></figure>\n\n"},{"title":"Renpy：获取当前标签名","date":"2022-03-03T09:43:51.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png","copyright":false,"_content":"\n# 获取当前标签名\n\nrenpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。\n\n解决方法：重写callback_label函数\n\n```\ninit python:\n\n  def label_callback(name, abnormal):\n\n​    \\# devlog.info(name)\n\n​    store.current_label = name\n\n\n\n  config.label_callback = label_callback\n```\n\n直接将代码块插入脚本，再使用  **$renpy.notify(current_label)** 进行测试\n\n![result](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png)\n\n明显的，已经可以使用了\n","source":"_posts/Renpy：获取当前标签名.md","raw":"---\ntitle: Renpy：获取当前标签名\ndate: 2022-03-03 17:43:51\ncategories:\n  - [技术,Renpy]\ntags: \"Renpy\"\ncover: https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\ncopyright: false\n---\n\n# 获取当前标签名\n\nrenpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。\n\n解决方法：重写callback_label函数\n\n```\ninit python:\n\n  def label_callback(name, abnormal):\n\n​    \\# devlog.info(name)\n\n​    store.current_label = name\n\n\n\n  config.label_callback = label_callback\n```\n\n直接将代码块插入脚本，再使用  **$renpy.notify(current_label)** 进行测试\n\n![result](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png)\n\n明显的，已经可以使用了\n","slug":"Renpy：获取当前标签名","published":1,"updated":"2022-03-07T08:45:55.210Z","_id":"cl0ggkzvc000bq8uhh6wdh8da","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"获取当前标签名\"><a href=\"#获取当前标签名\" class=\"headerlink\" title=\"获取当前标签名\"></a>获取当前标签名</h1><p>renpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。</p>\n<p>解决方法：重写callback_label函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init python:</span><br><span class=\"line\"></span><br><span class=\"line\">  def label_callback(name, abnormal):</span><br><span class=\"line\"></span><br><span class=\"line\">​    \\# devlog.info(name)</span><br><span class=\"line\"></span><br><span class=\"line\">​    store.current_label = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  config.label_callback = label_callback</span><br></pre></td></tr></table></figure>\n\n<p>直接将代码块插入脚本，再使用  <strong>$renpy.notify(current_label)</strong> 进行测试</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\" alt=\"result\"></p>\n<p>明显的，已经可以使用了</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"获取当前标签名\"><a href=\"#获取当前标签名\" class=\"headerlink\" title=\"获取当前标签名\"></a>获取当前标签名</h1><p>renpy原本就有一个[crrent_label]可以获取当前标签名，但是游戏进行过程中当我们call或者jump到其他标签的时候，[crrent_label]获取的还是跳转前的标签名。</p>\n<p>解决方法：重写callback_label函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">init python:</span><br><span class=\"line\"></span><br><span class=\"line\">  def label_callback(name, abnormal):</span><br><span class=\"line\"></span><br><span class=\"line\">​    \\# devlog.info(name)</span><br><span class=\"line\"></span><br><span class=\"line\">​    store.current_label = name</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">  config.label_callback = label_callback</span><br></pre></td></tr></table></figure>\n\n<p>直接将代码块插入脚本，再使用  <strong>$renpy.notify(current_label)</strong> 进行测试</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/Result.png\" alt=\"result\"></p>\n<p>明显的，已经可以使用了</p>\n"},{"title":"Renpy：假山问题-浅探transform参数与warper函数","date":"2022-03-03T09:44:27.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/假山-蓝.png","copyright":false,"_content":"\n# 假山问题-浅探transform参数与warper函数\n\n此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。\n\n```\nimage hiddenM:\n    contains:\n        \"images/假山遮片1.png\"\n        topleft\n        ease 3 yoffset -90\n    contains:\n        \"images/假山遮片2.png\"\n        topleft\n        ease 3 yoffset 360\n\nimage fakeM = \"images/假山.png\"\n\nlabel start:\n    scene fakeM:\n        topleft\n    show hiddenM\n\n    \"测试用\"\n    return\n\n```\n\n## 1.假山问题之解\n\n先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，**contains语句的执行是即时的，不会等待子组件的完成。**contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。\n\n *(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)*\n\n将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。\n\n接下来是对图片进行transform，根据[transform特性列表](https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties)，很容易知道是对其yoffset进行更改使其改变位置。\n\n当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做[warpers](https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers)的函数。\n\n此函数的描述为：*warper是一类函数，其可以改变interpolation语句中定义的时间值。*\n\n也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。\n\n关于warper下面几个语句定义曲线就不赘述了。\n\n**值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。**\n\n## 2.假山问题之遗\n\n之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。\n\n1）两张image组件的互相重叠（层的高度）是有什么决定的？\n\n此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。\n\n2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）\n\n现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。\n\n## 3.关于其他问题的畅想\n\n也许以上此种也能解决\n\n4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动\n\n5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）\n\n8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面\n\n10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）\n\n\n\n","source":"_posts/Renpy：假山问题-浅探transform参数与warper函数.md","raw":"---\ntitle: Renpy：假山问题-浅探transform参数与warper函数\ndate: 2022-03-03 17:44:27\ncategories:\n  - [技术,Renpy]\ntags: \"Renpy\"\ncover: https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/假山-蓝.png\ncopyright: false\n---\n\n# 假山问题-浅探transform参数与warper函数\n\n此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。\n\n```\nimage hiddenM:\n    contains:\n        \"images/假山遮片1.png\"\n        topleft\n        ease 3 yoffset -90\n    contains:\n        \"images/假山遮片2.png\"\n        topleft\n        ease 3 yoffset 360\n\nimage fakeM = \"images/假山.png\"\n\nlabel start:\n    scene fakeM:\n        topleft\n    show hiddenM\n\n    \"测试用\"\n    return\n\n```\n\n## 1.假山问题之解\n\n先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，**contains语句的执行是即时的，不会等待子组件的完成。**contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。\n\n *(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)*\n\n将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。\n\n接下来是对图片进行transform，根据[transform特性列表](https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties)，很容易知道是对其yoffset进行更改使其改变位置。\n\n当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做[warpers](https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers)的函数。\n\n此函数的描述为：*warper是一类函数，其可以改变interpolation语句中定义的时间值。*\n\n也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。\n\n关于warper下面几个语句定义曲线就不赘述了。\n\n**值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。**\n\n## 2.假山问题之遗\n\n之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。\n\n1）两张image组件的互相重叠（层的高度）是有什么决定的？\n\n此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。\n\n2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）\n\n现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。\n\n## 3.关于其他问题的畅想\n\n也许以上此种也能解决\n\n4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动\n\n5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）\n\n8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面\n\n10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）\n\n\n\n","slug":"Renpy：假山问题-浅探transform参数与warper函数","published":1,"updated":"2022-03-07T08:47:13.167Z","_id":"cl0ggl1t9000fq8uhas9s1od0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"假山问题-浅探transform参数与warper函数\"><a href=\"#假山问题-浅探transform参数与warper函数\" class=\"headerlink\" title=\"假山问题-浅探transform参数与warper函数\"></a>假山问题-浅探transform参数与warper函数</h1><p>此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image hiddenM:</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片1.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset -90</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片2.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset 360</span><br><span class=\"line\"></span><br><span class=\"line\">image fakeM = &quot;images/假山.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">label start:</span><br><span class=\"line\">    scene fakeM:</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">    show hiddenM</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;测试用&quot;</span><br><span class=\"line\">    return</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-假山问题之解\"><a href=\"#1-假山问题之解\" class=\"headerlink\" title=\"1.假山问题之解\"></a>1.假山问题之解</h2><p>先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，<strong>contains语句的执行是即时的，不会等待子组件的完成。</strong>contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。</p>\n<p> <em>(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)</em></p>\n<p>将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。</p>\n<p>接下来是对图片进行transform，根据<a href=\"https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties\">transform特性列表</a>，很容易知道是对其yoffset进行更改使其改变位置。</p>\n<p>当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做<a href=\"https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers\">warpers</a>的函数。</p>\n<p>此函数的描述为：<em>warper是一类函数，其可以改变interpolation语句中定义的时间值。</em></p>\n<p>也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。</p>\n<p>关于warper下面几个语句定义曲线就不赘述了。</p>\n<p><strong>值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。</strong></p>\n<h2 id=\"2-假山问题之遗\"><a href=\"#2-假山问题之遗\" class=\"headerlink\" title=\"2.假山问题之遗\"></a>2.假山问题之遗</h2><p>之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。</p>\n<p>1）两张image组件的互相重叠（层的高度）是有什么决定的？</p>\n<p>此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。</p>\n<p>2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）</p>\n<p>现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。</p>\n<h2 id=\"3-关于其他问题的畅想\"><a href=\"#3-关于其他问题的畅想\" class=\"headerlink\" title=\"3.关于其他问题的畅想\"></a>3.关于其他问题的畅想</h2><p>也许以上此种也能解决</p>\n<p>4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动</p>\n<p>5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）</p>\n<p>8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面</p>\n<p>10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"假山问题-浅探transform参数与warper函数\"><a href=\"#假山问题-浅探transform参数与warper函数\" class=\"headerlink\" title=\"假山问题-浅探transform参数与warper函数\"></a>假山问题-浅探transform参数与warper函数</h1><p>此文本是在研究完7号问题（假山遮片）之后，所衍生的对transform参数的查缺补漏，请配合代码块一起食用。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image hiddenM:</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片1.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset -90</span><br><span class=\"line\">    contains:</span><br><span class=\"line\">        &quot;images/假山遮片2.png&quot;</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">        ease 3 yoffset 360</span><br><span class=\"line\"></span><br><span class=\"line\">image fakeM = &quot;images/假山.png&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">label start:</span><br><span class=\"line\">    scene fakeM:</span><br><span class=\"line\">        topleft</span><br><span class=\"line\">    show hiddenM</span><br><span class=\"line\"></span><br><span class=\"line\">    &quot;测试用&quot;</span><br><span class=\"line\">    return</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"1-假山问题之解\"><a href=\"#1-假山问题之解\" class=\"headerlink\" title=\"1.假山问题之解\"></a>1.假山问题之解</h2><p>先单看假山问题，首先是image下面这个contains语句，此物类似于一个组件，将不同的部件拼接在一起，<strong>contains语句的执行是即时的，不会等待子组件的完成。</strong>contains语句可以说是语法糖，使我们很容易将参数传给它的子组件。</p>\n<p> <em>(译者注：语法糖(Syntactic Sugar)，也称作糖衣语法。由英国计算机科学家彼得·约翰·兰达(Peter J. Landin)发明。指计算机语言中添加的某种语法，对语言的功能并没有影响，能更方便程序员使用。通常来说使用语法糖能够增加程序的可读性，从而减少程序代码出错的机会。)</em></p>\n<p>将两个遮片整合入hiddenM之后，我将他们都固定在pos 0，即topleft位置（更低层的假山【这个图片的原名叫做假山-全】也一样）。</p>\n<p>接下来是对图片进行transform，根据<a href=\"https://renpy.cn/doc/atl.html?highlight=image%20contain#transform-properties\">transform特性列表</a>，很容易知道是对其yoffset进行更改使其改变位置。</p>\n<p>当然光是改变静态的位置也是不够的，通过查询文档，我发现一个叫做<a href=\"https://renpy.cn/doc/atl.html?highlight=linear%20ease#warpers\">warpers</a>的函数。</p>\n<p>此函数的描述为：<em>warper是一类函数，其可以改变interpolation语句中定义的时间值。</em></p>\n<p>也许静态的变换并非毫无中间过程，而是变换的时间默认为0，而warper函数是改变了这个默认时间。</p>\n<p>关于warper下面几个语句定义曲线就不赘述了。</p>\n<p><strong>值得一提的是：我使用的是720p的素材，所以请在参数后面乘以1.5。</strong></p>\n<h2 id=\"2-假山问题之遗\"><a href=\"#2-假山问题之遗\" class=\"headerlink\" title=\"2.假山问题之遗\"></a>2.假山问题之遗</h2><p>之后的事情就很容易了，此处不再赘述，但是我还有两个未解的疑惑。</p>\n<p>1）两张image组件的互相重叠（层的高度）是有什么决定的？</p>\n<p>此处大胆猜测是先后顺序，代码中先出现的fakeM就比后出现的hiddenM低。</p>\n<p>2）为什么hiddenM的两个contains组件同时开始变换？（此处是因为我最早使用两个hiddenM两个contains，在顺序的语句下切换也是同时才发出的疑问）</p>\n<p>现在看了，应该就是contains语法糖的即时性在起作用，不会等待子组件语句的顺序，而是同时执行。</p>\n<h2 id=\"3-关于其他问题的畅想\"><a href=\"#3-关于其他问题的畅想\" class=\"headerlink\" title=\"3.关于其他问题的畅想\"></a>3.关于其他问题的畅想</h2><p>也许以上此种也能解决</p>\n<p>4号问题-立绘平移：可以在label之后的show语句下面加warper函数让立绘移动</p>\n<p>5号问题-画面黑白的剩余：使用warper函数将变灰的过程显示出来（这个存疑，因为线性变换不一定有过程）</p>\n<p>8号问题-立绘渐入渐出时的动效：创建一个ALT叫做apper，包括淡入和变换两个动画效果，然后放在所有的名字下面</p>\n<p>10号问题-场景拉动特效：做一个较为复杂的曲线，拉动场景（也可以用之前那个默认函数hpunch）</p>\n"},{"title":"算法02：两数相加问题","date":"2022-03-04T01:20:15.000Z","copyright":false,"cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052140772.webp","_content":"# 两数相加问题\n\n## 1.涉及知识-链表ListNode\n\n## 2.具体题目\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n## 3.实现代码\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n## 4.思路\n\n因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。\n\nJava中链表的实现是以最小单位节点为元素，整合出来的，代码如下。\n\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    public int Listlength() {\n        int length = 0;\n        ListNode sth=this;\n        while (sth != null) {\n            sth = this.next;\n            length++;\n        }\n        return length;\n    }\n}\n```\n\n顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。\n\n","source":"_posts/算法02.两数相加问题.md","raw":"---\ntitle: 算法02：两数相加问题\ndate: 2022-03-04 09:20:15\ncategories:\n  - [技术,算法]\ntags: \n  - Java\n  - 算法\ncopyright: false\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203052140772.webp\"\n---\n# 两数相加问题\n\n## 1.涉及知识-链表ListNode\n\n## 2.具体题目\n\n给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n## 3.实现代码\n\n```java\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode head = null, tail = null;\n        int carry = 0;\n        while (l1 != null || l2 != null) {\n            int n1 = l1 != null ? l1.val : 0;\n            int n2 = l2 != null ? l2.val : 0;\n            int sum = n1 + n2 + carry;\n            if (head == null) {\n                head = tail = new ListNode(sum % 10);\n            } else {\n                tail.next = new ListNode(sum % 10);\n                tail = tail.next;\n            }\n            carry = sum / 10;\n            if (l1 != null) {\n                l1 = l1.next;\n            }\n            if (l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if (carry > 0) {\n            tail.next = new ListNode(carry);\n        }\n        return head;\n    }\n}\n```\n\n## 4.思路\n\n因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。\n\nJava中链表的实现是以最小单位节点为元素，整合出来的，代码如下。\n\n```\npublic class ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n\n    public int Listlength() {\n        int length = 0;\n        ListNode sth=this;\n        while (sth != null) {\n            sth = this.next;\n            length++;\n        }\n        return length;\n    }\n}\n```\n\n顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。\n\n","slug":"算法02.两数相加问题","published":1,"updated":"2022-03-07T08:46:27.653Z","_id":"cl0ggla2a000oq8uha9bm8b8d","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"两数相加问题\"><a href=\"#两数相加问题\" class=\"headerlink\" title=\"两数相加问题\"></a>两数相加问题</h1><h2 id=\"1-涉及知识-链表ListNode\"><a href=\"#1-涉及知识-链表ListNode\" class=\"headerlink\" title=\"1.涉及知识-链表ListNode\"></a>1.涉及知识-链表ListNode</h2><h2 id=\"2-具体题目\"><a href=\"#2-具体题目\" class=\"headerlink\" title=\"2.具体题目\"></a>2.具体题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<h2 id=\"3-实现代码\"><a href=\"#3-实现代码\" class=\"headerlink\" title=\"3.实现代码\"></a>3.实现代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>, tail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">carry</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">null</span> || l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> l1 != <span class=\"literal\">null</span> ? l1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> l2 != <span class=\"literal\">null</span> ? l2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> n1 + n2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                head = tail = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">                tail = tail.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-思路\"><a href=\"#4-思路\" class=\"headerlink\" title=\"4.思路\"></a>4.思路</h2><p>因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。</p>\n<p>Java中链表的实现是以最小单位节点为元素，整合出来的，代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ListNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val, ListNode next) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Listlength() &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode sth=this;</span><br><span class=\"line\">        while (sth != null) &#123;</span><br><span class=\"line\">            sth = this.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"两数相加问题\"><a href=\"#两数相加问题\" class=\"headerlink\" title=\"两数相加问题\"></a>两数相加问题</h1><h2 id=\"1-涉及知识-链表ListNode\"><a href=\"#1-涉及知识-链表ListNode\" class=\"headerlink\" title=\"1.涉及知识-链表ListNode\"></a>1.涉及知识-链表ListNode</h2><h2 id=\"2-具体题目\"><a href=\"#2-具体题目\" class=\"headerlink\" title=\"2.具体题目\"></a>2.具体题目</h2><p>给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<h2 id=\"3-实现代码\"><a href=\"#3-实现代码\" class=\"headerlink\" title=\"3.实现代码\"></a>3.实现代码</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Solution</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> ListNode <span class=\"title function_\">addTwoNumbers</span><span class=\"params\">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">ListNode</span> <span class=\"variable\">head</span> <span class=\"operator\">=</span> <span class=\"literal\">null</span>, tail = <span class=\"literal\">null</span>;</span><br><span class=\"line\">        <span class=\"type\">int</span> <span class=\"variable\">carry</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (l1 != <span class=\"literal\">null</span> || l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n1</span> <span class=\"operator\">=</span> l1 != <span class=\"literal\">null</span> ? l1.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">n2</span> <span class=\"operator\">=</span> l2 != <span class=\"literal\">null</span> ? l2.val : <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">sum</span> <span class=\"operator\">=</span> n1 + n2 + carry;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (head == <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                head = tail = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(sum % <span class=\"number\">10</span>);</span><br><span class=\"line\">                tail = tail.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            carry = sum / <span class=\"number\">10</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l1 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l1 = l1.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (l2 != <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">                l2 = l2.next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (carry &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            tail.next = <span class=\"keyword\">new</span> <span class=\"title class_\">ListNode</span>(carry);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> head;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"4-思路\"><a href=\"#4-思路\" class=\"headerlink\" title=\"4.思路\"></a>4.思路</h2><p>因为链表逆序存储，所以每一位相加自然可以得出最终结果，难点在于Java之中ListNode的数据结构实现和使用方法。</p>\n<p>Java中链表的实现是以最小单位节点为元素，整合出来的，代码如下。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class ListNode &#123;</span><br><span class=\"line\">    int val;</span><br><span class=\"line\">    ListNode next;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode() &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    ListNode(int val, ListNode next) &#123;</span><br><span class=\"line\">        this.val = val;</span><br><span class=\"line\">        this.next = next;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    public int Listlength() &#123;</span><br><span class=\"line\">        int length = 0;</span><br><span class=\"line\">        ListNode sth=this;</span><br><span class=\"line\">        while (sth != null) &#123;</span><br><span class=\"line\">            sth = this.next;</span><br><span class=\"line\">            length++;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return length;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>顺便一提，Listlength是我增加的一个链表长度的参数，当他使用起来的时候可以直接调用实例的方法：例如ListNode.Listlength。</p>\n"},{"title":"算法01：两数之和问题","date":"2022-03-04T01:20:15.000Z","copyright":false,"cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040924920.jpg","_content":"\n# 1.两数之和问题\n\n![两数之和问题](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png)\n\n## 解题方法\n\n```java\npublic class SumInTwoNum {\n    public int[] twoSum(int[] nums, int target) {//[2,7,11,15]\n        int[] result = new int[0];\n        for (int n = 0; n < nums.length; n++) {\n            int Vnum = target - nums[n];\n            for (int i = 0; i < nums.length; i++) {\n                if (Vnum == nums[i]) {\n                    result = new int[]{n, i};\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3,3};\n        SumInTwoNum test = new SumInTwoNum();\n        int[] result = test.twoSum(nums, 6);\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(result[i]);\n        }\n    }\n}\n```\n\n## 思路\n\n先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。\n\n## 实现过程中遇到的问题\n\n### 1.数组在主函数的输出\n\nint类型数组无法直接输出，需要一个循环结构。\n\n### 2.数组内容的写入\n\n仅支持用新数组制作复写，如result = new int[]{n, i};\n\n但是好处是这样就可以将数据传递出去了（虽然原因未知。\n\n### 3.循环结构的不停导致数组的覆写\n\n使用break；结束这一层嵌套的循环。\n\n## 官方解答\n\n### 方法一：暴力枚举\n\n思路及算法\n\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n代码\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n空间复杂度：O(1)O(1)。\n\n### 方法二：哈希表\n\n思路及算法\n\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。\n\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。\n\n空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。\n","source":"_posts/算法01.两数之和问题.md","raw":"---\ntitle: 算法01：两数之和问题\ndate: 2022-03-04 09:20:15\ncategories:\n  - [技术,算法]\ntags: \n  - Java\n  - 算法\ncopyright: false\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040924920.jpg\"\n---\n\n# 1.两数之和问题\n\n![两数之和问题](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png)\n\n## 解题方法\n\n```java\npublic class SumInTwoNum {\n    public int[] twoSum(int[] nums, int target) {//[2,7,11,15]\n        int[] result = new int[0];\n        for (int n = 0; n < nums.length; n++) {\n            int Vnum = target - nums[n];\n            for (int i = 0; i < nums.length; i++) {\n                if (Vnum == nums[i]) {\n                    result = new int[]{n, i};\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    public static void main(String[] args) {\n        int[] nums = {3,3};\n        SumInTwoNum test = new SumInTwoNum();\n        int[] result = test.twoSum(nums, 6);\n        for (int i = 0; i < result.length; i++) {\n            System.out.print(result[i]);\n        }\n    }\n}\n```\n\n## 思路\n\n先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。\n\n## 实现过程中遇到的问题\n\n### 1.数组在主函数的输出\n\nint类型数组无法直接输出，需要一个循环结构。\n\n### 2.数组内容的写入\n\n仅支持用新数组制作复写，如result = new int[]{n, i};\n\n但是好处是这样就可以将数据传递出去了（虽然原因未知。\n\n### 3.循环结构的不停导致数组的覆写\n\n使用break；结束这一层嵌套的循环。\n\n## 官方解答\n\n### 方法一：暴力枚举\n\n思路及算法\n\n最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。\n\n当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。\n\n代码\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (nums[i] + nums[j] == target) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。\n\n空间复杂度：O(1)O(1)。\n\n### 方法二：哈希表\n\n思路及算法\n\n注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。\n\n使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。\n\n这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。\n\n```\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();\n        for (int i = 0; i < nums.length; ++i) {\n            if (hashtable.containsKey(target - nums[i])) {\n                return new int[]{hashtable.get(target - nums[i]), i};\n            }\n            hashtable.put(nums[i], i);\n        }\n        return new int[0];\n    }\n}\n```\n\n复杂度分析\n\n时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。\n\n空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。\n","slug":"算法01.两数之和问题","published":1,"updated":"2022-03-07T08:46:56.030Z","_id":"cl0ggm3rc000tq8uh1lj59ho1","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"1-两数之和问题\"><a href=\"#1-两数之和问题\" class=\"headerlink\" title=\"1.两数之和问题\"></a>1.两数之和问题</h1><p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png\" alt=\"两数之和问题\"></p>\n<h2 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SumInTwoNum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;<span class=\"comment\">//[2,7,11,15]</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; n &lt; nums.length; n++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">Vnum</span> <span class=\"operator\">=</span> target - nums[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Vnum == nums[i]) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n, i&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">SumInTwoNum</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SumInTwoNum</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = test.twoSum(nums, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(result[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。</p>\n<h2 id=\"实现过程中遇到的问题\"><a href=\"#实现过程中遇到的问题\" class=\"headerlink\" title=\"实现过程中遇到的问题\"></a>实现过程中遇到的问题</h2><h3 id=\"1-数组在主函数的输出\"><a href=\"#1-数组在主函数的输出\" class=\"headerlink\" title=\"1.数组在主函数的输出\"></a>1.数组在主函数的输出</h3><p>int类型数组无法直接输出，需要一个循环结构。</p>\n<h3 id=\"2-数组内容的写入\"><a href=\"#2-数组内容的写入\" class=\"headerlink\" title=\"2.数组内容的写入\"></a>2.数组内容的写入</h3><p>仅支持用新数组制作复写，如result = new int[]{n, i};</p>\n<p>但是好处是这样就可以将数据传递出去了（虽然原因未知。</p>\n<h3 id=\"3-循环结构的不停导致数组的覆写\"><a href=\"#3-循环结构的不停导致数组的覆写\" class=\"headerlink\" title=\"3.循环结构的不停导致数组的覆写\"></a>3.循环结构的不停导致数组的覆写</h3><p>使用break；结束这一层嵌套的循环。</p>\n<h2 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h2><h3 id=\"方法一：暴力枚举\"><a href=\"#方法一：暴力枚举\" class=\"headerlink\" title=\"方法一：暴力枚举\"></a>方法一：暴力枚举</h3><p>思路及算法</p>\n<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p>\n<p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>\n<p>代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                if (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    return new int[]&#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p>\n<p>空间复杂度：O(1)O(1)。</p>\n<h3 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h3><p>思路及算法</p>\n<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>\n<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p>\n<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashtable.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。</p>\n<p>空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1-两数之和问题\"><a href=\"#1-两数之和问题\" class=\"headerlink\" title=\"1.两数之和问题\"></a>1.两数之和问题</h1><p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203040918365.png\" alt=\"两数之和问题\"></p>\n<h2 id=\"解题方法\"><a href=\"#解题方法\" class=\"headerlink\" title=\"解题方法\"></a>解题方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title class_\">SumInTwoNum</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"type\">int</span>[] twoSum(<span class=\"type\">int</span>[] nums, <span class=\"type\">int</span> target) &#123;<span class=\"comment\">//[2,7,11,15]</span></span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">n</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; n &lt; nums.length; n++) &#123;</span><br><span class=\"line\">            <span class=\"type\">int</span> <span class=\"variable\">Vnum</span> <span class=\"operator\">=</span> target - nums[n];</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (Vnum == nums[i]) &#123;</span><br><span class=\"line\">                    result = <span class=\"keyword\">new</span> <span class=\"title class_\">int</span>[]&#123;n, i&#125;;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title function_\">main</span><span class=\"params\">(String[] args)</span> &#123;</span><br><span class=\"line\">        <span class=\"type\">int</span>[] nums = &#123;<span class=\"number\">3</span>,<span class=\"number\">3</span>&#125;;</span><br><span class=\"line\">        <span class=\"type\">SumInTwoNum</span> <span class=\"variable\">test</span> <span class=\"operator\">=</span> <span class=\"keyword\">new</span> <span class=\"title class_\">SumInTwoNum</span>();</span><br><span class=\"line\">        <span class=\"type\">int</span>[] result = test.twoSum(nums, <span class=\"number\">6</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"type\">int</span> <span class=\"variable\">i</span> <span class=\"operator\">=</span> <span class=\"number\">0</span>; i &lt; result.length; i++) &#123;</span><br><span class=\"line\">            System.out.print(result[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"思路\"><a href=\"#思路\" class=\"headerlink\" title=\"思路\"></a>思路</h2><p>先确定靶子的余数（即弓），再遍历数组寻找箭。先用实例来得到框架，再将循环的变量填入进去。复杂度为O(n²)。</p>\n<h2 id=\"实现过程中遇到的问题\"><a href=\"#实现过程中遇到的问题\" class=\"headerlink\" title=\"实现过程中遇到的问题\"></a>实现过程中遇到的问题</h2><h3 id=\"1-数组在主函数的输出\"><a href=\"#1-数组在主函数的输出\" class=\"headerlink\" title=\"1.数组在主函数的输出\"></a>1.数组在主函数的输出</h3><p>int类型数组无法直接输出，需要一个循环结构。</p>\n<h3 id=\"2-数组内容的写入\"><a href=\"#2-数组内容的写入\" class=\"headerlink\" title=\"2.数组内容的写入\"></a>2.数组内容的写入</h3><p>仅支持用新数组制作复写，如result = new int[]{n, i};</p>\n<p>但是好处是这样就可以将数据传递出去了（虽然原因未知。</p>\n<h3 id=\"3-循环结构的不停导致数组的覆写\"><a href=\"#3-循环结构的不停导致数组的覆写\" class=\"headerlink\" title=\"3.循环结构的不停导致数组的覆写\"></a>3.循环结构的不停导致数组的覆写</h3><p>使用break；结束这一层嵌套的循环。</p>\n<h2 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h2><h3 id=\"方法一：暴力枚举\"><a href=\"#方法一：暴力枚举\" class=\"headerlink\" title=\"方法一：暴力枚举\"></a>方法一：暴力枚举</h3><p>思路及算法</p>\n<p>最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。</p>\n<p>当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。</p>\n<p>代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        int n = nums.length;</span><br><span class=\"line\">        for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class=\"line\">            for (int j = i + 1; j &lt; n; ++j) &#123;</span><br><span class=\"line\">                if (nums[i] + nums[j] == target) &#123;</span><br><span class=\"line\">                    return new int[]&#123;i, j&#125;;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N^2)，其中 NN 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。</p>\n<p>空间复杂度：O(1)O(1)。</p>\n<h3 id=\"方法二：哈希表\"><a href=\"#方法二：哈希表\" class=\"headerlink\" title=\"方法二：哈希表\"></a>方法二：哈希表</h3><p>思路及算法</p>\n<p>注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。</p>\n<p>使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)O(N) 降低到 O(1)O(1)。</p>\n<p>这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Solution &#123;</span><br><span class=\"line\">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class=\"line\">        Map&lt;Integer, Integer&gt; hashtable = new HashMap&lt;Integer, Integer&gt;();</span><br><span class=\"line\">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class=\"line\">            if (hashtable.containsKey(target - nums[i])) &#123;</span><br><span class=\"line\">                return new int[]&#123;hashtable.get(target - nums[i]), i&#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            hashtable.put(nums[i], i);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return new int[0];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>复杂度分析</p>\n<p>时间复杂度：O(N)，其中 NN 是数组中的元素数量。对于每一个元素 x，我们可以 O(1)O(1) 地寻找 target - x。</p>\n<p>空间复杂度：O(N)，其中 NN 是数组中的元素数量。主要为哈希表的开销。</p>\n"},{"title":"JavaScript：作用域和作用域链","copyright":false,"date":"2022-03-07T09:42:00.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071744155.webp","_content":"\n# 作用域和作用域链\n\n在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）\n\n## 一、全局作用域\n\n拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:\n\n1.最外层的函数以及最外层变量:\n\n```javascript\nvar globleVariable= 'global';  // 最外层变量\nfunction globalFunc(){         // 最外层函数\n    var childVariable = 'global_child';  //函数内变量\n    function childFunc(){        // 内层函数\n        console.log(childVariable);\n    }\n    console.log(globleVariable)\n}\nconsole.log(globleVariable);  // global\nglobalFunc();                 // global\nconsole.log(childVariable)   // childVariable is not defined\nconsole.log(childFunc)       // childFunc is not defined\n```\n\n2.未定义直接赋值的变量:\n\n```\nfunction func1(){\n    special = 'special_variable';\n    var normal = 'normal_variable';\n}\nfunc1();\nconsole.log(special);    //special_variable\nconsole.log(normal)     // normal is not defined\n```\n\n由于变量提升使没有定义的变量成为全局变量。\n\n然而，即使是定义也存在问题，因为var存在变量覆盖的特性。\n\n## 二、局部作用域\n\n局部作用域一般只能在固定代码片段内可以访问到。最常见的就是**函数作用域**。\n\n### 函数作用域\n\n```\nfunction test(){\n    var num = 9;\n    // 内部可以访问\n    console.log(\"test中：\"+num);\n}\n//test外部不能访问\nconsole.log(\"test外部:\"+num);\n```\n\n![image-20220307171137786](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png)\n\n## 三、块级作用域\n\nES6新增了`let`和`const`命令，可以用来创建块级作用域变量，使用`let`命令声明的变量只在`let`命令所在`代码块`内有效。\n\nlet 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：\n\n- 变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量\n\n- 不允许反复声明\n\n## 四、作用域链\n\n### JavaScript执行原理\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析\n\n- 分析函数参数\n- 分析变量声明\n- 分析函数声明\n\n分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个`AO(Active Object 活动对象)`\n\n分析阶段分析成功后，会把给`AO(Active Object 活动对象)`给执行阶段\n\n- 引擎询问作用域，作用域中是否有这个叫X的变量\n\n- 如果作用域有X变量，引擎会使用这个变量\n\n- 如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。\n\n  \n\n这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。\n\nJavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。\n\n### 什么是作用域链\n\n作用域链是一个独特空间。当一个变量被调用，那么变量在 **被调用** 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。\n\n```\n// 定义一个全局作用域变量：\nconst fullName = \"Oluwatobi Sofela\";\n\n// 定义多层嵌套函数:\nfunction profile() {\n  function sayName() {\n    function writeName() {\n      return fullName;\n    }\n    return writeName();\n  }\n  return sayName();\n}\n\nconsole.log(profile()) // 'Oluwatobi Sofela'\n```\n\n在上述示例中，`fullName` 变量在 `writeName()` 函数作用域中被调用。\n\n因此，从变量的执行作用域到全局作用域之间存在如下作用域链：\n\n**writeName() scope ---> sayName() scope ---> profile() scope ---> global scope**\n\n换言之，从`fullName`变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。\n\n**注意：** 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。\n","source":"_posts/JavaScript：作用域和作用域链.md","raw":"---\ntitle: JavaScript：作用域和作用域链\ncopyright: false\ndate: 2022-03-07 17:42:00\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071744155.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\n# 作用域和作用域链\n\n在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）\n\n## 一、全局作用域\n\n拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:\n\n1.最外层的函数以及最外层变量:\n\n```javascript\nvar globleVariable= 'global';  // 最外层变量\nfunction globalFunc(){         // 最外层函数\n    var childVariable = 'global_child';  //函数内变量\n    function childFunc(){        // 内层函数\n        console.log(childVariable);\n    }\n    console.log(globleVariable)\n}\nconsole.log(globleVariable);  // global\nglobalFunc();                 // global\nconsole.log(childVariable)   // childVariable is not defined\nconsole.log(childFunc)       // childFunc is not defined\n```\n\n2.未定义直接赋值的变量:\n\n```\nfunction func1(){\n    special = 'special_variable';\n    var normal = 'normal_variable';\n}\nfunc1();\nconsole.log(special);    //special_variable\nconsole.log(normal)     // normal is not defined\n```\n\n由于变量提升使没有定义的变量成为全局变量。\n\n然而，即使是定义也存在问题，因为var存在变量覆盖的特性。\n\n## 二、局部作用域\n\n局部作用域一般只能在固定代码片段内可以访问到。最常见的就是**函数作用域**。\n\n### 函数作用域\n\n```\nfunction test(){\n    var num = 9;\n    // 内部可以访问\n    console.log(\"test中：\"+num);\n}\n//test外部不能访问\nconsole.log(\"test外部:\"+num);\n```\n\n![image-20220307171137786](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png)\n\n## 三、块级作用域\n\nES6新增了`let`和`const`命令，可以用来创建块级作用域变量，使用`let`命令声明的变量只在`let`命令所在`代码块`内有效。\n\nlet 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：\n\n- 变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量\n\n- 不允许反复声明\n\n## 四、作用域链\n\n### JavaScript执行原理\n\n![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析\n\n- 分析函数参数\n- 分析变量声明\n- 分析函数声明\n\n分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个`AO(Active Object 活动对象)`\n\n分析阶段分析成功后，会把给`AO(Active Object 活动对象)`给执行阶段\n\n- 引擎询问作用域，作用域中是否有这个叫X的变量\n\n- 如果作用域有X变量，引擎会使用这个变量\n\n- 如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。\n\n  \n\n这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。\n\nJavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。\n\n### 什么是作用域链\n\n作用域链是一个独特空间。当一个变量被调用，那么变量在 **被调用** 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。\n\n```\n// 定义一个全局作用域变量：\nconst fullName = \"Oluwatobi Sofela\";\n\n// 定义多层嵌套函数:\nfunction profile() {\n  function sayName() {\n    function writeName() {\n      return fullName;\n    }\n    return writeName();\n  }\n  return sayName();\n}\n\nconsole.log(profile()) // 'Oluwatobi Sofela'\n```\n\n在上述示例中，`fullName` 变量在 `writeName()` 函数作用域中被调用。\n\n因此，从变量的执行作用域到全局作用域之间存在如下作用域链：\n\n**writeName() scope ---> sayName() scope ---> profile() scope ---> global scope**\n\n换言之，从`fullName`变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。\n\n**注意：** 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。\n","slug":"JavaScript：作用域和作用域链","published":1,"updated":"2022-03-07T13:26:19.426Z","_id":"cl0gil2no000yq8uh3dge9jq3","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h1><p>在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）</p>\n<h2 id=\"一、全局作用域\"><a href=\"#一、全局作用域\" class=\"headerlink\" title=\"一、全局作用域\"></a>一、全局作用域</h2><p>拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:</p>\n<p>1.最外层的函数以及最外层变量:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globleVariable= <span class=\"string\">&#x27;global&#x27;</span>;  <span class=\"comment\">// 最外层变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">globalFunc</span>(<span class=\"params\"></span>)&#123;         <span class=\"comment\">// 最外层函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> childVariable = <span class=\"string\">&#x27;global_child&#x27;</span>;  <span class=\"comment\">//函数内变量</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">childFunc</span>(<span class=\"params\"></span>)&#123;        <span class=\"comment\">// 内层函数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable);  <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"title function_\">globalFunc</span>();                 <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable)   <span class=\"comment\">// childVariable is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childFunc)       <span class=\"comment\">// childFunc is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>2.未定义直接赋值的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function func1()&#123;</span><br><span class=\"line\">    special = &#x27;special_variable&#x27;;</span><br><span class=\"line\">    var normal = &#x27;normal_variable&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\">console.log(special);    //special_variable</span><br><span class=\"line\">console.log(normal)     // normal is not defined</span><br></pre></td></tr></table></figure>\n\n<p>由于变量提升使没有定义的变量成为全局变量。</p>\n<p>然而，即使是定义也存在问题，因为var存在变量覆盖的特性。</p>\n<h2 id=\"二、局部作用域\"><a href=\"#二、局部作用域\" class=\"headerlink\" title=\"二、局部作用域\"></a>二、局部作用域</h2><p>局部作用域一般只能在固定代码片段内可以访问到。最常见的就是<strong>函数作用域</strong>。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    var num = 9;</span><br><span class=\"line\">    // 内部可以访问</span><br><span class=\"line\">    console.log(&quot;test中：&quot;+num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//test外部不能访问</span><br><span class=\"line\">console.log(&quot;test外部:&quot;+num);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png\" alt=\"image-20220307171137786\"></p>\n<h2 id=\"三、块级作用域\"><a href=\"#三、块级作用域\" class=\"headerlink\" title=\"三、块级作用域\"></a>三、块级作用域</h2><p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建块级作用域变量，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<code>代码块</code>内有效。</p>\n<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>\n<ul>\n<li><p>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</p>\n</li>\n<li><p>不允许反复声明</p>\n</li>\n</ul>\n<h2 id=\"四、作用域链\"><a href=\"#四、作用域链\" class=\"headerlink\" title=\"四、作用域链\"></a>四、作用域链</h2><h3 id=\"JavaScript执行原理\"><a href=\"#JavaScript执行原理\" class=\"headerlink\" title=\"JavaScript执行原理\"></a>JavaScript执行原理</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析</p>\n<ul>\n<li>分析函数参数</li>\n<li>分析变量声明</li>\n<li>分析函数声明</li>\n</ul>\n<p>分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个<code>AO(Active Object 活动对象)</code></p>\n<p>分析阶段分析成功后，会把给<code>AO(Active Object 活动对象)</code>给执行阶段</p>\n<ul>\n<li><p>引擎询问作用域，作用域中是否有这个叫X的变量</p>\n</li>\n<li><p>如果作用域有X变量，引擎会使用这个变量</p>\n</li>\n<li><p>如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。</p>\n</li>\n</ul>\n<p>这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。</p>\n<p>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。</p>\n<h3 id=\"什么是作用域链\"><a href=\"#什么是作用域链\" class=\"headerlink\" title=\"什么是作用域链\"></a>什么是作用域链</h3><p>作用域链是一个独特空间。当一个变量被调用，那么变量在 <strong>被调用</strong> 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局作用域变量：</span><br><span class=\"line\">const fullName = &quot;Oluwatobi Sofela&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义多层嵌套函数:</span><br><span class=\"line\">function profile() &#123;</span><br><span class=\"line\">  function sayName() &#123;</span><br><span class=\"line\">    function writeName() &#123;</span><br><span class=\"line\">      return fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return writeName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sayName();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(profile()) // &#x27;Oluwatobi Sofela&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，<code>fullName</code> 变量在 <code>writeName()</code> 函数作用域中被调用。</p>\n<p>因此，从变量的执行作用域到全局作用域之间存在如下作用域链：</p>\n<p><strong>writeName() scope —&gt; sayName() scope —&gt; profile() scope —&gt; global scope</strong></p>\n<p>换言之，从<code>fullName</code>变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。</p>\n<p><strong>注意：</strong> 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"作用域和作用域链\"><a href=\"#作用域和作用域链\" class=\"headerlink\" title=\"作用域和作用域链\"></a>作用域和作用域链</h1><p>在ES5中，作用域仅分为局部作用域（local Scope）和全局作用域（global Scope），在ES6中则通过let和const构建了块级作用域（一种特殊的局部作用域）</p>\n<h2 id=\"一、全局作用域\"><a href=\"#一、全局作用域\" class=\"headerlink\" title=\"一、全局作用域\"></a>一、全局作用域</h2><p>拥有全局作用域的对象可以在代码的任何地方访问到, 在js中一般有以下几种情形拥有全局作用域:</p>\n<p>1.最外层的函数以及最外层变量:</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> globleVariable= <span class=\"string\">&#x27;global&#x27;</span>;  <span class=\"comment\">// 最外层变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">globalFunc</span>(<span class=\"params\"></span>)&#123;         <span class=\"comment\">// 最外层函数</span></span><br><span class=\"line\">    <span class=\"keyword\">var</span> childVariable = <span class=\"string\">&#x27;global_child&#x27;</span>;  <span class=\"comment\">//函数内变量</span></span><br><span class=\"line\">    <span class=\"keyword\">function</span> <span class=\"title function_\">childFunc</span>(<span class=\"params\"></span>)&#123;        <span class=\"comment\">// 内层函数</span></span><br><span class=\"line\">        <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(globleVariable);  <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"title function_\">globalFunc</span>();                 <span class=\"comment\">// global</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childVariable)   <span class=\"comment\">// childVariable is not defined</span></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(childFunc)       <span class=\"comment\">// childFunc is not defined</span></span><br></pre></td></tr></table></figure>\n\n<p>2.未定义直接赋值的变量:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function func1()&#123;</span><br><span class=\"line\">    special = &#x27;special_variable&#x27;;</span><br><span class=\"line\">    var normal = &#x27;normal_variable&#x27;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">func1();</span><br><span class=\"line\">console.log(special);    //special_variable</span><br><span class=\"line\">console.log(normal)     // normal is not defined</span><br></pre></td></tr></table></figure>\n\n<p>由于变量提升使没有定义的变量成为全局变量。</p>\n<p>然而，即使是定义也存在问题，因为var存在变量覆盖的特性。</p>\n<h2 id=\"二、局部作用域\"><a href=\"#二、局部作用域\" class=\"headerlink\" title=\"二、局部作用域\"></a>二、局部作用域</h2><p>局部作用域一般只能在固定代码片段内可以访问到。最常见的就是<strong>函数作用域</strong>。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test()&#123;</span><br><span class=\"line\">    var num = 9;</span><br><span class=\"line\">    // 内部可以访问</span><br><span class=\"line\">    console.log(&quot;test中：&quot;+num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//test外部不能访问</span><br><span class=\"line\">console.log(&quot;test外部:&quot;+num);</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071711834.png\" alt=\"image-20220307171137786\"></p>\n<h2 id=\"三、块级作用域\"><a href=\"#三、块级作用域\" class=\"headerlink\" title=\"三、块级作用域\"></a>三、块级作用域</h2><p>ES6新增了<code>let</code>和<code>const</code>命令，可以用来创建块级作用域变量，使用<code>let</code>命令声明的变量只在<code>let</code>命令所在<code>代码块</code>内有效。</p>\n<p>let 声明的语法与 var 的语法一致。你基本上可以用 let 来代替 var 进行变量声明，但会将变量的作用域限制在当前代码块中。块级作用域有以下几个特点：</p>\n<ul>\n<li><p>变量不会提升到代码块顶部且不允许从外部访问块级作用域内部变量</p>\n</li>\n<li><p>不允许反复声明</p>\n</li>\n</ul>\n<h2 id=\"四、作用域链\"><a href=\"#四、作用域链\" class=\"headerlink\" title=\"四、作用域链\"></a>四、作用域链</h2><h3 id=\"JavaScript执行原理\"><a href=\"#JavaScript执行原理\" class=\"headerlink\" title=\"JavaScript执行原理\"></a>JavaScript执行原理</h3><p><img src=\"https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/6/27/16b94c342168e6da~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"img\"></p>\n<p>在了解作用域前，先要理解js是如何执行的。它的执行分为两个阶段：分析阶段和执行阶段，javascript编译器编译完成，生成代码后进行分析</p>\n<ul>\n<li>分析函数参数</li>\n<li>分析变量声明</li>\n<li>分析函数声明</li>\n</ul>\n<p>分析阶段的核心，在分析完成后（也就是接下来函数执行阶段的瞬间）会创建一个<code>AO(Active Object 活动对象)</code></p>\n<p>分析阶段分析成功后，会把给<code>AO(Active Object 活动对象)</code>给执行阶段</p>\n<ul>\n<li><p>引擎询问作用域，作用域中是否有这个叫X的变量</p>\n</li>\n<li><p>如果作用域有X变量，引擎会使用这个变量</p>\n</li>\n<li><p>如果作用域中没有，引擎会继续寻找（向上层作用域），如果到了最后都没有找到这个变量，引擎会抛出错误。</p>\n</li>\n</ul>\n<p>这里还涉及到LHS和RHS（左右查找），此处不做深入讨论。</p>\n<p>JavaScript上每一个函数执行时，会先在自己创建的AO上找对应属性值。若找不到则往父函数的AO上找，再找不到则再上一层的AO,直到找到window（全局作用域）。 而这一条形成的“AO链” 就是JavaScript中的作用域链。</p>\n<h3 id=\"什么是作用域链\"><a href=\"#什么是作用域链\" class=\"headerlink\" title=\"什么是作用域链\"></a>什么是作用域链</h3><p>作用域链是一个独特空间。当一个变量被调用，那么变量在 <strong>被调用</strong> 时所在的局部作用域和全局作用域之间，就形成了一个作用域链。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 定义一个全局作用域变量：</span><br><span class=\"line\">const fullName = &quot;Oluwatobi Sofela&quot;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 定义多层嵌套函数:</span><br><span class=\"line\">function profile() &#123;</span><br><span class=\"line\">  function sayName() &#123;</span><br><span class=\"line\">    function writeName() &#123;</span><br><span class=\"line\">      return fullName;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return writeName();</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  return sayName();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(profile()) // &#x27;Oluwatobi Sofela&#x27;</span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，<code>fullName</code> 变量在 <code>writeName()</code> 函数作用域中被调用。</p>\n<p>因此，从变量的执行作用域到全局作用域之间存在如下作用域链：</p>\n<p><strong>writeName() scope —&gt; sayName() scope —&gt; profile() scope —&gt; global scope</strong></p>\n<p>换言之，从<code>fullName</code>变量的执行作用域到它的词法作用域（此处指全局作用域）之间有4层作用域。</p>\n<p><strong>注意：</strong> 在 JavaScript作用域链中，全局作用域是整个作用域链的终点。</p>\n"},{"title":"JavaScript：闭包（Closure）的原理和目的","copyright":false,"date":"2022-03-07T12:07:56.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072010147.webp","_content":"\n# JavaScript：闭包（Closure）的原理和目的\n\n## 词法作用域\n\n**词法作用域**（`Lexical Scopes`）是 `javascript` 中使用的作用域类型，**词法作用域** 也可以被叫做 **静态作用域**，与之相对的还有 **动态作用域**。那么 `javascript` 使用的 **词法作用域** 和 **动态作用域** 的区别是什么呢？看下面这段代码：\n\n```\nvar value = 1;\n\nfunction foo() {\n  console.log(value);\n}\n\nfunction bar() {\n  var value = 2;\n  foo();\n}\n\nbar();\n```\n\n![image-20220307194155261](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png)\n\n上面这段代码中，一共有三个作用域：\n\n- 全局作用域\n- `foo` 的函数作用域\n- `bar` 的函数作用域\n\n一直到这边都好理解，可是 `foo` 里访问了本地作用域中没有的变量 `value` 。根据前面说的，引擎为了拿到这个变量就要去 `foo` 的上层作用域查询，那么 `foo` 的上层作用域是什么呢？是它 **调用时** 所在的 bar 作用域？还是它 **定义时** 所在的全局作用域？\n\n这个关键的问题就是 `javascript` 中的作用域类型——**词法作用域。**\n\n> 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。\n\n**词法作用域（Lexical Scope）** 是定义表达式并能被访问的区间。\n\n换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。\n\n**注意：**\n\n- 词法作用域又叫静态作用域。\n- 一个声明 **被调用时的作用域** 不一定是它的词法作用域。相反的，**定义时的作用域** 才是词法作用域\n\n### 一个词法作用域的小示例\n\n考虑如下代码：\n\n```js\n// 定义一个全局作用域变量：\nconst myName = \"Oluwatobi\";\n\n// 在函数体内调用myName变量\nfunction getName() {\n  return myName;\n}\n\nconsole.log(getName()) // 'Oluwatobi'\n```\n\n在上述示例中，我们在全局作用域定义了`myName`变量，并在`getName()`函数作用域内调用了该变量。\n\n**问题：** `myName`变量的词法作用域是什么？全局作用域还是 `getName()`的局部作用域？\n\n**答案：** 切记 **词法作用域** 意味着 **定义时的作用域**，并不是**调用时的作用域** 。因此`myName`变量的词法作用域是全局作用域，因为我们在全局环境下定义了`myName`变量。\n\n**换言之，函数的作用域在它的定义的时候就已经确定了。**\n\n### 作用域[scope]与上下文[context]的相似与区别\n\ncontext指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。\n\n并且它们的创建者不同\n\n- 作用域是**词法分析**创建，静态\n- 执行上下文由**js引擎**创建，动态\n\n## 闭包\n\n一句话定义闭包，就是**能够访问其他函数内部变量的函数，被称为 *闭包***\n\n一般闭包的表现形式是：**闭包就是函数内部定义的函数，被返回了出去并在外部调用**。\n\n```\nfunction foo() {\n  var a = 2;\n\n  function bar() {\n    console.log( a );\n  }\n\n  return bar;\n}\n\nvar baz = foo();\n\nbaz(); // 这就形成了一个闭包\n```\n\n我们可以简单剖析一下上面代码的运行流程：\n\n1. 编译阶段，变量和函数被声明，作用域即被确定。\n2. 运行函数 `foo()`，此时会创建一个 `foo` 函数的执行上下文，执行上下文内部存储了 `foo` 中声明的所有变量函数信息。\n3. 函数 `foo` 运行完毕，将内部函数 `bar` 的引用赋值给外部的变量 `baz` ，此时 `baz` 指针指向的还是 `bar` ，因此哪怕它位于 `foo` 作用域之外，它还是能够获取到 `foo` 的内部变量。\n4. `baz` 在外部被执行，`baz` 的内部可执行代码 `console.log` 向作用域请求获取 `a` 变量，本地作用域没有找到，继续请求父级作用域，找到了 `foo` 中的 `a` 变量，返回给 `console.log`，打印出 `2`。\n\n闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。\n\n### 闭包的目的\n\n#### 1.延长变量存活时间\n\n在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。\n\n#### 2.创造私有作用域\n\n`javascript` 没有 `java` 中那种 `public` `private` 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。\n\n### 闭包的问题：内存泄露\n\n我们知道，`javascript` 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 `0` 的变量标记为失效变量并将之清除从而释放内存。\n\n然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。\n\n当然，造成内存泄露的原因有很多，除了闭包以外，还有 **全局变量的无意创建**。开发者的本意是想将变量作为局部变量使用，然而忘记写 `var` 导致变量被泄露到全局中。\n\n还有 `DOM` 的事件绑定，移除 `DOM` 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。\n","source":"_posts/JavaScript：闭包（Closure）的原理和目的.md","raw":"---\ntitle: JavaScript：闭包（Closure）的原理和目的\ncopyright: false\ndate: 2022-03-07 20:07:56\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072010147.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\n# JavaScript：闭包（Closure）的原理和目的\n\n## 词法作用域\n\n**词法作用域**（`Lexical Scopes`）是 `javascript` 中使用的作用域类型，**词法作用域** 也可以被叫做 **静态作用域**，与之相对的还有 **动态作用域**。那么 `javascript` 使用的 **词法作用域** 和 **动态作用域** 的区别是什么呢？看下面这段代码：\n\n```\nvar value = 1;\n\nfunction foo() {\n  console.log(value);\n}\n\nfunction bar() {\n  var value = 2;\n  foo();\n}\n\nbar();\n```\n\n![image-20220307194155261](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png)\n\n上面这段代码中，一共有三个作用域：\n\n- 全局作用域\n- `foo` 的函数作用域\n- `bar` 的函数作用域\n\n一直到这边都好理解，可是 `foo` 里访问了本地作用域中没有的变量 `value` 。根据前面说的，引擎为了拿到这个变量就要去 `foo` 的上层作用域查询，那么 `foo` 的上层作用域是什么呢？是它 **调用时** 所在的 bar 作用域？还是它 **定义时** 所在的全局作用域？\n\n这个关键的问题就是 `javascript` 中的作用域类型——**词法作用域。**\n\n> 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。\n\n**词法作用域（Lexical Scope）** 是定义表达式并能被访问的区间。\n\n换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。\n\n**注意：**\n\n- 词法作用域又叫静态作用域。\n- 一个声明 **被调用时的作用域** 不一定是它的词法作用域。相反的，**定义时的作用域** 才是词法作用域\n\n### 一个词法作用域的小示例\n\n考虑如下代码：\n\n```js\n// 定义一个全局作用域变量：\nconst myName = \"Oluwatobi\";\n\n// 在函数体内调用myName变量\nfunction getName() {\n  return myName;\n}\n\nconsole.log(getName()) // 'Oluwatobi'\n```\n\n在上述示例中，我们在全局作用域定义了`myName`变量，并在`getName()`函数作用域内调用了该变量。\n\n**问题：** `myName`变量的词法作用域是什么？全局作用域还是 `getName()`的局部作用域？\n\n**答案：** 切记 **词法作用域** 意味着 **定义时的作用域**，并不是**调用时的作用域** 。因此`myName`变量的词法作用域是全局作用域，因为我们在全局环境下定义了`myName`变量。\n\n**换言之，函数的作用域在它的定义的时候就已经确定了。**\n\n### 作用域[scope]与上下文[context]的相似与区别\n\ncontext指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。\n\n并且它们的创建者不同\n\n- 作用域是**词法分析**创建，静态\n- 执行上下文由**js引擎**创建，动态\n\n## 闭包\n\n一句话定义闭包，就是**能够访问其他函数内部变量的函数，被称为 *闭包***\n\n一般闭包的表现形式是：**闭包就是函数内部定义的函数，被返回了出去并在外部调用**。\n\n```\nfunction foo() {\n  var a = 2;\n\n  function bar() {\n    console.log( a );\n  }\n\n  return bar;\n}\n\nvar baz = foo();\n\nbaz(); // 这就形成了一个闭包\n```\n\n我们可以简单剖析一下上面代码的运行流程：\n\n1. 编译阶段，变量和函数被声明，作用域即被确定。\n2. 运行函数 `foo()`，此时会创建一个 `foo` 函数的执行上下文，执行上下文内部存储了 `foo` 中声明的所有变量函数信息。\n3. 函数 `foo` 运行完毕，将内部函数 `bar` 的引用赋值给外部的变量 `baz` ，此时 `baz` 指针指向的还是 `bar` ，因此哪怕它位于 `foo` 作用域之外，它还是能够获取到 `foo` 的内部变量。\n4. `baz` 在外部被执行，`baz` 的内部可执行代码 `console.log` 向作用域请求获取 `a` 变量，本地作用域没有找到，继续请求父级作用域，找到了 `foo` 中的 `a` 变量，返回给 `console.log`，打印出 `2`。\n\n闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。\n\n### 闭包的目的\n\n#### 1.延长变量存活时间\n\n在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。\n\n#### 2.创造私有作用域\n\n`javascript` 没有 `java` 中那种 `public` `private` 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。\n\n### 闭包的问题：内存泄露\n\n我们知道，`javascript` 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 `0` 的变量标记为失效变量并将之清除从而释放内存。\n\n然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。\n\n当然，造成内存泄露的原因有很多，除了闭包以外，还有 **全局变量的无意创建**。开发者的本意是想将变量作为局部变量使用，然而忘记写 `var` 导致变量被泄露到全局中。\n\n还有 `DOM` 的事件绑定，移除 `DOM` 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。\n","slug":"JavaScript：闭包（Closure）的原理和目的","published":1,"updated":"2022-03-07T12:10:51.722Z","_id":"cl0gnsq8w0012q8uhdenpg29t","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"JavaScript：闭包（Closure）的原理和目的\"><a href=\"#JavaScript：闭包（Closure）的原理和目的\" class=\"headerlink\" title=\"JavaScript：闭包（Closure）的原理和目的\"></a>JavaScript：闭包（Closure）的原理和目的</h1><h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p><strong>词法作用域</strong>（<code>Lexical Scopes</code>）是 <code>javascript</code> 中使用的作用域类型，<strong>词法作用域</strong> 也可以被叫做 <strong>静态作用域</strong>，与之相对的还有 <strong>动态作用域</strong>。那么 <code>javascript</code> 使用的 <strong>词法作用域</strong> 和 <strong>动态作用域</strong> 的区别是什么呢？看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  var value = 2;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png\" alt=\"image-20220307194155261\"></p>\n<p>上面这段代码中，一共有三个作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li><code>foo</code> 的函数作用域</li>\n<li><code>bar</code> 的函数作用域</li>\n</ul>\n<p>一直到这边都好理解，可是 <code>foo</code> 里访问了本地作用域中没有的变量 <code>value</code> 。根据前面说的，引擎为了拿到这个变量就要去 <code>foo</code> 的上层作用域查询，那么 <code>foo</code> 的上层作用域是什么呢？是它 <strong>调用时</strong> 所在的 bar 作用域？还是它 <strong>定义时</strong> 所在的全局作用域？</p>\n<p>这个关键的问题就是 <code>javascript</code> 中的作用域类型——<strong>词法作用域。</strong></p>\n<blockquote>\n<p>词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</p>\n</blockquote>\n<p><strong>词法作用域（Lexical Scope）</strong> 是定义表达式并能被访问的区间。</p>\n<p>换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>词法作用域又叫静态作用域。</li>\n<li>一个声明 <strong>被调用时的作用域</strong> 不一定是它的词法作用域。相反的，<strong>定义时的作用域</strong> 才是词法作用域</li>\n</ul>\n<h3 id=\"一个词法作用域的小示例\"><a href=\"#一个词法作用域的小示例\" class=\"headerlink\" title=\"一个词法作用域的小示例\"></a>一个词法作用域的小示例</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个全局作用域变量：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myName = <span class=\"string\">&quot;Oluwatobi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在函数体内调用myName变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getName</span>()) <span class=\"comment\">// &#x27;Oluwatobi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们在全局作用域定义了<code>myName</code>变量，并在<code>getName()</code>函数作用域内调用了该变量。</p>\n<p><strong>问题：</strong> <code>myName</code>变量的词法作用域是什么？全局作用域还是 <code>getName()</code>的局部作用域？</p>\n<p><strong>答案：</strong> 切记 <strong>词法作用域</strong> 意味着 <strong>定义时的作用域</strong>，并不是<strong>调用时的作用域</strong> 。因此<code>myName</code>变量的词法作用域是全局作用域，因为我们在全局环境下定义了<code>myName</code>变量。</p>\n<p><strong>换言之，函数的作用域在它的定义的时候就已经确定了。</strong></p>\n<h3 id=\"作用域-scope-与上下文-context-的相似与区别\"><a href=\"#作用域-scope-与上下文-context-的相似与区别\" class=\"headerlink\" title=\"作用域[scope]与上下文[context]的相似与区别\"></a>作用域[scope]与上下文[context]的相似与区别</h3><p>context指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。</p>\n<p>并且它们的创建者不同</p>\n<ul>\n<li>作用域是<strong>词法分析</strong>创建，静态</li>\n<li>执行上下文由<strong>js引擎</strong>创建，动态</li>\n</ul>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>一句话定义闭包，就是<strong>能够访问其他函数内部变量的函数，被称为 <em>闭包</em></strong></p>\n<p>一般闭包的表现形式是：<strong>闭包就是函数内部定义的函数，被返回了出去并在外部调用</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">  function bar() &#123;</span><br><span class=\"line\">    console.log( a );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); // 这就形成了一个闭包</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单剖析一下上面代码的运行流程：</p>\n<ol>\n<li>编译阶段，变量和函数被声明，作用域即被确定。</li>\n<li>运行函数 <code>foo()</code>，此时会创建一个 <code>foo</code> 函数的执行上下文，执行上下文内部存储了 <code>foo</code> 中声明的所有变量函数信息。</li>\n<li>函数 <code>foo</code> 运行完毕，将内部函数 <code>bar</code> 的引用赋值给外部的变量 <code>baz</code> ，此时 <code>baz</code> 指针指向的还是 <code>bar</code> ，因此哪怕它位于 <code>foo</code> 作用域之外，它还是能够获取到 <code>foo</code> 的内部变量。</li>\n<li><code>baz</code> 在外部被执行，<code>baz</code> 的内部可执行代码 <code>console.log</code> 向作用域请求获取 <code>a</code> 变量，本地作用域没有找到，继续请求父级作用域，找到了 <code>foo</code> 中的 <code>a</code> 变量，返回给 <code>console.log</code>，打印出 <code>2</code>。</li>\n</ol>\n<p>闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。</p>\n<h3 id=\"闭包的目的\"><a href=\"#闭包的目的\" class=\"headerlink\" title=\"闭包的目的\"></a>闭包的目的</h3><h4 id=\"1-延长变量存活时间\"><a href=\"#1-延长变量存活时间\" class=\"headerlink\" title=\"1.延长变量存活时间\"></a>1.延长变量存活时间</h4><p>在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。</p>\n<h4 id=\"2-创造私有作用域\"><a href=\"#2-创造私有作用域\" class=\"headerlink\" title=\"2.创造私有作用域\"></a>2.创造私有作用域</h4><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。</p>\n<h3 id=\"闭包的问题：内存泄露\"><a href=\"#闭包的问题：内存泄露\" class=\"headerlink\" title=\"闭包的问题：内存泄露\"></a>闭包的问题：内存泄露</h3><p>我们知道，<code>javascript</code> 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p>\n<p>然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。</p>\n<p>当然，造成内存泄露的原因有很多，除了闭包以外，还有 <strong>全局变量的无意创建</strong>。开发者的本意是想将变量作为局部变量使用，然而忘记写 <code>var</code> 导致变量被泄露到全局中。</p>\n<p>还有 <code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"JavaScript：闭包（Closure）的原理和目的\"><a href=\"#JavaScript：闭包（Closure）的原理和目的\" class=\"headerlink\" title=\"JavaScript：闭包（Closure）的原理和目的\"></a>JavaScript：闭包（Closure）的原理和目的</h1><h2 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h2><p><strong>词法作用域</strong>（<code>Lexical Scopes</code>）是 <code>javascript</code> 中使用的作用域类型，<strong>词法作用域</strong> 也可以被叫做 <strong>静态作用域</strong>，与之相对的还有 <strong>动态作用域</strong>。那么 <code>javascript</code> 使用的 <strong>词法作用域</strong> 和 <strong>动态作用域</strong> 的区别是什么呢？看下面这段代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">  var value = 2;</span><br><span class=\"line\">  foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png\" alt=\"image-20220307194155261\"></p>\n<p>上面这段代码中，一共有三个作用域：</p>\n<ul>\n<li>全局作用域</li>\n<li><code>foo</code> 的函数作用域</li>\n<li><code>bar</code> 的函数作用域</li>\n</ul>\n<p>一直到这边都好理解，可是 <code>foo</code> 里访问了本地作用域中没有的变量 <code>value</code> 。根据前面说的，引擎为了拿到这个变量就要去 <code>foo</code> 的上层作用域查询，那么 <code>foo</code> 的上层作用域是什么呢？是它 <strong>调用时</strong> 所在的 bar 作用域？还是它 <strong>定义时</strong> 所在的全局作用域？</p>\n<p>这个关键的问题就是 <code>javascript</code> 中的作用域类型——<strong>词法作用域。</strong></p>\n<blockquote>\n<p>词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。</p>\n</blockquote>\n<p><strong>词法作用域（Lexical Scope）</strong> 是定义表达式并能被访问的区间。</p>\n<p>换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。</p>\n<p><strong>注意：</strong></p>\n<ul>\n<li>词法作用域又叫静态作用域。</li>\n<li>一个声明 <strong>被调用时的作用域</strong> 不一定是它的词法作用域。相反的，<strong>定义时的作用域</strong> 才是词法作用域</li>\n</ul>\n<h3 id=\"一个词法作用域的小示例\"><a href=\"#一个词法作用域的小示例\" class=\"headerlink\" title=\"一个词法作用域的小示例\"></a>一个词法作用域的小示例</h3><p>考虑如下代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 定义一个全局作用域变量：</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> myName = <span class=\"string\">&quot;Oluwatobi&quot;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 在函数体内调用myName变量</span></span><br><span class=\"line\"><span class=\"keyword\">function</span> <span class=\"title function_\">getName</span>(<span class=\"params\"></span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> myName;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"variable language_\">console</span>.<span class=\"title function_\">log</span>(<span class=\"title function_\">getName</span>()) <span class=\"comment\">// &#x27;Oluwatobi&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>在上述示例中，我们在全局作用域定义了<code>myName</code>变量，并在<code>getName()</code>函数作用域内调用了该变量。</p>\n<p><strong>问题：</strong> <code>myName</code>变量的词法作用域是什么？全局作用域还是 <code>getName()</code>的局部作用域？</p>\n<p><strong>答案：</strong> 切记 <strong>词法作用域</strong> 意味着 <strong>定义时的作用域</strong>，并不是<strong>调用时的作用域</strong> 。因此<code>myName</code>变量的词法作用域是全局作用域，因为我们在全局环境下定义了<code>myName</code>变量。</p>\n<p><strong>换言之，函数的作用域在它的定义的时候就已经确定了。</strong></p>\n<h3 id=\"作用域-scope-与上下文-context-的相似与区别\"><a href=\"#作用域-scope-与上下文-context-的相似与区别\" class=\"headerlink\" title=\"作用域[scope]与上下文[context]的相似与区别\"></a>作用域[scope]与上下文[context]的相似与区别</h3><p>context指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。</p>\n<p>并且它们的创建者不同</p>\n<ul>\n<li>作用域是<strong>词法分析</strong>创建，静态</li>\n<li>执行上下文由<strong>js引擎</strong>创建，动态</li>\n</ul>\n<h2 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h2><p>一句话定义闭包，就是<strong>能够访问其他函数内部变量的函数，被称为 <em>闭包</em></strong></p>\n<p>一般闭包的表现形式是：<strong>闭包就是函数内部定义的函数，被返回了出去并在外部调用</strong>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">  var a = 2;</span><br><span class=\"line\"></span><br><span class=\"line\">  function bar() &#123;</span><br><span class=\"line\">    console.log( a );</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var baz = foo();</span><br><span class=\"line\"></span><br><span class=\"line\">baz(); // 这就形成了一个闭包</span><br></pre></td></tr></table></figure>\n\n<p>我们可以简单剖析一下上面代码的运行流程：</p>\n<ol>\n<li>编译阶段，变量和函数被声明，作用域即被确定。</li>\n<li>运行函数 <code>foo()</code>，此时会创建一个 <code>foo</code> 函数的执行上下文，执行上下文内部存储了 <code>foo</code> 中声明的所有变量函数信息。</li>\n<li>函数 <code>foo</code> 运行完毕，将内部函数 <code>bar</code> 的引用赋值给外部的变量 <code>baz</code> ，此时 <code>baz</code> 指针指向的还是 <code>bar</code> ，因此哪怕它位于 <code>foo</code> 作用域之外，它还是能够获取到 <code>foo</code> 的内部变量。</li>\n<li><code>baz</code> 在外部被执行，<code>baz</code> 的内部可执行代码 <code>console.log</code> 向作用域请求获取 <code>a</code> 变量，本地作用域没有找到，继续请求父级作用域，找到了 <code>foo</code> 中的 <code>a</code> 变量，返回给 <code>console.log</code>，打印出 <code>2</code>。</li>\n</ol>\n<p>闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。</p>\n<h3 id=\"闭包的目的\"><a href=\"#闭包的目的\" class=\"headerlink\" title=\"闭包的目的\"></a>闭包的目的</h3><h4 id=\"1-延长变量存活时间\"><a href=\"#1-延长变量存活时间\" class=\"headerlink\" title=\"1.延长变量存活时间\"></a>1.延长变量存活时间</h4><p>在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。</p>\n<h4 id=\"2-创造私有作用域\"><a href=\"#2-创造私有作用域\" class=\"headerlink\" title=\"2.创造私有作用域\"></a>2.创造私有作用域</h4><p><code>javascript</code> 没有 <code>java</code> 中那种 <code>public</code> <code>private</code> 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。</p>\n<h3 id=\"闭包的问题：内存泄露\"><a href=\"#闭包的问题：内存泄露\" class=\"headerlink\" title=\"闭包的问题：内存泄露\"></a>闭包的问题：内存泄露</h3><p>我们知道，<code>javascript</code> 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 <code>0</code> 的变量标记为失效变量并将之清除从而释放内存。</p>\n<p>然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。</p>\n<p>当然，造成内存泄露的原因有很多，除了闭包以外，还有 <strong>全局变量的无意创建</strong>。开发者的本意是想将变量作为局部变量使用，然而忘记写 <code>var</code> 导致变量被泄露到全局中。</p>\n<p>还有 <code>DOM</code> 的事件绑定，移除 <code>DOM</code> 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。</p>\n"},{"title":"JavaScript：垃圾回收机制","copyright":false,"date":"2022-03-07T13:23:16.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072124126.jpg","_content":"\n垃圾回收：`GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，如果让它们长时间占用内存不仅会让程序的效率降低，还会引起内存泄露等问题。浏览器通常就会通过内置的某些机制进行垃圾回收。\n\n# 垃圾回收策略\n\n在JavaScript内存管理中有一个概念叫做“可达性”，指的是可以通过某种方式读取或使用的性质。JavaScript会将那些不具有可达性的对象给清理回收，释放内存。\n\n一般来说，识别可达性有两种策略\n\n- 标记清除算法\n- 引用计数算法\n\n## 标记清除算法\n\n标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法。\n\n整个标记清除算法大致过程就像下面这样\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成1\n- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\n- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n**优点**\n\n标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单\n\n**缺点**\n\n标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题\n\n## 引用计数算法\n\n**策略**\n\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了。\n\n它的策略是跟踪记录每个变量值被使用的次数\n\n- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\n- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\n\n# V8引擎的GC\n\nV8 是为Google Chrome 提供支持的JavaScript 引擎的名称。 当使用Chrome 进行浏览时，它负责处理并执行JavaScript。 V8 提供了执行JavaScript 的运行时环境。 DOM 和其他Web 平台API 则由浏览器提供。\n\nV8引擎使用的GC机制也是基于标记清除算法，但是在那基础之上还做了一定的优化。\n\n有个这样的思辨故事：金字塔和双子大厦谁会更先倒塌？答案是双子塔大厦，因为老建筑比新建筑倒塌的概率更低。\n\n基于这个理念，V8堆内存被分为了新生代和老生代。\n\n新生代通常只有`1-8M`的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了**不同的垃圾回收器和不同的回收算法**，以便更高效地实施垃圾回收\n\n- `副垃圾回收器 + Scavenge算法`：主要负责新生代的垃圾回收\n- `主垃圾回收器 + Mark-Sweep && Mark-Compact算法`：主要负责老生代的垃圾回收。\n\n","source":"_posts/JavaScript：垃圾回收机制.md","raw":"---\ntitle: JavaScript：垃圾回收机制\ncopyright: false\ndate: 2022-03-07 21:23:16\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072124126.jpg\"\ncategories:\n  - [技术,JavaScript]\n---\n\n垃圾回收：`GC` 即 `Garbage Collection` ，程序工作过程中会产生很多 `垃圾`，如果让它们长时间占用内存不仅会让程序的效率降低，还会引起内存泄露等问题。浏览器通常就会通过内置的某些机制进行垃圾回收。\n\n# 垃圾回收策略\n\n在JavaScript内存管理中有一个概念叫做“可达性”，指的是可以通过某种方式读取或使用的性质。JavaScript会将那些不具有可达性的对象给清理回收，释放内存。\n\n一般来说，识别可达性有两种策略\n\n- 标记清除算法\n- 引用计数算法\n\n## 标记清除算法\n\n标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法。\n\n整个标记清除算法大致过程就像下面这样\n\n- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0\n- 然后从各个根对象开始遍历，把不是垃圾的节点改成1\n- 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间\n- 最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收\n\n**优点**\n\n标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单\n\n**缺点**\n\n标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题\n\n## 引用计数算法\n\n**策略**\n\n引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 `对象是否不再需要` 简化定义为 `对象有没有其他对象引用到它`，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了。\n\n它的策略是跟踪记录每个变量值被使用的次数\n\n- 当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1\n- 如果同一个值又被赋给另一个变量，那么引用数加 1\n- 如果该变量的值被其他的值覆盖了，则引用次数减 1\n- 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存\n\n# V8引擎的GC\n\nV8 是为Google Chrome 提供支持的JavaScript 引擎的名称。 当使用Chrome 进行浏览时，它负责处理并执行JavaScript。 V8 提供了执行JavaScript 的运行时环境。 DOM 和其他Web 平台API 则由浏览器提供。\n\nV8引擎使用的GC机制也是基于标记清除算法，但是在那基础之上还做了一定的优化。\n\n有个这样的思辨故事：金字塔和双子大厦谁会更先倒塌？答案是双子塔大厦，因为老建筑比新建筑倒塌的概率更低。\n\n基于这个理念，V8堆内存被分为了新生代和老生代。\n\n新生代通常只有`1-8M`的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了**不同的垃圾回收器和不同的回收算法**，以便更高效地实施垃圾回收\n\n- `副垃圾回收器 + Scavenge算法`：主要负责新生代的垃圾回收\n- `主垃圾回收器 + Mark-Sweep && Mark-Compact算法`：主要负责老生代的垃圾回收。\n\n","slug":"JavaScript：垃圾回收机制","published":1,"updated":"2022-03-07T13:25:07.106Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0h4eij70000xcuh3alqet2r","content":"<p>垃圾回收：<code>GC</code> 即 <code>Garbage Collection</code> ，程序工作过程中会产生很多 <code>垃圾</code>，如果让它们长时间占用内存不仅会让程序的效率降低，还会引起内存泄露等问题。浏览器通常就会通过内置的某些机制进行垃圾回收。</p>\n<h1 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h1><p>在JavaScript内存管理中有一个概念叫做“可达性”，指的是可以通过某种方式读取或使用的性质。JavaScript会将那些不具有可达性的对象给清理回收，释放内存。</p>\n<p>一般来说，识别可达性有两种策略</p>\n<ul>\n<li>标记清除算法</li>\n<li>引用计数算法</li>\n</ul>\n<h2 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h2><p>标记清除（Mark-Sweep），目前在 <code>JavaScript引擎</code> 里这种算法是最常用的，到目前为止的大多数浏览器的 <code>JavaScript引擎</code> 都在采用标记清除算法。</p>\n<p>整个标记清除算法大致过程就像下面这样</p>\n<ul>\n<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li>\n<li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li>\n<li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li>\n<li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li>\n</ul>\n<p><strong>优点</strong></p>\n<p>标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p>\n<p><strong>缺点</strong></p>\n<p>标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p>\n<h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p><strong>策略</strong></p>\n<p>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code>，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了。</p>\n<p>它的策略是跟踪记录每个变量值被使用的次数</p>\n<ul>\n<li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li>\n<li>如果同一个值又被赋给另一个变量，那么引用数加 1</li>\n<li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li>\n<li>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</li>\n</ul>\n<h1 id=\"V8引擎的GC\"><a href=\"#V8引擎的GC\" class=\"headerlink\" title=\"V8引擎的GC\"></a>V8引擎的GC</h1><p>V8 是为Google Chrome 提供支持的JavaScript 引擎的名称。 当使用Chrome 进行浏览时，它负责处理并执行JavaScript。 V8 提供了执行JavaScript 的运行时环境。 DOM 和其他Web 平台API 则由浏览器提供。</p>\n<p>V8引擎使用的GC机制也是基于标记清除算法，但是在那基础之上还做了一定的优化。</p>\n<p>有个这样的思辨故事：金字塔和双子大厦谁会更先倒塌？答案是双子塔大厦，因为老建筑比新建筑倒塌的概率更低。</p>\n<p>基于这个理念，V8堆内存被分为了新生代和老生代。</p>\n<p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p>\n<ul>\n<li><code>副垃圾回收器 + Scavenge算法</code>：主要负责新生代的垃圾回收</li>\n<li><code>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法</code>：主要负责老生代的垃圾回收。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>垃圾回收：<code>GC</code> 即 <code>Garbage Collection</code> ，程序工作过程中会产生很多 <code>垃圾</code>，如果让它们长时间占用内存不仅会让程序的效率降低，还会引起内存泄露等问题。浏览器通常就会通过内置的某些机制进行垃圾回收。</p>\n<h1 id=\"垃圾回收策略\"><a href=\"#垃圾回收策略\" class=\"headerlink\" title=\"垃圾回收策略\"></a>垃圾回收策略</h1><p>在JavaScript内存管理中有一个概念叫做“可达性”，指的是可以通过某种方式读取或使用的性质。JavaScript会将那些不具有可达性的对象给清理回收，释放内存。</p>\n<p>一般来说，识别可达性有两种策略</p>\n<ul>\n<li>标记清除算法</li>\n<li>引用计数算法</li>\n</ul>\n<h2 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h2><p>标记清除（Mark-Sweep），目前在 <code>JavaScript引擎</code> 里这种算法是最常用的，到目前为止的大多数浏览器的 <code>JavaScript引擎</code> 都在采用标记清除算法。</p>\n<p>整个标记清除算法大致过程就像下面这样</p>\n<ul>\n<li>垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0</li>\n<li>然后从各个根对象开始遍历，把不是垃圾的节点改成1</li>\n<li>清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间</li>\n<li>最后，把所有内存中对象标记修改为0，等待下一轮垃圾回收</li>\n</ul>\n<p><strong>优点</strong></p>\n<p>标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单</p>\n<p><strong>缺点</strong></p>\n<p>标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 <code>内存碎片</code>（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题</p>\n<h2 id=\"引用计数算法\"><a href=\"#引用计数算法\" class=\"headerlink\" title=\"引用计数算法\"></a>引用计数算法</h2><p><strong>策略</strong></p>\n<p>引用计数（Reference Counting），这其实是早先的一种垃圾回收算法，它把 <code>对象是否不再需要</code> 简化定义为 <code>对象有没有其他对象引用到它</code>，如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收，目前很少使用这种算法了。</p>\n<p>它的策略是跟踪记录每个变量值被使用的次数</p>\n<ul>\n<li>当声明了一个变量并且将一个引用类型赋值给该变量的时候这个值的引用次数就为 1</li>\n<li>如果同一个值又被赋给另一个变量，那么引用数加 1</li>\n<li>如果该变量的值被其他的值覆盖了，则引用次数减 1</li>\n<li>当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存</li>\n</ul>\n<h1 id=\"V8引擎的GC\"><a href=\"#V8引擎的GC\" class=\"headerlink\" title=\"V8引擎的GC\"></a>V8引擎的GC</h1><p>V8 是为Google Chrome 提供支持的JavaScript 引擎的名称。 当使用Chrome 进行浏览时，它负责处理并执行JavaScript。 V8 提供了执行JavaScript 的运行时环境。 DOM 和其他Web 平台API 则由浏览器提供。</p>\n<p>V8引擎使用的GC机制也是基于标记清除算法，但是在那基础之上还做了一定的优化。</p>\n<p>有个这样的思辨故事：金字塔和双子大厦谁会更先倒塌？答案是双子塔大厦，因为老建筑比新建筑倒塌的概率更低。</p>\n<p>基于这个理念，V8堆内存被分为了新生代和老生代。</p>\n<p>新生代通常只有<code>1-8M</code>的容量，而老生代的容量就大很多了。对于这两块区域，V8分别使用了<strong>不同的垃圾回收器和不同的回收算法</strong>，以便更高效地实施垃圾回收</p>\n<ul>\n<li><code>副垃圾回收器 + Scavenge算法</code>：主要负责新生代的垃圾回收</li>\n<li><code>主垃圾回收器 + Mark-Sweep &amp;&amp; Mark-Compact算法</code>：主要负责老生代的垃圾回收。</li>\n</ul>\n"},{"title":"JavaScript：浅谈Promise","copyright":false,"date":"2022-03-07T16:38:05.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203080040881.webp","_content":"\nPromise是ES6新增的一个专门用于解决**回调地狱**问题的API，一个 `Promise` 对象代表一个在这个 promise 被创建出来时不一定已知的值。\n\n它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 *promise*，以便在未来某个时候把值交给使用者。\n\n# 回调地狱\n\n异步js编程常常会使用回调函数来进行业务逻辑的编写，并且这些回调总是互相嵌套的。然而一旦嵌套的层数多于一个数值，代码的可读性就会变得很差，并且不断向右拓展，这便是回调地狱。\n\nES6为了解决回调地狱问题，设计了promise专门用于异步编程。\n\n# Promise的三种状态（state）\n\n一个 `Promise` 必然处于以下几种状态之一：\n\n- *待定（pending）*: 初始状态，既没有被兑现，也没有被拒绝。\n- *已兑现（fulfilled）*: 意味着操作成功完成。\n- *已拒绝（rejected）*: 意味着操作失败。\n\n待定状态的 Promise 对象要么会通过一个值*被兑现（fulfilled）*，要么会通过一个原因（错误）*被拒绝（rejected）*。并且这三种状态的转换是不可逆的，换言之，Promise要么从pending转换为fulfilled，要么从pending转换为rejected。\n\n# Promise.then形成的链式调用\n\n接下来，就到了Promise如何解决回调地狱问题的关键API：.then方法了。\n\n![img](https://mdn.mozillademos.org/files/8633/promises.png)\n\n当Promise的状态改变，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。并且这种调用是链式的：因为Promise在then中返回的也是一个promise对象。这代表我们可以不断调用.then方法来执行回调。就像这样：\n\n```\nconst myPromise =\n  (new Promise(myExecutorFunc))\n  .then(handleFulfilledA,handleRejectedA)\n  .then(handleFulfilledB,handleRejectedB)\n  .then(handleFulfilledC,handleRejectedC);\n\n// 或者，这样可能会更好...\n\nconst myPromise =\n  (new Promise(myExecutorFunc))\n  .then(handleFulfilledA)\n  .then(handleFulfilledB)\n  .then(handleFulfilledC)\n  .catch(handleRejectedAny);\n```\n\n# 静态方法\n\n## Promise.all(iterable)\n\nPromise.all()可以传入一个可迭代对象（包括Array、map、set都属于ES6的iterable类型），一般是数个Promise实例，并且返回一个Promise实例。而返回的promise的回调必须等待所有传入的Promise的resolve回调都结束，如果有一个reject，它都会停止执行并立即抛出这个错误。\n\n实例：\n\n```\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3]).then((values) => {\n  console.log(values);\n});\n// expected output: Array [3, 42, \"foo\"]\n\n```\n\n## Promise.allSettled()\n\nPromise.allSettled和Promise.all类似，传入的都是一个Promise对象数组，不过Promise.allSettled()是等到所有promises都已敲定（settled）返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。\n\n## Promise.any(iterable)\n\n接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。（这与Promise.all恰恰相反）\n\n## Promise.race(iterable)\n\n当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\n\n**注：可用于限定时间的异步操作**\n","source":"_posts/JavaScript：浅谈Promise.md","raw":"---\ntitle: JavaScript：浅谈Promise\ncopyright: false\ndate: 2022-03-08 00:38:05\ntags:\n  - JavaScript\n  - ES6\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203080040881.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\nPromise是ES6新增的一个专门用于解决**回调地狱**问题的API，一个 `Promise` 对象代表一个在这个 promise 被创建出来时不一定已知的值。\n\n它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 *promise*，以便在未来某个时候把值交给使用者。\n\n# 回调地狱\n\n异步js编程常常会使用回调函数来进行业务逻辑的编写，并且这些回调总是互相嵌套的。然而一旦嵌套的层数多于一个数值，代码的可读性就会变得很差，并且不断向右拓展，这便是回调地狱。\n\nES6为了解决回调地狱问题，设计了promise专门用于异步编程。\n\n# Promise的三种状态（state）\n\n一个 `Promise` 必然处于以下几种状态之一：\n\n- *待定（pending）*: 初始状态，既没有被兑现，也没有被拒绝。\n- *已兑现（fulfilled）*: 意味着操作成功完成。\n- *已拒绝（rejected）*: 意味着操作失败。\n\n待定状态的 Promise 对象要么会通过一个值*被兑现（fulfilled）*，要么会通过一个原因（错误）*被拒绝（rejected）*。并且这三种状态的转换是不可逆的，换言之，Promise要么从pending转换为fulfilled，要么从pending转换为rejected。\n\n# Promise.then形成的链式调用\n\n接下来，就到了Promise如何解决回调地狱问题的关键API：.then方法了。\n\n![img](https://mdn.mozillademos.org/files/8633/promises.png)\n\n当Promise的状态改变，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。并且这种调用是链式的：因为Promise在then中返回的也是一个promise对象。这代表我们可以不断调用.then方法来执行回调。就像这样：\n\n```\nconst myPromise =\n  (new Promise(myExecutorFunc))\n  .then(handleFulfilledA,handleRejectedA)\n  .then(handleFulfilledB,handleRejectedB)\n  .then(handleFulfilledC,handleRejectedC);\n\n// 或者，这样可能会更好...\n\nconst myPromise =\n  (new Promise(myExecutorFunc))\n  .then(handleFulfilledA)\n  .then(handleFulfilledB)\n  .then(handleFulfilledC)\n  .catch(handleRejectedAny);\n```\n\n# 静态方法\n\n## Promise.all(iterable)\n\nPromise.all()可以传入一个可迭代对象（包括Array、map、set都属于ES6的iterable类型），一般是数个Promise实例，并且返回一个Promise实例。而返回的promise的回调必须等待所有传入的Promise的resolve回调都结束，如果有一个reject，它都会停止执行并立即抛出这个错误。\n\n实例：\n\n```\nconst promise1 = Promise.resolve(3);\nconst promise2 = 42;\nconst promise3 = new Promise((resolve, reject) => {\n  setTimeout(resolve, 100, 'foo');\n});\n\nPromise.all([promise1, promise2, promise3]).then((values) => {\n  console.log(values);\n});\n// expected output: Array [3, 42, \"foo\"]\n\n```\n\n## Promise.allSettled()\n\nPromise.allSettled和Promise.all类似，传入的都是一个Promise对象数组，不过Promise.allSettled()是等到所有promises都已敲定（settled）返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。\n\n## Promise.any(iterable)\n\n接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。（这与Promise.all恰恰相反）\n\n## Promise.race(iterable)\n\n当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。\n\n**注：可用于限定时间的异步操作**\n","slug":"JavaScript：浅谈Promise","published":1,"updated":"2022-03-07T16:40:34.798Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0h4eij90001xcuhgda92f88","content":"<p>Promise是ES6新增的一个专门用于解决<strong>回调地狱</strong>问题的API，一个 <code>Promise</code> 对象代表一个在这个 promise 被创建出来时不一定已知的值。</p>\n<p>它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>promise</em>，以便在未来某个时候把值交给使用者。</p>\n<h1 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h1><p>异步js编程常常会使用回调函数来进行业务逻辑的编写，并且这些回调总是互相嵌套的。然而一旦嵌套的层数多于一个数值，代码的可读性就会变得很差，并且不断向右拓展，这便是回调地狱。</p>\n<p>ES6为了解决回调地狱问题，设计了promise专门用于异步编程。</p>\n<h1 id=\"Promise的三种状态（state）\"><a href=\"#Promise的三种状态（state）\" class=\"headerlink\" title=\"Promise的三种状态（state）\"></a>Promise的三种状态（state）</h1><p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>\n<ul>\n<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>\n<li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li>\n<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>\n</ul>\n<p>待定状态的 Promise 对象要么会通过一个值<em>被兑现（fulfilled）</em>，要么会通过一个原因（错误）<em>被拒绝（rejected）</em>。并且这三种状态的转换是不可逆的，换言之，Promise要么从pending转换为fulfilled，要么从pending转换为rejected。</p>\n<h1 id=\"Promise-then形成的链式调用\"><a href=\"#Promise-then形成的链式调用\" class=\"headerlink\" title=\"Promise.then形成的链式调用\"></a>Promise.then形成的链式调用</h1><p>接下来，就到了Promise如何解决回调地狱问题的关键API：.then方法了。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"img\"></p>\n<p>当Promise的状态改变，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。并且这种调用是链式的：因为Promise在then中返回的也是一个promise对象。这代表我们可以不断调用.then方法来执行回调。就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myPromise =</span><br><span class=\"line\">  (new Promise(myExecutorFunc))</span><br><span class=\"line\">  .then(handleFulfilledA,handleRejectedA)</span><br><span class=\"line\">  .then(handleFulfilledB,handleRejectedB)</span><br><span class=\"line\">  .then(handleFulfilledC,handleRejectedC);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者，这样可能会更好...</span><br><span class=\"line\"></span><br><span class=\"line\">const myPromise =</span><br><span class=\"line\">  (new Promise(myExecutorFunc))</span><br><span class=\"line\">  .then(handleFulfilledA)</span><br><span class=\"line\">  .then(handleFulfilledB)</span><br><span class=\"line\">  .then(handleFulfilledC)</span><br><span class=\"line\">  .catch(handleRejectedAny);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h1><h2 id=\"Promise-all-iterable\"><a href=\"#Promise-all-iterable\" class=\"headerlink\" title=\"Promise.all(iterable)\"></a>Promise.all(iterable)</h2><p>Promise.all()可以传入一个可迭代对象（包括Array、map、set都属于ES6的iterable类型），一般是数个Promise实例，并且返回一个Promise实例。而返回的promise的回调必须等待所有传入的Promise的resolve回调都结束，如果有一个reject，它都会停止执行并立即抛出这个错误。</p>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise1 = Promise.resolve(3);</span><br><span class=\"line\">const promise2 = 42;</span><br><span class=\"line\">const promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 100, &#x27;foo&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123;</span><br><span class=\"line\">  console.log(values);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// expected output: Array [3, 42, &quot;foo&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h2><p>Promise.allSettled和Promise.all类似，传入的都是一个Promise对象数组，不过Promise.allSettled()是等到所有promises都已敲定（settled）返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。</p>\n<h2 id=\"Promise-any-iterable\"><a href=\"#Promise-any-iterable\" class=\"headerlink\" title=\"Promise.any(iterable)\"></a>Promise.any(iterable)</h2><p>接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。（这与Promise.all恰恰相反）</p>\n<h2 id=\"Promise-race-iterable\"><a href=\"#Promise-race-iterable\" class=\"headerlink\" title=\"Promise.race(iterable)\"></a>Promise.race(iterable)</h2><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p>\n<p><strong>注：可用于限定时间的异步操作</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Promise是ES6新增的一个专门用于解决<strong>回调地狱</strong>问题的API，一个 <code>Promise</code> 对象代表一个在这个 promise 被创建出来时不一定已知的值。</p>\n<p>它让您能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。 这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 <em>promise</em>，以便在未来某个时候把值交给使用者。</p>\n<h1 id=\"回调地狱\"><a href=\"#回调地狱\" class=\"headerlink\" title=\"回调地狱\"></a>回调地狱</h1><p>异步js编程常常会使用回调函数来进行业务逻辑的编写，并且这些回调总是互相嵌套的。然而一旦嵌套的层数多于一个数值，代码的可读性就会变得很差，并且不断向右拓展，这便是回调地狱。</p>\n<p>ES6为了解决回调地狱问题，设计了promise专门用于异步编程。</p>\n<h1 id=\"Promise的三种状态（state）\"><a href=\"#Promise的三种状态（state）\" class=\"headerlink\" title=\"Promise的三种状态（state）\"></a>Promise的三种状态（state）</h1><p>一个 <code>Promise</code> 必然处于以下几种状态之一：</p>\n<ul>\n<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>\n<li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li>\n<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>\n</ul>\n<p>待定状态的 Promise 对象要么会通过一个值<em>被兑现（fulfilled）</em>，要么会通过一个原因（错误）<em>被拒绝（rejected）</em>。并且这三种状态的转换是不可逆的，换言之，Promise要么从pending转换为fulfilled，要么从pending转换为rejected。</p>\n<h1 id=\"Promise-then形成的链式调用\"><a href=\"#Promise-then形成的链式调用\" class=\"headerlink\" title=\"Promise.then形成的链式调用\"></a>Promise.then形成的链式调用</h1><p>接下来，就到了Promise如何解决回调地狱问题的关键API：.then方法了。</p>\n<p><img src=\"https://mdn.mozillademos.org/files/8633/promises.png\" alt=\"img\"></p>\n<p>当Promise的状态改变，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。并且这种调用是链式的：因为Promise在then中返回的也是一个promise对象。这代表我们可以不断调用.then方法来执行回调。就像这样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const myPromise =</span><br><span class=\"line\">  (new Promise(myExecutorFunc))</span><br><span class=\"line\">  .then(handleFulfilledA,handleRejectedA)</span><br><span class=\"line\">  .then(handleFulfilledB,handleRejectedB)</span><br><span class=\"line\">  .then(handleFulfilledC,handleRejectedC);</span><br><span class=\"line\"></span><br><span class=\"line\">// 或者，这样可能会更好...</span><br><span class=\"line\"></span><br><span class=\"line\">const myPromise =</span><br><span class=\"line\">  (new Promise(myExecutorFunc))</span><br><span class=\"line\">  .then(handleFulfilledA)</span><br><span class=\"line\">  .then(handleFulfilledB)</span><br><span class=\"line\">  .then(handleFulfilledC)</span><br><span class=\"line\">  .catch(handleRejectedAny);</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h1><h2 id=\"Promise-all-iterable\"><a href=\"#Promise-all-iterable\" class=\"headerlink\" title=\"Promise.all(iterable)\"></a>Promise.all(iterable)</h2><p>Promise.all()可以传入一个可迭代对象（包括Array、map、set都属于ES6的iterable类型），一般是数个Promise实例，并且返回一个Promise实例。而返回的promise的回调必须等待所有传入的Promise的resolve回调都结束，如果有一个reject，它都会停止执行并立即抛出这个错误。</p>\n<p>实例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise1 = Promise.resolve(3);</span><br><span class=\"line\">const promise2 = 42;</span><br><span class=\"line\">const promise3 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">  setTimeout(resolve, 100, &#x27;foo&#x27;);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">Promise.all([promise1, promise2, promise3]).then((values) =&gt; &#123;</span><br><span class=\"line\">  console.log(values);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">// expected output: Array [3, 42, &quot;foo&quot;]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Promise-allSettled\"><a href=\"#Promise-allSettled\" class=\"headerlink\" title=\"Promise.allSettled()\"></a>Promise.allSettled()</h2><p>Promise.allSettled和Promise.all类似，传入的都是一个Promise对象数组，不过Promise.allSettled()是等到所有promises都已敲定（settled）返回一个promise，该promise在所有promise完成后完成。并带有一个对象数组，每个对象对应每个promise的结果。</p>\n<h2 id=\"Promise-any-iterable\"><a href=\"#Promise-any-iterable\" class=\"headerlink\" title=\"Promise.any(iterable)\"></a>Promise.any(iterable)</h2><p>接收一个Promise对象的集合，当其中的一个 promise 成功，就返回那个成功的promise的值。（这与Promise.all恰恰相反）</p>\n<h2 id=\"Promise-race-iterable\"><a href=\"#Promise-race-iterable\" class=\"headerlink\" title=\"Promise.race(iterable)\"></a>Promise.race(iterable)</h2><p>当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象。</p>\n<p><strong>注：可用于限定时间的异步操作</strong></p>\n"},{"title":"JavaScript：原型和原型链","copyright":false,"date":"2022-03-08T06:48:42.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081451787.webp","_content":"\njs中数据类型分为基础数据类型：number、string、boolean、undefined、null、bigInt、Symbol，和引用数据类型：Object、Array、Function。\n\njs脚本中的任意一个对象都可以识别成以上某一种类型。\n\n# 原型\n\n原型分为显式原型`[[prototype]]`和隐式原型`[[__proto__]]`他们不同时存在与一个对象上，而是一个存在构造函数上一个存在实例之上。\n\n一般来说，构造函数的显式原型对象就是实例的隐式原型对象，即`Object.prototype==obj.__proto__`\n\n# 原型链\n\n实例有原型，那么它的上层：构造函数是否有原型呢？\n\n答案是有的，但是以上的表述并不准确，正确的表达应该是：构造函数的原型对象依然存在`__proto__`去寻址它的原型对象。\n\n原型链便是在不断的向上寻址中构建出来，所有对象的原型对象最后都是Object.prototype，而它的上层则是null，这是为了避免死循环的设计。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n**注：这也从侧面说明了万物皆对象。**\n\n# 继承\n\n继承在Java中指的是类与类之间使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。\n\n然而js中并没有类这个概念，ES6增加的class也仅仅是一个语法糖，但基于原型链，js使用了另一种继承方法。\n\n## **原型链继承**\n\n就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果。\n\n然而，原型链继承还未解决其中子类this指向问题，便有了组合继承使用call来改变子类this指向。可这依然存在问题，父类的构造函数被调用了两次（创建子类原型时调用了一次，创建子类实例时又调用了一次），导致子类原型上会存在父类实例属性，浪费内存。\n\n## 寄生组合继承\n\n针对组合继承存在的缺陷，又进化出了“寄生组合继承”：使用 `Object.create(Parent.prototype)` 创建一个新的原型对象赋予子类从而解决组合继承的缺陷。\n\n寄生组合继承的模式是现在业内公认的比较可靠的 `JS` 继承模式，`ES6` 的 `class` 继承在 `babel` 转义后，底层也是使用的寄生组合继承的方式实现的。\n\n# new操作符做了什么？\n\n1.它首先创建了一块空对象，用于存放实例对象。\n\n2.它将实例的原型对象指向了构造函数的原型对象。\n\n3.它将空对象作为构造函数的上下文（即改变this指向）\n\n4.判断实例的返回值类型，并返回实例对象。\n","source":"_posts/JavaScript：原型和原型链.md","raw":"---\ntitle: JavaScript：原型和原型链\ncopyright: false\ndate: 2022-03-08 14:48:42\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081451787.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\njs中数据类型分为基础数据类型：number、string、boolean、undefined、null、bigInt、Symbol，和引用数据类型：Object、Array、Function。\n\njs脚本中的任意一个对象都可以识别成以上某一种类型。\n\n# 原型\n\n原型分为显式原型`[[prototype]]`和隐式原型`[[__proto__]]`他们不同时存在与一个对象上，而是一个存在构造函数上一个存在实例之上。\n\n一般来说，构造函数的显式原型对象就是实例的隐式原型对象，即`Object.prototype==obj.__proto__`\n\n# 原型链\n\n实例有原型，那么它的上层：构造函数是否有原型呢？\n\n答案是有的，但是以上的表述并不准确，正确的表达应该是：构造函数的原型对象依然存在`__proto__`去寻址它的原型对象。\n\n原型链便是在不断的向上寻址中构建出来，所有对象的原型对象最后都是Object.prototype，而它的上层则是null，这是为了避免死循环的设计。\n\n![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)\n\n**注：这也从侧面说明了万物皆对象。**\n\n# 继承\n\n继承在Java中指的是类与类之间使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。\n\n然而js中并没有类这个概念，ES6增加的class也仅仅是一个语法糖，但基于原型链，js使用了另一种继承方法。\n\n## **原型链继承**\n\n就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果。\n\n然而，原型链继承还未解决其中子类this指向问题，便有了组合继承使用call来改变子类this指向。可这依然存在问题，父类的构造函数被调用了两次（创建子类原型时调用了一次，创建子类实例时又调用了一次），导致子类原型上会存在父类实例属性，浪费内存。\n\n## 寄生组合继承\n\n针对组合继承存在的缺陷，又进化出了“寄生组合继承”：使用 `Object.create(Parent.prototype)` 创建一个新的原型对象赋予子类从而解决组合继承的缺陷。\n\n寄生组合继承的模式是现在业内公认的比较可靠的 `JS` 继承模式，`ES6` 的 `class` 继承在 `babel` 转义后，底层也是使用的寄生组合继承的方式实现的。\n\n# new操作符做了什么？\n\n1.它首先创建了一块空对象，用于存放实例对象。\n\n2.它将实例的原型对象指向了构造函数的原型对象。\n\n3.它将空对象作为构造函数的上下文（即改变this指向）\n\n4.判断实例的返回值类型，并返回实例对象。\n","slug":"JavaScript：原型和原型链","published":1,"updated":"2022-03-08T06:54:50.505Z","_id":"cl0hru2370000e0uh8i8r4neu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>js中数据类型分为基础数据类型：number、string、boolean、undefined、null、bigInt、Symbol，和引用数据类型：Object、Array、Function。</p>\n<p>js脚本中的任意一个对象都可以识别成以上某一种类型。</p>\n<h1 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h1><p>原型分为显式原型<code>[[prototype]]</code>和隐式原型<code>[[__proto__]]</code>他们不同时存在与一个对象上，而是一个存在构造函数上一个存在实例之上。</p>\n<p>一般来说，构造函数的显式原型对象就是实例的隐式原型对象，即<code>Object.prototype==obj.__proto__</code></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><p>实例有原型，那么它的上层：构造函数是否有原型呢？</p>\n<p>答案是有的，但是以上的表述并不准确，正确的表达应该是：构造函数的原型对象依然存在<code>__proto__</code>去寻址它的原型对象。</p>\n<p>原型链便是在不断的向上寻址中构建出来，所有对象的原型对象最后都是Object.prototype，而它的上层则是null，这是为了避免死循环的设计。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"></p>\n<p><strong>注：这也从侧面说明了万物皆对象。</strong></p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承在Java中指的是类与类之间使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n<p>然而js中并没有类这个概念，ES6增加的class也仅仅是一个语法糖，但基于原型链，js使用了另一种继承方法。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a><strong>原型链继承</strong></h2><p>就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果。</p>\n<p>然而，原型链继承还未解决其中子类this指向问题，便有了组合继承使用call来改变子类this指向。可这依然存在问题，父类的构造函数被调用了两次（创建子类原型时调用了一次，创建子类实例时又调用了一次），导致子类原型上会存在父类实例属性，浪费内存。</p>\n<h2 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h2><p>针对组合继承存在的缺陷，又进化出了“寄生组合继承”：使用 <code>Object.create(Parent.prototype)</code> 创建一个新的原型对象赋予子类从而解决组合继承的缺陷。</p>\n<p>寄生组合继承的模式是现在业内公认的比较可靠的 <code>JS</code> 继承模式，<code>ES6</code> 的 <code>class</code> 继承在 <code>babel</code> 转义后，底层也是使用的寄生组合继承的方式实现的。</p>\n<h1 id=\"new操作符做了什么？\"><a href=\"#new操作符做了什么？\" class=\"headerlink\" title=\"new操作符做了什么？\"></a>new操作符做了什么？</h1><p>1.它首先创建了一块空对象，用于存放实例对象。</p>\n<p>2.它将实例的原型对象指向了构造函数的原型对象。</p>\n<p>3.它将空对象作为构造函数的上下文（即改变this指向）</p>\n<p>4.判断实例的返回值类型，并返回实例对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>js中数据类型分为基础数据类型：number、string、boolean、undefined、null、bigInt、Symbol，和引用数据类型：Object、Array、Function。</p>\n<p>js脚本中的任意一个对象都可以识别成以上某一种类型。</p>\n<h1 id=\"原型\"><a href=\"#原型\" class=\"headerlink\" title=\"原型\"></a>原型</h1><p>原型分为显式原型<code>[[prototype]]</code>和隐式原型<code>[[__proto__]]</code>他们不同时存在与一个对象上，而是一个存在构造函数上一个存在实例之上。</p>\n<p>一般来说，构造函数的显式原型对象就是实例的隐式原型对象，即<code>Object.prototype==obj.__proto__</code></p>\n<h1 id=\"原型链\"><a href=\"#原型链\" class=\"headerlink\" title=\"原型链\"></a>原型链</h1><p>实例有原型，那么它的上层：构造函数是否有原型呢？</p>\n<p>答案是有的，但是以上的表述并不准确，正确的表达应该是：构造函数的原型对象依然存在<code>__proto__</code>去寻址它的原型对象。</p>\n<p>原型链便是在不断的向上寻址中构建出来，所有对象的原型对象最后都是Object.prototype，而它的上层则是null，这是为了避免死循环的设计。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c631b657ca62427a8bdef1a2c145346a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp\" alt=\"image.png\"></p>\n<p><strong>注：这也从侧面说明了万物皆对象。</strong></p>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承在Java中指的是类与类之间使得子类具有父类的属性和方法或者重新定义、追加属性和方法等。</p>\n<p>然而js中并没有类这个概念，ES6增加的class也仅仅是一个语法糖，但基于原型链，js使用了另一种继承方法。</p>\n<h2 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a><strong>原型链继承</strong></h2><p>就是让对象实例通过原型链的方式串联起来，当访问目标对象的某一属性时，能顺着原型链进行查找，从而达到类似继承的效果。</p>\n<p>然而，原型链继承还未解决其中子类this指向问题，便有了组合继承使用call来改变子类this指向。可这依然存在问题，父类的构造函数被调用了两次（创建子类原型时调用了一次，创建子类实例时又调用了一次），导致子类原型上会存在父类实例属性，浪费内存。</p>\n<h2 id=\"寄生组合继承\"><a href=\"#寄生组合继承\" class=\"headerlink\" title=\"寄生组合继承\"></a>寄生组合继承</h2><p>针对组合继承存在的缺陷，又进化出了“寄生组合继承”：使用 <code>Object.create(Parent.prototype)</code> 创建一个新的原型对象赋予子类从而解决组合继承的缺陷。</p>\n<p>寄生组合继承的模式是现在业内公认的比较可靠的 <code>JS</code> 继承模式，<code>ES6</code> 的 <code>class</code> 继承在 <code>babel</code> 转义后，底层也是使用的寄生组合继承的方式实现的。</p>\n<h1 id=\"new操作符做了什么？\"><a href=\"#new操作符做了什么？\" class=\"headerlink\" title=\"new操作符做了什么？\"></a>new操作符做了什么？</h1><p>1.它首先创建了一块空对象，用于存放实例对象。</p>\n<p>2.它将实例的原型对象指向了构造函数的原型对象。</p>\n<p>3.它将空对象作为构造函数的上下文（即改变this指向）</p>\n<p>4.判断实例的返回值类型，并返回实例对象。</p>\n"},{"title":"CSS：如何画一个三角形","copyright":false,"date":"2022-03-08T10:16:58.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png","_content":"\n代码如下：\n\n```\n.tri{\n    /* margin:  0 auto; */\n    width: 0;\n    height: 0;\n    /* border-top  : 100px solid skyblue; */\n    /* border-right: 100px solid rebeccapurple; */\n    border: 100px solid transparent;\n    border-bottom: 200px solid rgb(35, 134, 138);\n    /* border-left: 100px solid rgb(235, 188, 135); */\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate( -50%, -50%);\n}\n```\n\n原理也很简单，设置div大小为0，border设置成100，此时可以得到一个沿对角线等分成四份的正方形\n\n![image-20220308181435045](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png)\n\n然后再将其中三边变成透明的`border: 100px solid transparent;`\n\n![image-20220308181504663](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081815699.png)\n\n同理也可以得到梯形、扇形`radius`。\n","source":"_posts/CSS：如何画一个三角形.md","raw":"---\ntitle: CSS：如何画一个三角形\ncopyright: false\ndate: 2022-03-08 18:16:58\ntags: CSS\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png\"\ncategories:\t\n  - [技术,CSS]\n---\n\n代码如下：\n\n```\n.tri{\n    /* margin:  0 auto; */\n    width: 0;\n    height: 0;\n    /* border-top  : 100px solid skyblue; */\n    /* border-right: 100px solid rebeccapurple; */\n    border: 100px solid transparent;\n    border-bottom: 200px solid rgb(35, 134, 138);\n    /* border-left: 100px solid rgb(235, 188, 135); */\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate( -50%, -50%);\n}\n```\n\n原理也很简单，设置div大小为0，border设置成100，此时可以得到一个沿对角线等分成四份的正方形\n\n![image-20220308181435045](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png)\n\n然后再将其中三边变成透明的`border: 100px solid transparent;`\n\n![image-20220308181504663](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081815699.png)\n\n同理也可以得到梯形、扇形`radius`。\n","slug":"CSS：如何画一个三角形","published":1,"updated":"2022-03-08T10:17:45.112Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0hzb1go0000j0uh75x5hk2j","content":"<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.tri&#123;</span><br><span class=\"line\">    /* margin:  0 auto; */</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    /* border-top  : 100px solid skyblue; */</span><br><span class=\"line\">    /* border-right: 100px solid rebeccapurple; */</span><br><span class=\"line\">    border: 100px solid transparent;</span><br><span class=\"line\">    border-bottom: 200px solid rgb(35, 134, 138);</span><br><span class=\"line\">    /* border-left: 100px solid rgb(235, 188, 135); */</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 50%;</span><br><span class=\"line\">    left: 50%;</span><br><span class=\"line\">    transform: translate( -50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原理也很简单，设置div大小为0，border设置成100，此时可以得到一个沿对角线等分成四份的正方形</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png\" alt=\"image-20220308181435045\"></p>\n<p>然后再将其中三边变成透明的<code>border: 100px solid transparent;</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081815699.png\" alt=\"image-20220308181504663\"></p>\n<p>同理也可以得到梯形、扇形<code>radius</code>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>代码如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.tri&#123;</span><br><span class=\"line\">    /* margin:  0 auto; */</span><br><span class=\"line\">    width: 0;</span><br><span class=\"line\">    height: 0;</span><br><span class=\"line\">    /* border-top  : 100px solid skyblue; */</span><br><span class=\"line\">    /* border-right: 100px solid rebeccapurple; */</span><br><span class=\"line\">    border: 100px solid transparent;</span><br><span class=\"line\">    border-bottom: 200px solid rgb(35, 134, 138);</span><br><span class=\"line\">    /* border-left: 100px solid rgb(235, 188, 135); */</span><br><span class=\"line\">    position: absolute;</span><br><span class=\"line\">    top: 50%;</span><br><span class=\"line\">    left: 50%;</span><br><span class=\"line\">    transform: translate( -50%, -50%);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>原理也很简单，设置div大小为0，border设置成100，此时可以得到一个沿对角线等分成四份的正方形</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081814102.png\" alt=\"image-20220308181435045\"></p>\n<p>然后再将其中三边变成透明的<code>border: 100px solid transparent;</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203081815699.png\" alt=\"image-20220308181504663\"></p>\n<p>同理也可以得到梯形、扇形<code>radius</code>。</p>\n"},{"title":"Vue：$nextTick使用","copyright":false,"date":"2022-03-10T21:54:00.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110557723.webp","_content":"\n# 官方文档\n\n`Vue.nextTick( [callback, context] )`\n参数：\n\n`{Function} [callback]`\n`{Object} [context]`\n用法：\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n```\n// 修改数据\nvm.msg = 'Hello'\n// DOM 还没有更新\nVue.nextTick(function () {\n  // DOM 更新了\n})\n\n// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\nVue.nextTick()\n  .then(function () {\n    // DOM 更新了\n  })\n```\n\n2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\n## 异步更新队列\n\n可能你还没有注意到，Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。\n\n例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。例如：\n\n```\n<div id=\"example\">{{message}}</div>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n\n在组件内使用 `vm.$nextTick()` 实例方法特别方便，因为它不需要全局 `Vue`，并且回调函数中的 `this` 将自动绑定到当前的 Vue 实例上：\n\n```\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: '未更新'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = '已更新'\n      console.log(this.$el.textContent) // => '未更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '已更新'\n      })\n    }\n  }\n})\n```\n\n因为 `$nextTick()` 返回一个 `Promise` 对象，所以你可以使用新的 [ES2017 async/await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function) 语法完成相同的事情：\n\n```\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```\n\n# 关于nextTick\n\n在Vue2.4-2.6版本中中，nextTick反复变动，其原因最终是因为浏览器对于微任务的不兼容，并且宏任务与微任务各有优劣，Vue也是在不断取舍。nextTick主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\n","source":"_posts/Vue：-nextTick使用.md","raw":"---\ntitle: Vue：$nextTick使用\ncopyright: false\ndate: 2022-03-11 05:54:00\ntags: Vue\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110557723.webp\"\ncategories:\n  - [技术,Vue]\n---\n\n# 官方文档\n\n`Vue.nextTick( [callback, context] )`\n参数：\n\n`{Function} [callback]`\n`{Object} [context]`\n用法：\n\n在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。\n\n```\n// 修改数据\nvm.msg = 'Hello'\n// DOM 还没有更新\nVue.nextTick(function () {\n  // DOM 更新了\n})\n\n// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)\nVue.nextTick()\n  .then(function () {\n    // DOM 更新了\n  })\n```\n\n2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。\n\n## 异步更新队列\n\n可能你还没有注意到，Vue 在更新 DOM 时是**异步**执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 `Promise.then`、`MutationObserver` 和 `setImmediate`，如果执行环境不支持，则会采用 `setTimeout(fn, 0)` 代替。\n\n例如，当你设置 `vm.someData = 'new value'`，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 `Vue.nextTick(callback)`。这样回调函数将在 DOM 更新完成后被调用。例如：\n\n```\n<div id=\"example\">{{message}}</div>\nvar vm = new Vue({\n  el: '#example',\n  data: {\n    message: '123'\n  }\n})\nvm.message = 'new message' // 更改数据\nvm.$el.textContent === 'new message' // false\nVue.nextTick(function () {\n  vm.$el.textContent === 'new message' // true\n})\n```\n\n在组件内使用 `vm.$nextTick()` 实例方法特别方便，因为它不需要全局 `Vue`，并且回调函数中的 `this` 将自动绑定到当前的 Vue 实例上：\n\n```\nVue.component('example', {\n  template: '<span>{{ message }}</span>',\n  data: function () {\n    return {\n      message: '未更新'\n    }\n  },\n  methods: {\n    updateMessage: function () {\n      this.message = '已更新'\n      console.log(this.$el.textContent) // => '未更新'\n      this.$nextTick(function () {\n        console.log(this.$el.textContent) // => '已更新'\n      })\n    }\n  }\n})\n```\n\n因为 `$nextTick()` 返回一个 `Promise` 对象，所以你可以使用新的 [ES2017 async/await](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function) 语法完成相同的事情：\n\n```\nmethods: {\n  updateMessage: async function () {\n    this.message = '已更新'\n    console.log(this.$el.textContent) // => '未更新'\n    await this.$nextTick()\n    console.log(this.$el.textContent) // => '已更新'\n  }\n}\n```\n\n# 关于nextTick\n\n在Vue2.4-2.6版本中中，nextTick反复变动，其原因最终是因为浏览器对于微任务的不兼容，并且宏任务与微任务各有优劣，Vue也是在不断取舍。nextTick主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。\n\n","slug":"Vue：-nextTick使用","published":1,"updated":"2022-03-10T21:57:23.993Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0lj6vy40000j0uhd92691kx","content":"<h1 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h1><p><code>Vue.nextTick( [callback, context] )</code><br>参数：</p>\n<p><code>&#123;Function&#125; [callback]</code><br><code>&#123;Object&#125; [context]</code><br>用法：</p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修改数据</span><br><span class=\"line\">vm.msg = &#x27;Hello&#x27;</span><br><span class=\"line\">// DOM 还没有更新</span><br><span class=\"line\">Vue.nextTick(function () &#123;</span><br><span class=\"line\">  // DOM 更新了</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span><br><span class=\"line\">Vue.nextTick()</span><br><span class=\"line\">  .then(function () &#123;</span><br><span class=\"line\">    // DOM 更新了</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p>\n<h2 id=\"异步更新队列\"><a href=\"#异步更新队列\" class=\"headerlink\" title=\"异步更新队列\"></a>异步更新队列</h2><p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &#x27;123&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">vm.message = &#x27;new message&#x27; // 更改数据</span><br><span class=\"line\">vm.$el.textContent === &#x27;new message&#x27; // false</span><br><span class=\"line\">Vue.nextTick(function () &#123;</span><br><span class=\"line\">  vm.$el.textContent === &#x27;new message&#x27; // true</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;example&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: &#x27;未更新&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateMessage: function () &#123;</span><br><span class=\"line\">      this.message = &#x27;已更新&#x27;</span><br><span class=\"line\">      console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class=\"line\">      this.$nextTick(function () &#123;</span><br><span class=\"line\">        console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\">ES2017 async/await</a> 语法完成相同的事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  updateMessage: async function () &#123;</span><br><span class=\"line\">    this.message = &#x27;已更新&#x27;</span><br><span class=\"line\">    console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class=\"line\">    await this.$nextTick()</span><br><span class=\"line\">    console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"关于nextTick\"><a href=\"#关于nextTick\" class=\"headerlink\" title=\"关于nextTick\"></a>关于nextTick</h1><p>在Vue2.4-2.6版本中中，nextTick反复变动，其原因最终是因为浏览器对于微任务的不兼容，并且宏任务与微任务各有优劣，Vue也是在不断取舍。nextTick主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"官方文档\"><a href=\"#官方文档\" class=\"headerlink\" title=\"官方文档\"></a>官方文档</h1><p><code>Vue.nextTick( [callback, context] )</code><br>参数：</p>\n<p><code>&#123;Function&#125; [callback]</code><br><code>&#123;Object&#125; [context]</code><br>用法：</p>\n<p>在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 修改数据</span><br><span class=\"line\">vm.msg = &#x27;Hello&#x27;</span><br><span class=\"line\">// DOM 还没有更新</span><br><span class=\"line\">Vue.nextTick(function () &#123;</span><br><span class=\"line\">  // DOM 更新了</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)</span><br><span class=\"line\">Vue.nextTick()</span><br><span class=\"line\">  .then(function () &#123;</span><br><span class=\"line\">    // DOM 更新了</span><br><span class=\"line\">  &#125;)</span><br></pre></td></tr></table></figure>\n\n<p>2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。</p>\n<h2 id=\"异步更新队列\"><a href=\"#异步更新队列\" class=\"headerlink\" title=\"异步更新队列\"></a>异步更新队列</h2><p>可能你还没有注意到，Vue 在更新 DOM 时是<strong>异步</strong>执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 <code>Promise.then</code>、<code>MutationObserver</code> 和 <code>setImmediate</code>，如果执行环境不支持，则会采用 <code>setTimeout(fn, 0)</code> 代替。</p>\n<p>例如，当你设置 <code>vm.someData = &#39;new value&#39;</code>，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 <code>Vue.nextTick(callback)</code>。这样回调函数将在 DOM 更新完成后被调用。例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;example&quot;&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">var vm = new Vue(&#123;</span><br><span class=\"line\">  el: &#x27;#example&#x27;,</span><br><span class=\"line\">  data: &#123;</span><br><span class=\"line\">    message: &#x27;123&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">vm.message = &#x27;new message&#x27; // 更改数据</span><br><span class=\"line\">vm.$el.textContent === &#x27;new message&#x27; // false</span><br><span class=\"line\">Vue.nextTick(function () &#123;</span><br><span class=\"line\">  vm.$el.textContent === &#x27;new message&#x27; // true</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>在组件内使用 <code>vm.$nextTick()</code> 实例方法特别方便，因为它不需要全局 <code>Vue</code>，并且回调函数中的 <code>this</code> 将自动绑定到当前的 Vue 实例上：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vue.component(&#x27;example&#x27;, &#123;</span><br><span class=\"line\">  template: &#x27;&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;&#x27;,</span><br><span class=\"line\">  data: function () &#123;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">      message: &#x27;未更新&#x27;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    updateMessage: function () &#123;</span><br><span class=\"line\">      this.message = &#x27;已更新&#x27;</span><br><span class=\"line\">      console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class=\"line\">      this.$nextTick(function () &#123;</span><br><span class=\"line\">        console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<p>因为 <code>$nextTick()</code> 返回一个 <code>Promise</code> 对象，所以你可以使用新的 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function\">ES2017 async/await</a> 语法完成相同的事情：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  updateMessage: async function () &#123;</span><br><span class=\"line\">    this.message = &#x27;已更新&#x27;</span><br><span class=\"line\">    console.log(this.$el.textContent) // =&gt; &#x27;未更新&#x27;</span><br><span class=\"line\">    await this.$nextTick()</span><br><span class=\"line\">    console.log(this.$el.textContent) // =&gt; &#x27;已更新&#x27;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"关于nextTick\"><a href=\"#关于nextTick\" class=\"headerlink\" title=\"关于nextTick\"></a>关于nextTick</h1><p>在Vue2.4-2.6版本中中，nextTick反复变动，其原因最终是因为浏览器对于微任务的不兼容，并且宏任务与微任务各有优劣，Vue也是在不断取舍。nextTick主要是处理我们再变更完数据以后，无法立刻拿到最新的DOM节点对象的问题。</p>\n"},{"title":"HTML：语义化标签","copyright":false,"date":"2022-03-10T22:09:33.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110614854.webp","_content":"\n# 语义化标签是什么\n\n想知道语义化标签是什么，先要知道语义化标签不是什么。\n\n早年间的HTML文档基本上都是通过`<Table>`和`<div>`写的，因为前后端并未分离，因此并未有特别完善的标准。随着前后端分离的大势可趋，随之而来的便是标准化的标签规范：也就是语义化标签。\n\n语义化标签说白了，就是提升代码可读性，用同一的命名标准去规范不同网页中相似的结构，然后再以这套标准来编写新的网页。\n\n- **头部：header**\n- **导航：nav**\n- **主体内容：main**\n- **标题：h1 ~ h6**\n- **段落：p**\n- **侧边栏：aside**\n- **页脚：footer**\n\n这使得HTML的结构清晰，易读性远胜非语义化标签。\n\n# 语义化标签的优点\n\n1. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。\n\n2. 使代码更具可读性，便于团队开发和维护。\n\n3. 提升用户体验，例如title、alt可用于解释名词或解释图片信息。\n\n4. 网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。\n\n   \n","source":"_posts/HTML：语义化标签.md","raw":"---\ntitle: HTML：语义化标签\ncopyright: false\ndate: 2022-03-11 06:09:33\ntags: HTML\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110614854.webp\"\ncategories:\n  - [技术,HTML]\n---\n\n# 语义化标签是什么\n\n想知道语义化标签是什么，先要知道语义化标签不是什么。\n\n早年间的HTML文档基本上都是通过`<Table>`和`<div>`写的，因为前后端并未分离，因此并未有特别完善的标准。随着前后端分离的大势可趋，随之而来的便是标准化的标签规范：也就是语义化标签。\n\n语义化标签说白了，就是提升代码可读性，用同一的命名标准去规范不同网页中相似的结构，然后再以这套标准来编写新的网页。\n\n- **头部：header**\n- **导航：nav**\n- **主体内容：main**\n- **标题：h1 ~ h6**\n- **段落：p**\n- **侧边栏：aside**\n- **页脚：footer**\n\n这使得HTML的结构清晰，易读性远胜非语义化标签。\n\n# 语义化标签的优点\n\n1. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。\n\n2. 使代码更具可读性，便于团队开发和维护。\n\n3. 提升用户体验，例如title、alt可用于解释名词或解释图片信息。\n\n4. 网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。\n\n   \n","slug":"HTML：语义化标签","published":1,"updated":"2022-03-10T22:14:09.593Z","_id":"cl0ljlz7a0006j0uh9gv0eyal","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"语义化标签是什么\"><a href=\"#语义化标签是什么\" class=\"headerlink\" title=\"语义化标签是什么\"></a>语义化标签是什么</h1><p>想知道语义化标签是什么，先要知道语义化标签不是什么。</p>\n<p>早年间的HTML文档基本上都是通过<code>&lt;Table&gt;</code>和<code>&lt;div&gt;</code>写的，因为前后端并未分离，因此并未有特别完善的标准。随着前后端分离的大势可趋，随之而来的便是标准化的标签规范：也就是语义化标签。</p>\n<p>语义化标签说白了，就是提升代码可读性，用同一的命名标准去规范不同网页中相似的结构，然后再以这套标准来编写新的网页。</p>\n<ul>\n<li><strong>头部：header</strong></li>\n<li><strong>导航：nav</strong></li>\n<li><strong>主体内容：main</strong></li>\n<li><strong>标题：h1 ~ h6</strong></li>\n<li><strong>段落：p</strong></li>\n<li><strong>侧边栏：aside</strong></li>\n<li><strong>页脚：footer</strong></li>\n</ul>\n<p>这使得HTML的结构清晰，易读性远胜非语义化标签。</p>\n<h1 id=\"语义化标签的优点\"><a href=\"#语义化标签的优点\" class=\"headerlink\" title=\"语义化标签的优点\"></a>语义化标签的优点</h1><ol>\n<li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。</p>\n</li>\n<li><p>使代码更具可读性，便于团队开发和维护。</p>\n</li>\n<li><p>提升用户体验，例如title、alt可用于解释名词或解释图片信息。</p>\n</li>\n<li><p>网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"语义化标签是什么\"><a href=\"#语义化标签是什么\" class=\"headerlink\" title=\"语义化标签是什么\"></a>语义化标签是什么</h1><p>想知道语义化标签是什么，先要知道语义化标签不是什么。</p>\n<p>早年间的HTML文档基本上都是通过<code>&lt;Table&gt;</code>和<code>&lt;div&gt;</code>写的，因为前后端并未分离，因此并未有特别完善的标准。随着前后端分离的大势可趋，随之而来的便是标准化的标签规范：也就是语义化标签。</p>\n<p>语义化标签说白了，就是提升代码可读性，用同一的命名标准去规范不同网页中相似的结构，然后再以这套标准来编写新的网页。</p>\n<ul>\n<li><strong>头部：header</strong></li>\n<li><strong>导航：nav</strong></li>\n<li><strong>主体内容：main</strong></li>\n<li><strong>标题：h1 ~ h6</strong></li>\n<li><strong>段落：p</strong></li>\n<li><strong>侧边栏：aside</strong></li>\n<li><strong>页脚：footer</strong></li>\n</ul>\n<p>这使得HTML的结构清晰，易读性远胜非语义化标签。</p>\n<h1 id=\"语义化标签的优点\"><a href=\"#语义化标签的优点\" class=\"headerlink\" title=\"语义化标签的优点\"></a>语义化标签的优点</h1><ol>\n<li><p>有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息。</p>\n</li>\n<li><p>使代码更具可读性，便于团队开发和维护。</p>\n</li>\n<li><p>提升用户体验，例如title、alt可用于解释名词或解释图片信息。</p>\n</li>\n<li><p>网页加载慢导致CSS文件还未加载时（没有CSS），页面仍然清晰、可读、好看。</p>\n</li>\n</ol>\n"},{"title":"JavaScript：防抖和节流","copyright":false,"date":"2022-03-10T22:31:57.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110633288.webp","_content":"\n# 防抖和节流解决的问题\n\n举一个例子，如果有一个按钮，效果是向后端请求数据。用户不断点击，难道要向不断向后端请求数据吗？\n\n不论后端的压力，单论必要性都是要打问号的。防抖和节流就是为了解决这个问题的：短时间的重复请求。\n\n# 防抖（debounce）\n\n防抖就是：**当一个函数连续触发，只执行最后一次。**\n\n当连续的事件却只需要触发一次的情况下，我们会使用防抖，具体实现的原理类似于设置一个定时器，当再次触发的时候清除前一个定时器，只有在一定时间内没有再次触发事件才会执行。\n\n## 代码实现\n\n```\nfunction debounce(fn, delay) {\n  // timer是一个定时器\n  let timer = null;\n  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器\n  return function () {\n    // 调用一次就清除上一次的定时器\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn();\n    }, delay)\n  }\n```\n\n# 节流（throttle）\n\n节流就是：**当一个函数被触发，经过一定时间才执行下一个。**\n\n有一次我将节流和防抖记混了，就这么和别人说的：在容器里放一个定时器，当函数执行的之前先看看这个容器里有没有定时器，如果有就不执行函数，直到定时器触发完。\n\n## 代码实现\n\n```\nfunction throttle(fn, delay) {\n  // 重置定时器\n  let timer = null;\n  // 返回闭包函数\n  return function () {\n    // 记录事件参数\n    let args = arguments;\n    // 如果定时器为空\n    if (!timer) {\n      // 开启定时器\n      timer = setTimeout(() => {\n        // 执行函数\n        fn.apply(this, args);\n        // 函数执行完毕后重置定时器\n        timer = null;\n      }, delay);\n    }\n  }\n}\n```\n\n代码这里实现的方式其实分成首节流和尾节流，一个是利用时间戳在函数头设置节流器，另一个便是上面写的这个。\n","source":"_posts/JavaScript：防抖和节流.md","raw":"---\ntitle: JavaScript：防抖和节流\ncopyright: false\ndate: 2022-03-11 06:31:57\ntags: JavaScript\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110633288.webp\"\ncategories:\n  - [技术,JavaScript]\n---\n\n# 防抖和节流解决的问题\n\n举一个例子，如果有一个按钮，效果是向后端请求数据。用户不断点击，难道要向不断向后端请求数据吗？\n\n不论后端的压力，单论必要性都是要打问号的。防抖和节流就是为了解决这个问题的：短时间的重复请求。\n\n# 防抖（debounce）\n\n防抖就是：**当一个函数连续触发，只执行最后一次。**\n\n当连续的事件却只需要触发一次的情况下，我们会使用防抖，具体实现的原理类似于设置一个定时器，当再次触发的时候清除前一个定时器，只有在一定时间内没有再次触发事件才会执行。\n\n## 代码实现\n\n```\nfunction debounce(fn, delay) {\n  // timer是一个定时器\n  let timer = null;\n  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器\n  return function () {\n    // 调用一次就清除上一次的定时器\n    clearTimeout(timer);\n    timer = setTimeout(() => {\n      fn();\n    }, delay)\n  }\n```\n\n# 节流（throttle）\n\n节流就是：**当一个函数被触发，经过一定时间才执行下一个。**\n\n有一次我将节流和防抖记混了，就这么和别人说的：在容器里放一个定时器，当函数执行的之前先看看这个容器里有没有定时器，如果有就不执行函数，直到定时器触发完。\n\n## 代码实现\n\n```\nfunction throttle(fn, delay) {\n  // 重置定时器\n  let timer = null;\n  // 返回闭包函数\n  return function () {\n    // 记录事件参数\n    let args = arguments;\n    // 如果定时器为空\n    if (!timer) {\n      // 开启定时器\n      timer = setTimeout(() => {\n        // 执行函数\n        fn.apply(this, args);\n        // 函数执行完毕后重置定时器\n        timer = null;\n      }, delay);\n    }\n  }\n}\n```\n\n代码这里实现的方式其实分成首节流和尾节流，一个是利用时间戳在函数头设置节流器，另一个便是上面写的这个。\n","slug":"JavaScript：防抖和节流","published":1,"updated":"2022-03-10T22:33:45.775Z","_id":"cl0lkesdc000cj0uhcmvfdvqk","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"防抖和节流解决的问题\"><a href=\"#防抖和节流解决的问题\" class=\"headerlink\" title=\"防抖和节流解决的问题\"></a>防抖和节流解决的问题</h1><p>举一个例子，如果有一个按钮，效果是向后端请求数据。用户不断点击，难道要向不断向后端请求数据吗？</p>\n<p>不论后端的压力，单论必要性都是要打问号的。防抖和节流就是为了解决这个问题的：短时间的重复请求。</p>\n<h1 id=\"防抖（debounce）\"><a href=\"#防抖（debounce）\" class=\"headerlink\" title=\"防抖（debounce）\"></a>防抖（debounce）</h1><p>防抖就是：<strong>当一个函数连续触发，只执行最后一次。</strong></p>\n<p>当连续的事件却只需要触发一次的情况下，我们会使用防抖，具体实现的原理类似于设置一个定时器，当再次触发的时候清除前一个定时器，只有在一定时间内没有再次触发事件才会执行。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay) &#123;</span><br><span class=\"line\">  // timer是一个定时器</span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\">  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    // 调用一次就清除上一次的定时器</span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      fn();</span><br><span class=\"line\">    &#125;, delay)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h1><p>节流就是：<strong>当一个函数被触发，经过一定时间才执行下一个。</strong></p>\n<p>有一次我将节流和防抖记混了，就这么和别人说的：在容器里放一个定时器，当函数执行的之前先看看这个容器里有没有定时器，如果有就不执行函数，直到定时器触发完。</p>\n<h2 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, delay) &#123;</span><br><span class=\"line\">  // 重置定时器</span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\">  // 返回闭包函数</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    // 记录事件参数</span><br><span class=\"line\">    let args = arguments;</span><br><span class=\"line\">    // 如果定时器为空</span><br><span class=\"line\">    if (!timer) &#123;</span><br><span class=\"line\">      // 开启定时器</span><br><span class=\"line\">      timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 执行函数</span><br><span class=\"line\">        fn.apply(this, args);</span><br><span class=\"line\">        // 函数执行完毕后重置定时器</span><br><span class=\"line\">        timer = null;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码这里实现的方式其实分成首节流和尾节流，一个是利用时间戳在函数头设置节流器，另一个便是上面写的这个。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"防抖和节流解决的问题\"><a href=\"#防抖和节流解决的问题\" class=\"headerlink\" title=\"防抖和节流解决的问题\"></a>防抖和节流解决的问题</h1><p>举一个例子，如果有一个按钮，效果是向后端请求数据。用户不断点击，难道要向不断向后端请求数据吗？</p>\n<p>不论后端的压力，单论必要性都是要打问号的。防抖和节流就是为了解决这个问题的：短时间的重复请求。</p>\n<h1 id=\"防抖（debounce）\"><a href=\"#防抖（debounce）\" class=\"headerlink\" title=\"防抖（debounce）\"></a>防抖（debounce）</h1><p>防抖就是：<strong>当一个函数连续触发，只执行最后一次。</strong></p>\n<p>当连续的事件却只需要触发一次的情况下，我们会使用防抖，具体实现的原理类似于设置一个定时器，当再次触发的时候清除前一个定时器，只有在一定时间内没有再次触发事件才会执行。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay) &#123;</span><br><span class=\"line\">  // timer是一个定时器</span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\">  // 返回一个闭包函数，用闭包保存timer确保其不会销毁，重复点击会清理上一次的定时器</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    // 调用一次就清除上一次的定时器</span><br><span class=\"line\">    clearTimeout(timer);</span><br><span class=\"line\">    timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">      fn();</span><br><span class=\"line\">    &#125;, delay)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"节流（throttle）\"><a href=\"#节流（throttle）\" class=\"headerlink\" title=\"节流（throttle）\"></a>节流（throttle）</h1><p>节流就是：<strong>当一个函数被触发，经过一定时间才执行下一个。</strong></p>\n<p>有一次我将节流和防抖记混了，就这么和别人说的：在容器里放一个定时器，当函数执行的之前先看看这个容器里有没有定时器，如果有就不执行函数，直到定时器触发完。</p>\n<h2 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, delay) &#123;</span><br><span class=\"line\">  // 重置定时器</span><br><span class=\"line\">  let timer = null;</span><br><span class=\"line\">  // 返回闭包函数</span><br><span class=\"line\">  return function () &#123;</span><br><span class=\"line\">    // 记录事件参数</span><br><span class=\"line\">    let args = arguments;</span><br><span class=\"line\">    // 如果定时器为空</span><br><span class=\"line\">    if (!timer) &#123;</span><br><span class=\"line\">      // 开启定时器</span><br><span class=\"line\">      timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">        // 执行函数</span><br><span class=\"line\">        fn.apply(this, args);</span><br><span class=\"line\">        // 函数执行完毕后重置定时器</span><br><span class=\"line\">        timer = null;</span><br><span class=\"line\">      &#125;, delay);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码这里实现的方式其实分成首节流和尾节流，一个是利用时间戳在函数头设置节流器，另一个便是上面写的这个。</p>\n"},{"title":"Vue：Keep-alive标签与它的生命周期钩子","copyright":false,"date":"2022-03-10T22:51:54.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110653375.webp","_content":"\n# Keep-alive释义\n\n当我们使用路由的时候，在不同的组件之间切换，这些组件其实在不断经历被创建、被销毁的过程。某些情况下，我们并不希望组件被销毁，或是我们希望保留一些data在我们切换组件之后。为了解决这个问题，我们可以用一个 `<keep-alive>` 元素将其动态组件包裹起来。\n\n```\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n- 注意这个 `<keep-alive>` 要求被切换到的组件都有自己的名字，不论是通过组件的 `name` 选项还是局部/全局注册。\n\n## 它是什么\n\n- `keep-alive`是一个`Vue全局组件`\n- `keep-alive`本身不会渲染出来，也不会出现在父组件链中\n- `keep-alive`包裹动态组件时，会缓存不活动的组件，而不是销毁它们\n\n## 它的用法\n\n- [keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)\n\n  - **Props**：\n\n    - `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。\n    - `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。\n    - `max` - 数字。最多可以缓存多少组件实例。\n\n  - **用法**：\n\n    `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n\n    当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n# 扯点别的：Vue的渲染方式\n\n在编译结束之后，vue开始渲染各个组件。\n\n- `render`：此函数会将组件转成`VNode`\n- `patch`：此函数在初次渲染时会直接渲染根据拿到的`VNode`直接渲染成`真实DOM`，第二次渲染开始就会拿`VNode`会跟`旧VNode`对比，打补丁（diff算法对比发生在此阶段），然后渲染成`真实DOM`\n\n那么，Keep-alive是如何渲染的呢？\n\n`keep-alive`自身组件不会被渲染到页面上，换言之，它不会生成真正的DOM节点。它通过判断组件实例上的`abstract`的属性值，如果是`true`的话，就跳过该实例，该实例也不会出现在父级链上。\n\n> 在 2.2.0 及其更高版本中，`activated` 和 `deactivated` 将会在 `<keep-alive>` 树内的所有嵌套组件中触发。\n\n**`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。**\n\n# 相关的两个生命周期钩子\n\n### activated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用**\n\n### deactivated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件失活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n","source":"_posts/Vue：Keep-alive标签与它的生命周期钩子.md","raw":"---\ntitle: Vue：Keep-alive标签与它的生命周期钩子\ncopyright: false\ndate: 2022-03-11 06:51:54\ntags: Vue\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203110653375.webp\"\ncategories:\n  - [技术,Vue]\n---\n\n# Keep-alive释义\n\n当我们使用路由的时候，在不同的组件之间切换，这些组件其实在不断经历被创建、被销毁的过程。某些情况下，我们并不希望组件被销毁，或是我们希望保留一些data在我们切换组件之后。为了解决这个问题，我们可以用一个 `<keep-alive>` 元素将其动态组件包裹起来。\n\n```\n<!-- 失活的组件将会被缓存！-->\n<keep-alive>\n  <component v-bind:is=\"currentTabComponent\"></component>\n</keep-alive>\n```\n\n- 注意这个 `<keep-alive>` 要求被切换到的组件都有自己的名字，不论是通过组件的 `name` 选项还是局部/全局注册。\n\n## 它是什么\n\n- `keep-alive`是一个`Vue全局组件`\n- `keep-alive`本身不会渲染出来，也不会出现在父组件链中\n- `keep-alive`包裹动态组件时，会缓存不活动的组件，而不是销毁它们\n\n## 它的用法\n\n- [keep-alive](https://cn.vuejs.org/v2/api/#keep-alive)\n\n  - **Props**：\n\n    - `include` - 字符串或正则表达式。只有名称匹配的组件会被缓存。\n    - `exclude` - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。\n    - `max` - 数字。最多可以缓存多少组件实例。\n\n  - **用法**：\n\n    `<keep-alive>` 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 `<transition>` 相似，`<keep-alive>` 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。\n\n    当组件在 `<keep-alive>` 内被切换，它的 `activated` 和 `deactivated` 这两个生命周期钩子函数将会被对应执行。\n\n# 扯点别的：Vue的渲染方式\n\n在编译结束之后，vue开始渲染各个组件。\n\n- `render`：此函数会将组件转成`VNode`\n- `patch`：此函数在初次渲染时会直接渲染根据拿到的`VNode`直接渲染成`真实DOM`，第二次渲染开始就会拿`VNode`会跟`旧VNode`对比，打补丁（diff算法对比发生在此阶段），然后渲染成`真实DOM`\n\n那么，Keep-alive是如何渲染的呢？\n\n`keep-alive`自身组件不会被渲染到页面上，换言之，它不会生成真正的DOM节点。它通过判断组件实例上的`abstract`的属性值，如果是`true`的话，就跳过该实例，该实例也不会出现在父级链上。\n\n> 在 2.2.0 及其更高版本中，`activated` 和 `deactivated` 将会在 `<keep-alive>` 树内的所有嵌套组件中触发。\n\n**`<keep-alive>` 不会在函数式组件中正常工作，因为它们没有缓存实例。**\n\n# 相关的两个生命周期钩子\n\n### activated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件激活时调用。\n\n  **该钩子在服务器端渲染期间不被调用**\n\n### deactivated\n\n- **类型**：`Function`\n\n- **详细**：\n\n  被 keep-alive 缓存的组件失活时调用。\n\n  **该钩子在服务器端渲染期间不被调用。**\n","slug":"Vue：Keep-alive标签与它的生命周期钩子","published":1,"updated":"2022-03-10T22:53:45.078Z","_id":"cl0ll4fj5000gj0uh2szrfuus","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Keep-alive释义\"><a href=\"#Keep-alive释义\" class=\"headerlink\" title=\"Keep-alive释义\"></a>Keep-alive释义</h1><p>当我们使用路由的时候，在不同的组件之间切换，这些组件其实在不断经历被创建、被销毁的过程。某些情况下，我们并不希望组件被销毁，或是我们希望保留一些data在我们切换组件之后。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部/全局注册。</li>\n</ul>\n<h2 id=\"它是什么\"><a href=\"#它是什么\" class=\"headerlink\" title=\"它是什么\"></a>它是什么</h2><ul>\n<li><code>keep-alive</code>是一个<code>Vue全局组件</code></li>\n<li><code>keep-alive</code>本身不会渲染出来，也不会出现在父组件链中</li>\n<li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件，而不是销毁它们</li>\n</ul>\n<h2 id=\"它的用法\"><a href=\"#它的用法\" class=\"headerlink\" title=\"它的用法\"></a>它的用法</h2><ul>\n<li><p><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive</a></p>\n<ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>\n<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>\n<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"扯点别的：Vue的渲染方式\"><a href=\"#扯点别的：Vue的渲染方式\" class=\"headerlink\" title=\"扯点别的：Vue的渲染方式\"></a>扯点别的：Vue的渲染方式</h1><p>在编译结束之后，vue开始渲染各个组件。</p>\n<ul>\n<li><code>render</code>：此函数会将组件转成<code>VNode</code></li>\n<li><code>patch</code>：此函数在初次渲染时会直接渲染根据拿到的<code>VNode</code>直接渲染成<code>真实DOM</code>，第二次渲染开始就会拿<code>VNode</code>会跟<code>旧VNode</code>对比，打补丁（diff算法对比发生在此阶段），然后渲染成<code>真实DOM</code></li>\n</ul>\n<p>那么，Keep-alive是如何渲染的呢？</p>\n<p><code>keep-alive</code>自身组件不会被渲染到页面上，换言之，它不会生成真正的DOM节点。它通过判断组件实例上的<code>abstract</code>的属性值，如果是<code>true</code>的话，就跳过该实例，该实例也不会出现在父级链上。</p>\n<blockquote>\n<p>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 <code>&lt;keep-alive&gt;</code> 树内的所有嵌套组件中触发。</p>\n</blockquote>\n<p><strong><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</strong></p>\n<h1 id=\"相关的两个生命周期钩子\"><a href=\"#相关的两个生命周期钩子\" class=\"headerlink\" title=\"相关的两个生命周期钩子\"></a>相关的两个生命周期钩子</h1><h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件失活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Keep-alive释义\"><a href=\"#Keep-alive释义\" class=\"headerlink\" title=\"Keep-alive释义\"></a>Keep-alive释义</h1><p>当我们使用路由的时候，在不同的组件之间切换，这些组件其实在不断经历被创建、被销毁的过程。某些情况下，我们并不希望组件被销毁，或是我们希望保留一些data在我们切换组件之后。为了解决这个问题，我们可以用一个 <code>&lt;keep-alive&gt;</code> 元素将其动态组件包裹起来。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 失活的组件将会被缓存！--&gt;</span><br><span class=\"line\">&lt;keep-alive&gt;</span><br><span class=\"line\">  &lt;component v-bind:is=&quot;currentTabComponent&quot;&gt;&lt;/component&gt;</span><br><span class=\"line\">&lt;/keep-alive&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意这个 <code>&lt;keep-alive&gt;</code> 要求被切换到的组件都有自己的名字，不论是通过组件的 <code>name</code> 选项还是局部/全局注册。</li>\n</ul>\n<h2 id=\"它是什么\"><a href=\"#它是什么\" class=\"headerlink\" title=\"它是什么\"></a>它是什么</h2><ul>\n<li><code>keep-alive</code>是一个<code>Vue全局组件</code></li>\n<li><code>keep-alive</code>本身不会渲染出来，也不会出现在父组件链中</li>\n<li><code>keep-alive</code>包裹动态组件时，会缓存不活动的组件，而不是销毁它们</li>\n</ul>\n<h2 id=\"它的用法\"><a href=\"#它的用法\" class=\"headerlink\" title=\"它的用法\"></a>它的用法</h2><ul>\n<li><p><a href=\"https://cn.vuejs.org/v2/api/#keep-alive\">keep-alive</a></p>\n<ul>\n<li><p><strong>Props</strong>：</p>\n<ul>\n<li><code>include</code> - 字符串或正则表达式。只有名称匹配的组件会被缓存。</li>\n<li><code>exclude</code> - 字符串或正则表达式。任何名称匹配的组件都不会被缓存。</li>\n<li><code>max</code> - 数字。最多可以缓存多少组件实例。</li>\n</ul>\n</li>\n<li><p><strong>用法</strong>：</p>\n<p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。</p>\n<p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 <code>activated</code> 和 <code>deactivated</code> 这两个生命周期钩子函数将会被对应执行。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"扯点别的：Vue的渲染方式\"><a href=\"#扯点别的：Vue的渲染方式\" class=\"headerlink\" title=\"扯点别的：Vue的渲染方式\"></a>扯点别的：Vue的渲染方式</h1><p>在编译结束之后，vue开始渲染各个组件。</p>\n<ul>\n<li><code>render</code>：此函数会将组件转成<code>VNode</code></li>\n<li><code>patch</code>：此函数在初次渲染时会直接渲染根据拿到的<code>VNode</code>直接渲染成<code>真实DOM</code>，第二次渲染开始就会拿<code>VNode</code>会跟<code>旧VNode</code>对比，打补丁（diff算法对比发生在此阶段），然后渲染成<code>真实DOM</code></li>\n</ul>\n<p>那么，Keep-alive是如何渲染的呢？</p>\n<p><code>keep-alive</code>自身组件不会被渲染到页面上，换言之，它不会生成真正的DOM节点。它通过判断组件实例上的<code>abstract</code>的属性值，如果是<code>true</code>的话，就跳过该实例，该实例也不会出现在父级链上。</p>\n<blockquote>\n<p>在 2.2.0 及其更高版本中，<code>activated</code> 和 <code>deactivated</code> 将会在 <code>&lt;keep-alive&gt;</code> 树内的所有嵌套组件中触发。</p>\n</blockquote>\n<p><strong><code>&lt;keep-alive&gt;</code> 不会在函数式组件中正常工作，因为它们没有缓存实例。</strong></p>\n<h1 id=\"相关的两个生命周期钩子\"><a href=\"#相关的两个生命周期钩子\" class=\"headerlink\" title=\"相关的两个生命周期钩子\"></a>相关的两个生命周期钩子</h1><h3 id=\"activated\"><a href=\"#activated\" class=\"headerlink\" title=\"activated\"></a>activated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件激活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用</strong></p>\n</li>\n</ul>\n<h3 id=\"deactivated\"><a href=\"#deactivated\" class=\"headerlink\" title=\"deactivated\"></a>deactivated</h3><ul>\n<li><p><strong>类型</strong>：<code>Function</code></p>\n</li>\n<li><p><strong>详细</strong>：</p>\n<p>被 keep-alive 缓存的组件失活时调用。</p>\n<p><strong>该钩子在服务器端渲染期间不被调用。</strong></p>\n</li>\n</ul>\n"},{"title":"算法：寻找最长斐波那契数列","copyright":false,"date":"2022-03-13T14:58:01.000Z","cover":"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203132304094.webp","_content":"\n实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段。 \n\n比如[13, 9, 3, 8, 5, 25, 31, 11, 21]， 输出[3, 5, 8, 13, 21]\n\n```\nfunction findFibonacci(arr){\n\n  //生成fib数组，可能会涉及边界问题，但这样快一点\n\n  var fib = []\n\n  let n = 1;\n\n  for(let i =0 ; i<100 ; i++){\n\n​    if(fib.length<2)fib.push(n)\n\n​    if(fib.length>=2){\n\n​      fib.push(fib[i]+fib[i-1])\n\n​    }\n\n​    \n\n  }\n\n  //过滤输入数组中不是fib数组内的数\n\n  var arr = arr.filter(i =>{\n\n​    if(fib.includes(i))return i \n\n  })\n\n  arr.sort(function(a,b){return a-b})\n\n  length = arr.length\n\n  let FibNum = [];\n\n  //生成新数组并返回\n\n  for (let i = 0; i < length; i++) {\n\n​    let target = fib.indexOf(arr[i]);\n\n​    // console.log(target,fib[target],arr[i]);\n\n​    if(fib[target]==arr[i])FibNum.push(arr[i]);\n\n​    if(fib[target]!=arr[i])break;\n\n  }\n\n  return FibNum\n\n}\n```\n\n当然这个方式存在大索引的fib边界问题，更好的实现应该是：\n\n```\nfunction findeFibonacci(arr) {\nvar arr1 = arr.sort(function(a, b) {\n    return a-b;\n})\nvar tempArr = [];\ntempArr.push(arr1[0], arr[1])\nfor(var i=2; i<arr1.length;i++) {\n    if(arr1[i] == arr1[i-2] + arr1[i-1]) {\n        tempArr.push(arr1[i])\n    } else {\n        arr1.splice(i, 1)\n        arr1 = arr1\n        i--;\n    }\n}\nreturn tempArr;\n}\n```\n\n","source":"_posts/算法：寻找最长斐波那契数列.md","raw":"---\ntitle: 算法：寻找最长斐波那契数列\ncopyright: false\ndate: 2022-03-13 22:58:01\ntags: JavaScript,算法\ncover: \"https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203132304094.webp\"\ncategories:\n  - [技术,算法]\n---\n\n实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段。 \n\n比如[13, 9, 3, 8, 5, 25, 31, 11, 21]， 输出[3, 5, 8, 13, 21]\n\n```\nfunction findFibonacci(arr){\n\n  //生成fib数组，可能会涉及边界问题，但这样快一点\n\n  var fib = []\n\n  let n = 1;\n\n  for(let i =0 ; i<100 ; i++){\n\n​    if(fib.length<2)fib.push(n)\n\n​    if(fib.length>=2){\n\n​      fib.push(fib[i]+fib[i-1])\n\n​    }\n\n​    \n\n  }\n\n  //过滤输入数组中不是fib数组内的数\n\n  var arr = arr.filter(i =>{\n\n​    if(fib.includes(i))return i \n\n  })\n\n  arr.sort(function(a,b){return a-b})\n\n  length = arr.length\n\n  let FibNum = [];\n\n  //生成新数组并返回\n\n  for (let i = 0; i < length; i++) {\n\n​    let target = fib.indexOf(arr[i]);\n\n​    // console.log(target,fib[target],arr[i]);\n\n​    if(fib[target]==arr[i])FibNum.push(arr[i]);\n\n​    if(fib[target]!=arr[i])break;\n\n  }\n\n  return FibNum\n\n}\n```\n\n当然这个方式存在大索引的fib边界问题，更好的实现应该是：\n\n```\nfunction findeFibonacci(arr) {\nvar arr1 = arr.sort(function(a, b) {\n    return a-b;\n})\nvar tempArr = [];\ntempArr.push(arr1[0], arr[1])\nfor(var i=2; i<arr1.length;i++) {\n    if(arr1[i] == arr1[i-2] + arr1[i-1]) {\n        tempArr.push(arr1[i])\n    } else {\n        arr1.splice(i, 1)\n        arr1 = arr1\n        i--;\n    }\n}\nreturn tempArr;\n}\n```\n\n","slug":"算法：寻找最长斐波那契数列","published":1,"updated":"2022-03-13T15:05:23.555Z","_id":"cl0perjl100002ouh1p2raun4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段。 </p>\n<p>比如[13, 9, 3, 8, 5, 25, 31, 11, 21]， 输出[3, 5, 8, 13, 21]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function findFibonacci(arr)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  //生成fib数组，可能会涉及边界问题，但这样快一点</span><br><span class=\"line\"></span><br><span class=\"line\">  var fib = []</span><br><span class=\"line\"></span><br><span class=\"line\">  let n = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">  for(let i =0 ; i&lt;100 ; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.length&lt;2)fib.push(n)</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.length&gt;=2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​      fib.push(fib[i]+fib[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">​    </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //过滤输入数组中不是fib数组内的数</span><br><span class=\"line\"></span><br><span class=\"line\">  var arr = arr.filter(i =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.includes(i))return i </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.sort(function(a,b)&#123;return a-b&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  length = arr.length</span><br><span class=\"line\"></span><br><span class=\"line\">  let FibNum = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  //生成新数组并返回</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    let target = fib.indexOf(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    // console.log(target,fib[target],arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib[target]==arr[i])FibNum.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib[target]!=arr[i])break;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return FibNum</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这个方式存在大索引的fib边界问题，更好的实现应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function findeFibonacci(arr) &#123;</span><br><span class=\"line\">var arr1 = arr.sort(function(a, b) &#123;</span><br><span class=\"line\">    return a-b;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var tempArr = [];</span><br><span class=\"line\">tempArr.push(arr1[0], arr[1])</span><br><span class=\"line\">for(var i=2; i&lt;arr1.length;i++) &#123;</span><br><span class=\"line\">    if(arr1[i] == arr1[i-2] + arr1[i-1]) &#123;</span><br><span class=\"line\">        tempArr.push(arr1[i])</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        arr1.splice(i, 1)</span><br><span class=\"line\">        arr1 = arr1</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return tempArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段。 </p>\n<p>比如[13, 9, 3, 8, 5, 25, 31, 11, 21]， 输出[3, 5, 8, 13, 21]</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function findFibonacci(arr)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  //生成fib数组，可能会涉及边界问题，但这样快一点</span><br><span class=\"line\"></span><br><span class=\"line\">  var fib = []</span><br><span class=\"line\"></span><br><span class=\"line\">  let n = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">  for(let i =0 ; i&lt;100 ; i++)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.length&lt;2)fib.push(n)</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.length&gt;=2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​      fib.push(fib[i]+fib[i-1])</span><br><span class=\"line\"></span><br><span class=\"line\">​    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">​    </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  //过滤输入数组中不是fib数组内的数</span><br><span class=\"line\"></span><br><span class=\"line\">  var arr = arr.filter(i =&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib.includes(i))return i </span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  arr.sort(function(a,b)&#123;return a-b&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">  length = arr.length</span><br><span class=\"line\"></span><br><span class=\"line\">  let FibNum = [];</span><br><span class=\"line\"></span><br><span class=\"line\">  //生成新数组并返回</span><br><span class=\"line\"></span><br><span class=\"line\">  for (let i = 0; i &lt; length; i++) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">​    let target = fib.indexOf(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    // console.log(target,fib[target],arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib[target]==arr[i])FibNum.push(arr[i]);</span><br><span class=\"line\"></span><br><span class=\"line\">​    if(fib[target]!=arr[i])break;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  return FibNum</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>当然这个方式存在大索引的fib边界问题，更好的实现应该是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function findeFibonacci(arr) &#123;</span><br><span class=\"line\">var arr1 = arr.sort(function(a, b) &#123;</span><br><span class=\"line\">    return a-b;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var tempArr = [];</span><br><span class=\"line\">tempArr.push(arr1[0], arr[1])</span><br><span class=\"line\">for(var i=2; i&lt;arr1.length;i++) &#123;</span><br><span class=\"line\">    if(arr1[i] == arr1[i-2] + arr1[i-1]) &#123;</span><br><span class=\"line\">        tempArr.push(arr1[i])</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        arr1.splice(i, 1)</span><br><span class=\"line\">        arr1 = arr1</span><br><span class=\"line\">        i--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">return tempArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0f8k8gj0006fsuh924ag8r2","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0f8k8gv0012fsuh717q81lz"},{"post_id":"cl0f8k8gj0006fsuh924ag8r2","category_id":"cl0f8k8gu000wfsuh781fgdn3","_id":"cl0f8k8gv0013fsuh05ak2e3e"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkbsr0005q8uhddvp2k1o"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0ggkbsr0006q8uh3n775f39"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkjjl0009q8uh3mi2fs88"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0ggkjjl000aq8uh9wltcg2c"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggkzvd000dq8uh5ccqhxm8"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","category_id":"cl0f8k8gs000nfsuh3u9w153m","_id":"cl0ggkzvd000eq8uhb30e8wbv"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggl1ta000hq8uhd8mf761t"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","category_id":"cl0f8k8gs000nfsuh3u9w153m","_id":"cl0ggl1ta000iq8uh0qjr623w"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggla2b000rq8uhdyqqc9f8"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","category_id":"cl0f8k8gr000jfsuh0h1988b0","_id":"cl0ggla2c000sq8uhc46a2bf7"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ggm3rd000wq8uhgo24fscd"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","category_id":"cl0f8k8gr000jfsuh0h1988b0","_id":"cl0ggm3rd000xq8uh19k55fbq"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0gio0930010q8uh09gz3de2"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0gio0940011q8uh2imu1lrw"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0gnwhp80014q8uhc61nfq35"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0gnwhp80015q8uh5dsz116j"},{"post_id":"cl0h4eij70000xcuh3alqet2r","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0h4eijg0004xcuh655yg4hn"},{"post_id":"cl0h4eij70000xcuh3alqet2r","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0h4eijg0005xcuh4im89fpv"},{"post_id":"cl0h4eij90001xcuhgda92f88","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0h4eijh0007xcuh4sudbvq8"},{"post_id":"cl0h4eij90001xcuhgda92f88","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0h4eijh0009xcuh5zjm3y4j"},{"post_id":"cl0hru2370000e0uh8i8r4neu","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0hry2es0001hsuh0xoi5f20"},{"post_id":"cl0hru2370000e0uh8i8r4neu","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0hry2es0002hsuh0ti6hai8"},{"post_id":"cl0hzb1go0000j0uh75x5hk2j","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0hzb1h10004j0uh9uxa421q"},{"post_id":"cl0hzb1go0000j0uh75x5hk2j","category_id":"cl0hzb1h00002j0uhhtn2cbgx","_id":"cl0hzb1h10005j0uh4qothyn0"},{"post_id":"cl0lj6vy40000j0uhd92691kx","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0lj6vyp0004j0uhchs7dr7v"},{"post_id":"cl0lj6vy40000j0uhd92691kx","category_id":"cl0lj6vyn0002j0uh9nh6gein","_id":"cl0lj6vyp0005j0uhdv2b29ij"},{"post_id":"cl0ljlz7a0006j0uh9gv0eyal","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ljn4jp000aj0uh6tcb9quq"},{"post_id":"cl0ljlz7a0006j0uh9gv0eyal","category_id":"cl0ljn4jo0008j0uh7edsawou","_id":"cl0ljn4jp000bj0uhcvfq4f7o"},{"post_id":"cl0lkesdc000cj0uhcmvfdvqk","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0lkh3pe000ej0uhfokm8jca"},{"post_id":"cl0lkesdc000cj0uhcmvfdvqk","category_id":"cl0f8k8gq000gfsuhbabzdsva","_id":"cl0lkh3pe000fj0uhgc788jlu"},{"post_id":"cl0ll4fj5000gj0uh2szrfuus","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0ll6t3b000ij0uha0aeewhz"},{"post_id":"cl0ll4fj5000gj0uh2szrfuus","category_id":"cl0lj6vyn0002j0uh9nh6gein","_id":"cl0ll6t3b000jj0uh94wm903c"},{"post_id":"cl0perjl100002ouh1p2raun4","category_id":"cl0f8k8gk0007fsuhcx1jh29n","_id":"cl0perjlj00022ouhgre1ao3d"},{"post_id":"cl0perjl100002ouh1p2raun4","category_id":"cl0f8k8gr000jfsuh0h1988b0","_id":"cl0perjlk00042ouh2dkw7jdq"}],"PostTag":[{"post_id":"cl0f8k8gj0006fsuh924ag8r2","tag_id":"cl0f8k8gr000ifsuh73vl7z8a","_id":"cl0f8k8gs000pfsuhaf6l5h8f"},{"post_id":"cl0ggkbsp0003q8uh1rvdgivt","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0ggkbsq0004q8uhdcxh4zke"},{"post_id":"cl0ggkjjk0007q8uh4l0m8qax","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0ggkjjl0008q8uhhzu64omp"},{"post_id":"cl0ggkzvc000bq8uhh6wdh8da","tag_id":"cl0f8k8gs000rfsuhhf76dt41","_id":"cl0ggkzvd000cq8uh9i8cey47"},{"post_id":"cl0ggl1t9000fq8uhas9s1od0","tag_id":"cl0f8k8gs000rfsuhhf76dt41","_id":"cl0ggl1ta000gq8uhcuwu8xxf"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","tag_id":"cl0f8k8gg0004fsuh7go61n5z","_id":"cl0ggla2b000pq8uhdxhe5es8"},{"post_id":"cl0ggla2a000oq8uha9bm8b8d","tag_id":"cl0f8k8gm000afsuh9ea63qua","_id":"cl0ggla2b000qq8uh9bjfhkqu"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","tag_id":"cl0f8k8gg0004fsuh7go61n5z","_id":"cl0ggm3rd000uq8uh2jni3sur"},{"post_id":"cl0ggm3rc000tq8uh1lj59ho1","tag_id":"cl0f8k8gm000afsuh9ea63qua","_id":"cl0ggm3rd000vq8uhcnod73k6"},{"post_id":"cl0gil2no000yq8uh3dge9jq3","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0gio093000zq8uh0pm23q6w"},{"post_id":"cl0gnsq8w0012q8uhdenpg29t","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0gnwhp80013q8uhgbi0481z"},{"post_id":"cl0h4eij70000xcuh3alqet2r","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0h4eija0002xcuhc54oa57u"},{"post_id":"cl0h4eij90001xcuhgda92f88","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0h4eijg0006xcuh9mhx3aw4"},{"post_id":"cl0h4eij90001xcuhgda92f88","tag_id":"cl0h4eijb0003xcuh0dfldstd","_id":"cl0h4eijh0008xcuha6pxd5ds"},{"post_id":"cl0hru2370000e0uh8i8r4neu","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0hry2er0000hsuh0z2ge593"},{"post_id":"cl0hzb1go0000j0uh75x5hk2j","tag_id":"cl0hzb1gv0001j0uh80bf3b5z","_id":"cl0hzb1h10003j0uh75nwendn"},{"post_id":"cl0lj6vy40000j0uhd92691kx","tag_id":"cl0lj6vyf0001j0uhdxqh8rqi","_id":"cl0lj6vyo0003j0uhe8jo6usq"},{"post_id":"cl0ljlz7a0006j0uh9gv0eyal","tag_id":"cl0ljn4jn0007j0uh6kue81y2","_id":"cl0ljn4jo0009j0uh6jgw0dz9"},{"post_id":"cl0lkesdc000cj0uhcmvfdvqk","tag_id":"cl0f8k8gr000mfsuhc6ww62hn","_id":"cl0lkh3pe000dj0uhafhpb2qw"},{"post_id":"cl0ll4fj5000gj0uh2szrfuus","tag_id":"cl0lj6vyf0001j0uhdxqh8rqi","_id":"cl0ll6t3b000hj0uh3kuw5da2"},{"post_id":"cl0perjl100002ouh1p2raun4","tag_id":"cl0perjla00012ouhf39nhb6w","_id":"cl0perjlk00032ouh6lgp21py"}],"Tag":[{"name":"Java","_id":"cl0f8k8gg0004fsuh7go61n5z"},{"name":"算法","_id":"cl0f8k8gm000afsuh9ea63qua"},{"name":"KrKr","_id":"cl0f8k8gr000ifsuh73vl7z8a"},{"name":"JavaScript","_id":"cl0f8k8gr000mfsuhc6ww62hn"},{"name":"Renpy","_id":"cl0f8k8gs000rfsuhhf76dt41"},{"name":"ES6","_id":"cl0h4eijb0003xcuh0dfldstd"},{"name":"CSS","_id":"cl0hzb1gv0001j0uh80bf3b5z"},{"name":"Vue","_id":"cl0lj6vyf0001j0uhdxqh8rqi"},{"name":"HTML","_id":"cl0ljn4jn0007j0uh6kue81y2"},{"name":"JavaScript,算法","_id":"cl0perjla00012ouhf39nhb6w"}]}}