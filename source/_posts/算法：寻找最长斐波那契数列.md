---
title: 算法：寻找最长斐波那契数列
copyright: false
date: 2022-03-13 22:58:01
tags: JavaScript,算法
cover: "https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203132304094.webp"
categories:
  - [技术,算法]
---

实现findFibonacci函数，在一堆正整数中，找到最长的一组斐波那契数列段。 

比如[13, 9, 3, 8, 5, 25, 31, 11, 21]， 输出[3, 5, 8, 13, 21]

```
function findFibonacci(arr){

  //生成fib数组，可能会涉及边界问题，但这样快一点

  var fib = []

  let n = 1;

  for(let i =0 ; i<100 ; i++){

​    if(fib.length<2)fib.push(n)

​    if(fib.length>=2){

​      fib.push(fib[i]+fib[i-1])

​    }

​    

  }

  //过滤输入数组中不是fib数组内的数

  var arr = arr.filter(i =>{

​    if(fib.includes(i))return i 

  })

  arr.sort(function(a,b){return a-b})

  length = arr.length

  let FibNum = [];

  //生成新数组并返回

  for (let i = 0; i < length; i++) {

​    let target = fib.indexOf(arr[i]);

​    // console.log(target,fib[target],arr[i]);

​    if(fib[target]==arr[i])FibNum.push(arr[i]);

​    if(fib[target]!=arr[i])break;

  }

  return FibNum

}
```

当然这个方式存在大索引的fib边界问题，更好的实现应该是：

```
function findeFibonacci(arr) {
var arr1 = arr.sort(function(a, b) {
    return a-b;
})
var tempArr = [];
tempArr.push(arr1[0], arr[1])
for(var i=2; i<arr1.length;i++) {
    if(arr1[i] == arr1[i-2] + arr1[i-1]) {
        tempArr.push(arr1[i])
    } else {
        arr1.splice(i, 1)
        arr1 = arr1
        i--;
    }
}
return tempArr;
}
```

