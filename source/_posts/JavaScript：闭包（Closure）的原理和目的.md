---
title: JavaScript：闭包（Closure）的原理和目的
copyright: false
date: 2022-03-07 20:07:56
tags: JavaScript
cover: "https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203072010147.webp"
categories:
  - [技术,JavaScript]
---

# JavaScript：闭包（Closure）的原理和目的

## 词法作用域

**词法作用域**（`Lexical Scopes`）是 `javascript` 中使用的作用域类型，**词法作用域** 也可以被叫做 **静态作用域**，与之相对的还有 **动态作用域**。那么 `javascript` 使用的 **词法作用域** 和 **动态作用域** 的区别是什么呢？看下面这段代码：

```
var value = 1;

function foo() {
  console.log(value);
}

function bar() {
  var value = 2;
  foo();
}

bar();
```

![image-20220307194155261](https://cdn.jsdelivr.net/gh/Zhuxb-Clouds/PicDepot/img/202203071941308.png)

上面这段代码中，一共有三个作用域：

- 全局作用域
- `foo` 的函数作用域
- `bar` 的函数作用域

一直到这边都好理解，可是 `foo` 里访问了本地作用域中没有的变量 `value` 。根据前面说的，引擎为了拿到这个变量就要去 `foo` 的上层作用域查询，那么 `foo` 的上层作用域是什么呢？是它 **调用时** 所在的 bar 作用域？还是它 **定义时** 所在的全局作用域？

这个关键的问题就是 `javascript` 中的作用域类型——**词法作用域。**

> 词法作用域，就意味着函数被定义的时候，它的作用域就已经确定了，和拿到哪里执行没有关系，因此词法作用域也被称为 “静态作用域”。

**词法作用域（Lexical Scope）** 是定义表达式并能被访问的区间。

换言之，一个声明（定义变量、函数等）的词法作用域就是它被定义时所在的作用域。

**注意：**

- 词法作用域又叫静态作用域。
- 一个声明 **被调用时的作用域** 不一定是它的词法作用域。相反的，**定义时的作用域** 才是词法作用域

### 一个词法作用域的小示例

考虑如下代码：

```js
// 定义一个全局作用域变量：
const myName = "Oluwatobi";

// 在函数体内调用myName变量
function getName() {
  return myName;
}

console.log(getName()) // 'Oluwatobi'
```

在上述示例中，我们在全局作用域定义了`myName`变量，并在`getName()`函数作用域内调用了该变量。

**问题：** `myName`变量的词法作用域是什么？全局作用域还是 `getName()`的局部作用域？

**答案：** 切记 **词法作用域** 意味着 **定义时的作用域**，并不是**调用时的作用域** 。因此`myName`变量的词法作用域是全局作用域，因为我们在全局环境下定义了`myName`变量。

**换言之，函数的作用域在它的定义的时候就已经确定了。**

### 作用域[scope]与上下文[context]的相似与区别

context指的是this对象，而scope指的是可以获取的变量范围，类似于python中命名空间的感觉。

并且它们的创建者不同

- 作用域是**词法分析**创建，静态
- 执行上下文由**js引擎**创建，动态

## 闭包

一句话定义闭包，就是**能够访问其他函数内部变量的函数，被称为 *闭包***

一般闭包的表现形式是：**闭包就是函数内部定义的函数，被返回了出去并在外部调用**。

```
function foo() {
  var a = 2;

  function bar() {
    console.log( a );
  }

  return bar;
}

var baz = foo();

baz(); // 这就形成了一个闭包
```

我们可以简单剖析一下上面代码的运行流程：

1. 编译阶段，变量和函数被声明，作用域即被确定。
2. 运行函数 `foo()`，此时会创建一个 `foo` 函数的执行上下文，执行上下文内部存储了 `foo` 中声明的所有变量函数信息。
3. 函数 `foo` 运行完毕，将内部函数 `bar` 的引用赋值给外部的变量 `baz` ，此时 `baz` 指针指向的还是 `bar` ，因此哪怕它位于 `foo` 作用域之外，它还是能够获取到 `foo` 的内部变量。
4. `baz` 在外部被执行，`baz` 的内部可执行代码 `console.log` 向作用域请求获取 `a` 变量，本地作用域没有找到，继续请求父级作用域，找到了 `foo` 中的 `a` 变量，返回给 `console.log`，打印出 `2`。

闭包绕过了作用域的规则，将内部函数的变量返回给外部函数。

### 闭包的目的

#### 1.延长变量存活时间

在js中存在垃圾回收机制，一定时间不使用的变量会被回收释放内存，而闭包可以让变量一直被依赖从而无法被自动回收，延长了变量存活时间。

#### 2.创造私有作用域

`javascript` 没有 `java` 中那种 `public` `private` 的访问权限控制，对象中的所用方法和属性均可以访问，这就造成了安全隐患，内部的属性任何开发者都可以随意修改。虽然语言层面不支持私有属性的创建，但是我们可以用闭包的手段来模拟出私有属性。

### 闭包的问题：内存泄露

我们知道，`javascript` 内部的垃圾回收机制用的是引用计数收集：即当内存中的一个变量被引用一次，计数就加一。垃圾回收机制会以固定的时间轮询这些变量，将计数为 `0` 的变量标记为失效变量并将之清除从而释放内存。

然而，因为闭包中创建的变量会被错误的认为一直被依赖，所以不会释放内存，一旦闭包使用过度就会导致内存占用无法释放，即内存泄露。

当然，造成内存泄露的原因有很多，除了闭包以外，还有 **全局变量的无意创建**。开发者的本意是想将变量作为局部变量使用，然而忘记写 `var` 导致变量被泄露到全局中。

还有 `DOM` 的事件绑定，移除 `DOM` 元素前如果忘记了注销掉其中绑定的事件方法，也会造成内存泄露。
